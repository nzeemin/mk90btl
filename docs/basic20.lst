; Elektronika MK-90 main ROM disassembly, BASIC V2.0
; The disassembly made by Piotr Piatek
; Converted to octals by nzeemin

; The MK-92 ROM consists of 4 pages of 4000 bytes size and shares the address
; range 4000-7FFF with the MK-90 test ROM.
; Function of individual bits (bit numbers are decimal) of the register E880:
; Bit 13	- switches the ROM banks, enables the MK-92 ROM when set
; Bits 12,11	- select the MK-92 ROM page

000000:
000004:				; odd address when accessing word size data,
				; accessing nonexisting memory,
				; HALT in the user mode,
				; JMP/JSR with a register as the destination
000010:				; unimplemented instruction
000014:				; vector BPT
000020:				; vector IOT
000024:				; vector POK (power supply)
000030:				; vector EMT
000034:	.WORD	100212		; vector TRAP
000050:	.WORD	000000
000100:	.WORD	137326, 000000	; EVNT interrupt vector (timer)
000170:				; INT0 interrupt vector
000174:				; INT1 interrupt vector
000270:				; INT2 interrupt vector
000274:				; INT3 interrupt vector
000310:	.WORD	136550, 000000	; keyboard controller interrupt vector
000374:	.WORD	142656, 000000
001000:	.BLKB	001700		; display RAM
002700:				; USRBUF
006074:	.WORD	000007		; height of a character in pixels
006076:	.WORD	000005		; width of a character in pixels
006100:	.WORD	000043		; number of bits to store each character in
				; the font table
006402:	.WORD	001000		; address of the display RAM
006424:	.WORD	000100		; height of the screen in pixels
006426:	.WORD	000170		; width of the screen in pixels
006434:	.WORD	000160
006534:	.BLKW	001		; print mode
				; bit 6 set - output to the plotter
				; bit 0 set - inverted print mode
006606:	.BLKW	001		; key scan code
007156:	.BLKW	001		; SU keyboard mode if not zero
007236:	.BLKB	000120		; input line buffer (up to 80 characters)
007360:	.BLKW	001		; current line number
007424:	.BLKW	001		; counter decremented at each EVNT interrupt
007430:	.BLKW	001		; flag of a pressed key
007520:	.BLKB	004		; address in a memory module (big endian order)
				; RAM module - used bytes 0F52..0F53
				; ROM module - used bytes 0F51..0F53
007524:	.BLKW	001		; memory module type: 0=read/write, 1=read only

; default system error handler routine
100000:	MOV	(SP)+,R1	; get the PC
100002:	TST	(SP)+		; drop the PSW
100004:	MOV	#C8B,R0		; buffer for the octal number 0C85-0C8A
100010:	MOV	#006,R4		; number of digits
100014:	CALL	100032	; convert the word in r1 to octal ASCII
100020:	MOV	#C78,R0		; string 'SBOJ PO ADR'
100024:	TRAP	066		; print a string pointed to by r0
100026:	JMP	103254		; restart the BASIC system

; convert the word in r1 to octal ASCII, number of digits in r4
100032:	MOV	R1,R2
100034:	BIC	#177770,R2
100040:	BIS	#060,R2		; '0'
100044:	MOVB	R2,-(R0)
100046:	CLC
100050:	ROR	R1
100052:	ASR	R1
100054:	ASR	R1
100056:	SOB	R4,100032	; next digit
100060:	RETURN

; trap 6C
100062:	MOV	006402,R1	; address of the display RAM
100066:	MOV	#000740,R2	; size of the display RAM (03C0 bytes)
100072:	CLR	(R1)+
100074:	SOB	R2,100072
100076:	MOV	006402,@#164000	; address of the display RAM
100104:	MOV	#104306,@#164002
100112:	MOV	#136550,@#310	; keyboard controller interrupt vector
100120:	CLR	@#312
100124:	MOV	#001000,@#164022
100132:	MOV	#342,@#164024
100140:	CALL	141066
100144:	CLR	@#050
100150:	MOV	#137326,@#100	; EVNT (timer) interrupt vector
100156:	CLR	@#102
100162:	MOV	#142656,@#374
100170:	CLR	@#376
100174:	TST	@#164036
100200:	BMI	100210
100202:	BIS	#040040,@#164200
100210:	RETURN

; TRAP handler routine
100212:	MOV	(SP),000002(SP)
100216:	SUB	#002,(SP)
100222:	MOV	@(SP)+,-(SP)
100224:	ASR	(SP)
100226:	BLO	100240
; even traps = system function calls
100230:	ASL	(SP)
100232:	ADD	#174022,(SP)	; 174022 + TRAP_0_opcode = 100422
100236:	MOV	@(SP)+,PC
; odd traps = error_codes * 2 + 1
100240:	BIC	#177600,(SP)
100244:	MOV	(SP)+,R2
100246:	CMP	R2,#100
100252:	BGT	100276		; recoverable errors (error code > 64)
; unrecoverable errors (error code <= 64)
100254:	CLR	007374
100260:	MOV	#001,006374
100266:	MOV	006400,SP
100272:	MOV	#105126,-(SP)
100276:	TST	007416
100302:	BLE	100326
100304:	MOV	007416,R0
100310:	MOV	007360,007412
100316:	NEG	007416
100322:	JMP	105556
;
100326:	MOV	R1,-(SP)
100330:	MOV	006110,-(SP)
100334:	CALL	125226
100340:	CLR	007440
100344:	MOV	R2,R1
100346:	MOV	R2,007414
100352:	MOV	007360,007412
100360:	MOV	#C90,R0		; address of the error code as an ASCII string
100364:	MOV	R1,-(SP)	; error code
100366:	TRAP	012		; ITOA
100370:	TRAP	002		; print CR, LF
100372:	MOV	#006215,R0	; string 'OSH        STR ' - error X in line X
100376:	TRAP	066		; print a string pointed to by r0
100400:	TRAP	004		; display the line number 0EF0
100402:	TRAP	002		; print CR, LF
100404:	TST	(SP)+
100406:	BNE	100412
100410:	TRAP	116
100412:	MOV	(SP)+,006110
100416:	MOV	(SP)+,R1
100420:	RETURN

; TRAP vectors
100422:	.WORD	100646, 100722, 102312, 111576		; trap 000, 002, 004, 006
100432:	.WORD	113142, 113210, 113270, 113454		; trap 010, 012, 014, 016
100442:	.WORD	113720, 114144, 114202, 114252		; trap 020, 022, 024, 026
100452:	.WORD	114500, 115012, 115026, 114670		; trap 030, 032, 034, 036
100462:	.WORD	115200, 115172, 116452, 116550		; trap 040, 042, 044, 046
100472:	.WORD	116472, 116342, 115056, 116466		; trap 050, 052, 054, 056
100502:	.WORD	117630, 113500, 113540, 100734		; trap 060, 062, 064, 066
100512:	.WORD	100600, 101274, 101726, 101670		; trap 070, 072, 074, 076
100522:	.WORD	100770, 101716, 102134, 102060		; trap 100, 102, 104, 106
100532:	.WORD	101306, 101410, 101506, 101326		; trap 110, 112, 114, 116
100542:	.WORD	101660, 101606, 102042, 101774		; trap 120, 122, 124, 126
100552:	.WORD	102346, 102152, 102362, 106136		; trap 130, 132, 134, 136
100562:	.WORD	102400, 102414, 107502, 101352		; trap 140, 142, 144, 146
100572:	.WORD	101372, 000000, 100062			; trap 150, 152, 154

; trap 070 - test if r2 is a digit
; returns V set if r2 is not a digit
; returns Z set if r2 is a decimal digit '0'..'9'
; returns V cleared if r2 is a hex digit 'A'..'F'
100600:	CMP	R2,#060		; '0'
100604:	BLT	100640
100606:	CMP	R2,#071		; '9'
100612:	BGT	100620
100614:	SET	Z		; decimal digit: Z=1, V=0
100616:	RETURN
100620:	CMP	R2,#101		; 'A'
100624:	BLT	100640
100626:	CMP	R2,#132		; 'Z'
100632:	BGT	100640
100634:	CLEAR	CVZN		; hexadecimal digit: Z=0, V=0
100636:	RETURN
100640:	CLEAR	CVZN
100642:	SET	V		; not a digit: Z=0, V=1
100644:	RETURN

; trap 000 - print character r2
100646:	MOV	R1,-(SP)
100650:	TST	007376
100654:	BEQ	100664
100656:	CALL	155564
100662:	BR	100716
100664:	TST	007440
100670:	BEQ	100700
100672:	CALL	050044
100676:	BR	100716
100700:	TST	006374
100704:	BEQ	100716
100706:	INC	006376
100712:	CALL	120034		; display character r2
100716:	MOV	(SP)+,R1
100720:	RETURN

; trap 002 - print CR, LF
100722:	MOV	#177776,007372
100730:	MOV	#105045,R0	; string CR, LF

; trap 066 - print a zero terminated string pointed to by r0
100734:	MOVB	(R0)+,R2
100736:	BEQ	100720
100740:	TRAP	000		; print character r2
100742:	BR	100734

100744:	CALL	122462
100750:	TST	007374
100754:	BNE	100774
100756:	CMP	#007236,R3
100762:	BHIS	100770
100764:	DEC	R3
100766:	BR	100774

; trap 100 - input a line from the keyboard
; returns a pointer to the input buffer in R1
100770:	MOV	#007236,R3	; input line buffer
100774:	TST	007374
101000:	BEQ	101014
101002:	CLR	006374
101006:	CALL	155012
101012:	BR	101026
101014:	INC	006376
101020:	CALL	137472		; wait for a key
101024:	BEQ	100774
101026:	BIC	#177600,R2
101032:	CMPB	R2,#020
101036:	BEQ	101204
101040:	CMPB	#015,R2
101044:	BNE	101056
101046:	TRAP	002		; print CR, LF
101050:	MOV	#012,R2
101054:	BR	101130
101056:	CMPB	#177,R2
101062:	BEQ	100744
101064:	CMPB	#025,R2
101070:	BEQ	101164
101072:	CMPB	#012,R2
101076:	BEQ	101126
101100:	CMPB	#016,R2
101104:	BEQ	101126
101106:	CMPB	#017,R2
101112:	BEQ	101126
101114:	CMPB	#040,R2
101120:	BLE	101126
101122:	MOVB	#077,R2
101126:	TRAP	000		; print character r2
101130:	MOVB	R2,(R3)+
101132:	CMPB	R2,#012
101136:	BEQ	101150
101140:	CMP	R3,#EEF
101144:	BLO	100774		; branch if less than or equal 80 characters
101146:	TRAP	031		; error 12 - input line too long
101150:	MOV	#007236,R1	; input line buffer
101154:	MOV	#001,006374
101162:	RETURN
101164:	MOVB	#136,R2
101170:	TRAP	000		; print character r2
101172:	MOVB	#125,R2
101176:	TRAP	000		; print character r2
101200:	TRAP	002		; print CR, LF
101202:	BR	100770
101204:	CLR	-(SP)
101206:	MOV	#103276,-(SP)
101212:	MOV	R2,-(SP)
101214:	BR	101244
101216:	TRAP	007		; error 3 - illegal character
101220:	MOV	R2,-(SP)
101222:	CALL	137472		; wait for a key
101226:	BIC	#177600,R2
101232:	CMPB	R2,#020
101236:	BEQ	101244
101240:	MOV	(SP)+,R2
101242:	RTI
101244:	MOV	006374,-(SP)
101250:	CALL	125226
101254:	CLR	007440
101260:	MOV	(SP)+,006374
101264:	MOV	#001,007400
101272:	BR	101240

; trap 072 - GETNSC, get a character other than space
101274:	MOVB	(R1)+,R2
101276:	CMP	#040,R2
101302:	BEQ	101274
101304:	RETURN

; trap 110
101306:	CMPB	(R1),#072
101312:	BEQ	101324
101314:	CMPB	(R1)+,#012
101320:	BNE	101306
101322:	DEC	R1
101324:	RETURN

; trap 116
101326:	CLR	007370
101332:	TST	007366
101336:	BEQ	101350
101340:	MOV	007366,R5
101344:	CLR	007366
101350:	RETURN

; trap 146
101352:	TRAP	112
101354:	CLR	R0
101356:	TRAP	112
101360:	MOV	R5,R0
101362:	TRAP	112
101364:	TRAP	112
101366:	TRAP	112
101370:	RETURN

; trap 150
101372:	MOV	R2,R0
101374:	TRAP	112
101376:	MOV	R3,R0
101400:	TRAP	112
101402:	MOV	R4,R0
101404:	TRAP	112
101406:	RETURN

; trap 112
101410:	MOV	R4,-(SP)
101412:	MOV	R5,R4
101414:	ADD	#024,R4
101420:	CMP	R4,SP
101422:	BHIS	101454
101424:	TST	007366
101430:	BNE	101446
101432:	MOV	R5,007366
101436:	INC	R5
101440:	ASR	R5
101442:	CLC
101444:	ASL	R5
101446:	MOV	R0,(R5)+
101450:	MOV	(SP)+,R4
101452:	RETURN
101454:	TRAP	001		; error 0 - out of memory
101456:	MOV	(R3),R0
101460:	BIC	(SP),R0
101462:	CMP	R0,R4
101464:	BEQ	101534
101466:	BIC	#017777,R0
101472:	CMP	#040000,R0
101476:	BNE	101544
101500:	ADD	#020,R3
101504:	BR	101522

; trap 114
101506:	TST	R3
101510:	BEQ	101542
101512:	CMP	R5,SP
101514:	BHIS	101454
101516:	MOV	R1,-(SP)
101520:	MOV	R0,-(SP)
101522:	CMP	R3,SP
101524:	BHIS	101454
101526:	CMP	R3,R5
101530:	BLO	101456
101532:	CLR	R3
101534:	MOV	(SP)+,R0
101536:	MOV	(SP)+,R1
101540:	TST	R3
101542:	RETURN
101544:	BGT	101560
101546:	ADD	#002,R3
101552:	ADD	#004,R3
101556:	BR	101522
101560:	TST	R0
101562:	BEQ	101570
101564:	TST	(R3)+
101566:	BR	101522
101570:	MOVB	000002(R3),R0
101574:	MOVB	000003(R3),R1
101600:	TRAP	122
101602:	ADD	R0,R3
101604:	BR	101552

; trap 122
101606:	BIC	#177400,R0
101612:	BIC	#177400,R1
101616:	INC	R0
101620:	INC	R1
101622:	MOV	R4,-(SP)
101624:	MOV	R3,-(SP)
101626:	TRAP	016		; IMUL
101630:	MOV	(SP)+,R3
101632:	MOV	(SP)+,R4
101634:	TST	R1
101636:	BNE	101654
101640:	CMP	R0,#022000
101644:	BHIS	101654
101646:	TRAP	130		; multiply r0 by 6
101650:	CLEAR	CVZN
101652:	RETURN
101654:	SET	V
101656:	RETURN

; trap 120
101660:	MOV	R3,R1
101662:	MOV	R1,R2
101664:	ADD	R4,R1
101666:	BR	101700

; trap 076
101670:	TRAP	116
101672:	MOV	R1,R3
101674:	MOV	R1,R2
101676:	TRAP	102		; move the pointer r1 to the end of the line
101700:	CMP	R1,R5
101702:	BHIS	101710
101704:	MOVB	(R1)+,(R3)+
101706:	BR	101700
101710:	MOV	R3,R5
101712:	MOV	R2,R1
101714:	RETURN

; trap 102 - move the pointer r1 to the end of the line
101716:	CMPB	(R1)+,#012
101722:	BNE	101716
101724:	RETURN

; trap 074
101726:	MOV	007362,R1
101732:	TRAP	102		; move the pointer r1 to the end of the line
101734:	CMP	R1,R5
101736:	BHIS	101766
101740:	MOV	R0,-(SP)
101742:	MOV	R1,-(SP)
101744:	TRAP	010		; ATOI
101746:	MOV	(SP)+,R1
101750:	MOV	R0,R2
101752:	MOV	(SP)+,R0
101754:	CMP	R0,R2
101756:	BGT	101732
101760:	BEQ	101764
101762:	CLEAR	CVZN
101764:	RETURN
101766:	CLEAR	CVZN
101770:	SET	V
101772:	RETURN

; trap 126 - get a variable name (single letter or a letter followed by
; a single digit)
; returned values:
; r1 - pointer to the parsed string
; r2 - first unprocessed character other than space
; r4 - letter code in bits 11-6, digit in ASCII format in bits 5-0
; V flag cleared if name found
101774:	TRAP	072		; get a character other than space to r2
101776:	TRAP	070		; is r2 a digit?
102000:	BEQ	102036		; branch if yes
102002:	BVS	102036
102004:	BIC	#177700,R2
102010:	MOV	R2,R4
102012:	SWAB	R4
102014:	ASR	R4
102016:	ASR	R4
102020:	TRAP	072		; get a character other than space to r2
102022:	TRAP	070		; is r2 a digit?
102024:	BNE	102032		; branch if not
102026:	BIS	R2,R4
102030:	TRAP	072		; get a character other than space to r2
102032:	CLEAR	CVZN
102034:	RETURN
102036:	SET	V
102040:	RETURN

; trap 124
102042:	TST	R0
102044:	BLT	101762
102046:	CMP	R0,#377
102052:	BGT	101762
102054:	SET	Z
102056:	RETURN

; trap 106 - get a pair of integer numbers separated by a comma
; on entry r1 points to the parsed string
; returned values:
; r3 <- first number
; r4 <- second number
; r2 <- separator between numbers
102060:	TRAP	072		; get a character other than space to r2
102062:	TRAP	070		; is r2 a digit?
102064:	BNE	102124		; branch if r2 is not a decimal digit
102066:	DEC	R1
102070:	TRAP	010		; ATOI
102072:	MOV	R0,-(SP)
102074:	TRAP	072		; get a character other than space to r2
102076:	CMP	#054,R2		; comma?
102102:	BNE	102130
102104:	MOV	R2,-(SP)
102106:	TRAP	010		; ATOI
102110:	MOV	(SP)+,R2
102112:	TST	R0
102114:	BEQ	102130
102116:	MOV	R0,R4
102120:	MOV	(SP)+,R3
102122:	RETURN
102124:	CLR	-(SP)
102126:	BR	102076
102130:	CLR	R4
102132:	BR	102120

; trap 104 - check the available stack space
102134:	MOV	R5,R4
102136:	ADD	R0,R4
102140:	MOV	SP,R3
102142:	SUB	#070,R3
102146:	CMP	R3,R4
102150:	RETURN

; trap 132
102152:	MOV	R3,-(SP)
102154:	TRAP	136		; evaluate an arithmetical expression
102156:	BVS	102256
102160:	CMPB	(R1),#054
102164:	BNE	102264
102166:	CALL	102270
102172:	TRAP	072		; get a character other than space to r2
102174:	MOV	R0,-(SP)
102176:	TRAP	136		; evaluate an arithmetical expression
102200:	BVC	102264
102202:	TRAP	040		; FIX
102204:	BMI	102266
102206:	MOV	(SP)+,R2
102210:	MOV	@000000(SP),R4
102214:	BIC	#177400,R4
102220:	CMP	R0,R4
102222:	BGT	102266
102224:	MOV	R1,-(SP)
102226:	MOV	R2,R1
102230:	MOV	R0,-(SP)
102232:	MOV	R4,R0
102234:	INC	R0
102236:	TRAP	016		; IMUL
102240:	ADD	(SP)+,R0
102242:	MOV	(SP)+,R1
102244:	TRAP	130		; multiply r0 by 6
102246:	MOV	(SP)+,R3
102250:	ADD	R3,R0
102252:	TST	(R0)+
102254:	RETURN
102256:	CALL	102270
102262:	BR	102244
102264:	TRAP	013		; error 5 - incorrect index
102266:	TRAP	015		; error 6 - index out of range
102270:	TRAP	040		; FIX
102272:	BMI	102266
102274:	MOV	@000002(SP),R4
102300:	CLRB	R4
102302:	SWAB	R4
102304:	CMP	R0,R4
102306:	BGT	102266
102310:	RETURN

; trap 004 - display the line number 0EF0
102312:	SUB	#010,SP
102316:	MOV	SP,R0		; buffer for the string on the stack
102320:	MOV	007360,R1
102324:	TRAP	012		; ITOA
102326:	MOV	SP,R0
102330:	TST	(R0)+
102332:	CLRB	000007(SP)
102336:	TRAP	066		; print a string pointed to by r0
102340:	ADD	#010,SP
102344:	RETURN

; trap 130 - multiply r0 by 6
102346:	CLC
102350:	ASL	R0		; * 2
102352:	MOV	R0,-(SP)
102354:	ASL	R0		; * 4
102356:	ADD	(SP)+,R0	; * 6
102360:	RETURN

; trap 134 - pointer to the beginning of the variable table
102362:	MOV	007366,R3
; align r3 to a word boundary
102366:	INC	R3
102370:	ASR	R3
102372:	CLC
102374:	ASL	R3
102376:	RETURN

; trap 140 - get a pair of characters other than space to r4
102400:	TRAP	072		; get a character other than space to r2
102402:	MOV	R2,R4
102404:	SWAB	R4
102406:	TRAP	072		; get a character other than space to r2
102410:	BIS	R2,R4
102412:	RETURN

; trap 142 - MOVSTK, push r4,r3,r2 on the stack
102414:	MOV	R3,-(SP)
102416:	MOV	R2,-(SP)
102420:	MOV	000004(SP),-(SP)	; push the return address on the stack
102424:	MOV	R4,000006(SP)
102430:	CMP	R5,SP
102432:	BHIS	102436
102434:	RETURN
102436:	TRAP	001		; error 0 - out of memory

; command LIST
102440:	INC	006616
102444:	CLR	006622
102450:	CLR	007500
102454:	TRAP	072		; get a character other than space to r2
102456:	CMPB	R2,#052
102462:	BNE	102472
102464:	INC	007500
102470:	BR	102506
102472:	DEC	R1
102474:	CALL	166000
102500:	TST	006620
102504:	BNE	103046
102506:	TRAP	116
102510:	TRAP	106		; get a pair of integer numbers
102512:	MOV	R3,R0		; first number
102514:	BNE	102744
102516:	MOV	007362,R3
102522:	TST	R4		; second number
102524:	BNE	102774
102526:	MOV	R5,R4
102530:	TST	007400
102534:	BNE	103046
102536:	MOVB	(R3)+,R2
102540:	NOP
102542:	NOP
102544:	BPL	102624
102546:	BIC	#177600,R2
102552:	MOV	#104170,R0
102556:	MOV	R2,R1
102560:	DEC	R1
102562:	BLT	102574
102564:	CMPB	(R0)+,#044
102570:	BNE	102564
102572:	BR	102560
102574:	MOVB	(R0)+,R2
102576:	CMPB	R2,#044
102602:	BEQ	102530
102604:	TST	007500
102610:	BEQ	102620
102612:	CMPB	R2,#047
102616:	BEQ	102574
102620:	TRAP	000		; print character r2
102622:	BR	102574
102624:	CMPB	R2,#012
102630:	BEQ	102636
102632:	TRAP	000		; print character r2
102634:	BR	102530
102636:	TRAP	002		; print CR, LF
102640:	TST	007376
102644:	BNE	102700
102646:	TST	007440
102652:	BNE	102700
102654:	TST	006622
102660:	BEQ	102674
102662:	CALL	137472		; wait for a key
102666:	CMP	R2,#015
102672:	BNE	102662
102674:	INC	006622
102700:	CMP	R3,R4
102702:	BHIS	102722
102704:	TST	007500
102710:	BEQ	102530
102712:	MOV	R3,R1
102714:	TRAP	010		; ATOI
102716:	MOV	R1,R3
102720:	BR	102530
102722:	CLR	007440
102726:	TST	007376
102732:	BEQ	102740
102734:	CALL	155644
102740:	JMP	103326
102744:	MOV	R4,-(SP)
102746:	MOV	R2,-(SP)
102750:	TRAP	074
102752:	MOV	(SP)+,R2
102754:	MOV	(SP)+,R4
102756:	CMP	R1,R5
102760:	BHI	102516
102762:	TST	007500
102766:	BEQ	102772
102770:	DEC	R1
102772:	MOV	R1,R3
102774:	TST	R4
102776:	BNE	103006
103000:	CMP	#054,R2
103004:	BEQ	102526
103006:	CMP	R4,R0
103010:	BLE	103030
103012:	MOV	R4,R0
103014:	MOV	R3,-(SP)
103016:	TRAP	074
103020:	BNE	103036
103022:	MOV	(SP)+,R3
103024:	CMP	R1,R5
103026:	BHI	102526
103030:	TRAP	102		; move the pointer r1 to the end of the line
103032:	MOV	R1,R4
103034:	BR	102530
103036:	MOV	(SP)+,R3
103040:	CMP	R1,R5
103042:	BHI	102526
103044:	BR	103032
103046:	JMP	103276

; command DELETE
103052:	TRAP	116
103054:	TRAP	106		; get a pair of integer numbers
103056:	MOV	007362,R1
103062:	TST	R4
103064:	BNE	103070
103066:	MOV	R3,R4
103070:	MOV	R4,-(SP)	; second number
103072:	MOV	R3,-(SP)	; first number
103074:	TRAP	102		; move the pointer r1 to the end of the line
103076:	CMP	R1,R5
103100:	BHIS	103126
103102:	MOV	R1,-(SP)
103104:	TRAP	010		; ATOI
103106:	MOV	(SP)+,R1
103110:	CMP	R0,(SP)
103112:	BLT	103074
103114:	CMP	R0,000002(SP)
103120:	BGT	103126
103122:	TRAP	076
103124:	BR	103076
103126:	CMP	(SP)+,(SP)+
103130:	BR	103332
103132:	TRAP	116
103134:	TRAP	074
103136:	BNE	103166
103140:	TRAP	076
103142:	BR	103166
103144:	CALL	101274		; get a character other than space
103150:	CMPB	#072,R2
103154:	BEQ	103546
103156:	CMPB	#012,R2
103162:	BEQ	103166
103164:	TRAP	007		; error 3 - illegal character
103166:	BIT	#020,006534
103174:	BEQ	103202
103176:	MOV	(SP)+,R2
103200:	JMP	(R2)
103202:	TST	007364
103206:	BEQ	103406
103210:	TST	007366
103214:	BEQ	103224
103216:	CMP	R1,007366
103222:	BR	103226
103224:	CMP	R1,R5
103226:	BHIS	103610
103230:	TST	007410
103234:	BEQ	103242
103236:	CALL	151072
103242:	CALL	113142
103246:	MOV	R0,007360
103252:	BR	103546

; start the BASIC system
103254:	JMP	117716

; command SYSTEM
103260:	JMP	173000		; system restart

; command NEW
103264:	MOV	007362,R5
103270:	INC	R5
103272:	CLR	007366
103276:	MOV	006400,SP
103302:	CLR	007374
103306:	CLR	007400
103312:	CLR	007360
103316:	MOV	#001,006374
103324:	TRAP	002		; print CR, LF
103326:	CLR	007376
103332:	CLR	007364
103336:	CLR	007440
103342:	CALL	125226
103346:	CLR	007470
103352:	CLR	007432
103356:	CLR	006616
103362:	CLR	007416
103366:	MOV	006110,-(SP)
103372:	MOV	#105034,R0	; string 'Gotov' (Ready)
103376:	TRAP	066		; print a string pointed to by r0
103400:	MOV	(SP)+,006110
103404:	TRAP	002		; print CR, LF
103406:	CLR	007400
103412:	TST	006560
103416:	BEQ	103432
103420:	CALL	122766
103424:	CALL	100774
103430:	BR	103434
103432:	TRAP	100		; input a line from the keyboard
103434:	TRAP	072		; get a character other than space to r2
103436:	CMP	R2,#012
103442:	BEQ	103406
103444:	MOV	#007236,R1		; input line buffer
103450:	TRAP	010		; ATOI
103452:	CMPB	(R1),#012
103456:	BEQ	103132
103460:	MOV	R1,R3
103462:	CALL	105136
103466:	BLO	103472
103470:	BR	103632
103472:	MOV	#104170,R0
103476:	CLR	R2
103500:	CMPB	(R3)+,#040
103504:	BEQ	103500
103506:	CMPB	-(R3),(R0)+
103510:	BNE	103524
103512:	INC	R3
103514:	CMPB	(R0),#044
103520:	BEQ	103624
103522:	BR	103500
103524:	CMPB	(R0)+,#044
103530:	BNE	103524
103532:	CMPB	(R0),#044
103536:	BEQ	103614
103540:	MOV	R1,R3
103542:	INC	R2
103544:	BR	103500
103546:	TST	007400
103552:	BNE	103276
103554:	CALL	101274		; get a character other than space
103560:	BPL	103576
103562:	DEC	R1
103564:	CALL	105136
103570:	BLO	103622
103572:	JMP	107562
103576:	BIC	#177600,R2
103602:	ASL	R2
103604:	JMP	@104646(R2)
103610:	JMP	105074
103614:	TST	007374
103620:	BNE	103632
103622:	TRAP	003		; error 1 - unknown operator
103624:	ADD	#200,R2
103630:	MOVB	R2,(R1)+
103632:	MOV	R1,R4
103634:	MOVB	(R3),(R1)+
103636:	CMPB	(R3)+,#012
103642:	BNE	103634
103644:	CMPB	R2,#203
103650:	BEQ	104032
103652:	CMPB	R2,#243
103656:	BEQ	104032
103660:	CMP	R2,#215
103664:	BNE	103760
103666:	MOV	R4,R1
103670:	TRAP	072		; get a character other than space to r2
103672:	CMPB	R2,#124		; 'T'
103676:	BNE	103744
103700:	TRAP	072		; get a character other than space to r2
103702:	CMPB	R2,#110		; 'H'
103706:	BNE	103672
103710:	TRAP	072		; get a character other than space to r2
103712:	CMPB	R2,#105		; 'E'
103716:	BNE	103672
103720:	TRAP	072		; get a character other than space to r2
103722:	CMPB	R2,#116		; 'N'
103726:	BNE	103672
103730:	TRAP	072		; get a character other than space to r2
103732:	DEC	R1
103734:	MOV	R1,R4
103736:	TRAP	070		; is r2 a digit?
103740:	BEQ	103760		; branch if r2 is a decimal digit
103742:	BR	103460
103744:	CMPB	R2,#012
103750:	BEQ	104032
103752:	CMPB	R2,#072
103756:	BNE	103670
103760:	MOV	R4,R1
103762:	CMPB	(R1),#042
103766:	BEQ	104010
103770:	CMPB	(R1)+,#072
103774:	BEQ	103730
103776:	CMPB	-(R1),#012
104002:	BEQ	104030
104004:	INC	R1
104006:	BR	103762
104010:	INC	R1
104012:	CMPB	(R1),#042
104016:	BEQ	104004
104020:	CMPB	(R1),#012
104024:	BNE	104010
104026:	TRAP	063		; error 25 - mismatched quotation marks
104030:	INC	R1
104032:	MOV	R1,R3
104034:	MOV	#007236,R1	; input line buffer
104040:	TRAP	072		; get a character other than space to r2
104042:	TRAP	070		; is r2 a digit?
104044:	BEQ	104052		; branch if r2 is a decimal digit
104046:	DEC	R1
104050:	BR	103546
104052:	TRAP	116
104054:	MOV	#007236,R1	; input line buffer
104060:	SUB	R1,R3
104062:	MOV	R3,-(SP)
104064:	TRAP	010		; ATOI
104066:	TST	R0
104070:	BEQ	104166
104072:	CMP	R0,#017777
104076:	BGT	104166
104100:	TRAP	074
104102:	BNE	104106
104104:	TRAP	076
104106:	MOV	(SP)+,R3
104110:	TRAP	116
104112:	MOV	R3,R0
104114:	TRAP	104		; check the available stack space
104116:	BHIS	104126
104120:	TRAP	001		; error 0 - out of memory
104122:	ADD	R0,R5
104124:	BR	104146
104126:	CMP	R1,R5
104130:	BHIS	104122
104132:	MOV	R5,R2
104134:	ADD	R0,R5
104136:	MOV	R5,R4
104140:	MOVB	-(R2),-(R4)
104142:	CMP	R1,R2
104144:	BLOS	104140
104146:	MOV	#007236,R2	; input line buffer
104152:	MOVB	(R2),(R1)+
104154:	CMPB	(R2)+,#012
104160:	BNE	104152
104162:	JMP	103166
104166:	TRAP	041		; error 16 - wrong line number or dimension

; keyword codes 80..BA
104170:	.ASCII	'LIST$', 'LET$', 'READ$', 'REM$'
104212:	.ASCII	'RUN$', 'RESTORE$', 'RETURN$', 'DATA$'
104242:	.ASCII	'DIM$', 'DELETE$', 'PRINT$', 'GOSUB$'
104271:	.ASCII	'GOTO$', 'IF$', 'FOR$', 'NEXT$'
104312:	.ASCII	'INPUT$', 'SAVE$', 'STOP$', 'END$'
104336:	.ASCII	'DEF$', 'LOAD$', 'RANDOMIZE$', 'INIT$'
104366:	.ASCII	'KILL$', 'DRAW$', 'DIS$', 'CLS$'
104410:	.ASCII	'LOCATE$', 'WAIT$', 'PLAY$', 'AUTO$'
104436:	.ASCII	'NAME$', 'FILES$', 047, '$', 'DEV$'
104457:	.ASCII	'EDIT$', 'MEM$', 'BSAVE$', 'BLOAD$'
104504:	.ASCII	'TRON$', 'TROFF$', 'CONT$', 'PATCH$'
104532:	.ASCII	'RESUME$', 'ON$', 'RENUM$', 'NEW$'
104556:	.ASCII	'SYSTEM$', 'CALL$', 'TIME$', 'DATE$'
104604:	.ASCII	'OPEN$', 'PUT$', 'GET$', 'CLOSE$'
104626:	.ASCII	'PAINT$', 'USR$', '@$'
104644:	.BYTE	000
104645:	.EVEN

; addresses of corresponding procedures
104646:	.WORD	102440, 107562, 110666, 110016
104656:	.WORD	105252, 105576, 105604, 110016
104666:	.WORD	105674, 103052, 110122, 105510
104676:	.WORD	105522, 107632, 111020, 111334
104706:	.WORD	110376, 155310, 105062, 105074
104716:	.WORD	106036, 154522, 111556, 155664
104726:	.WORD	154444, 126000, 123466, 123630
104736:	.WORD	123642, 123056, 123150, 122700
104746:	.WORD	155212, 156126, 110016, 157374
104756:	.WORD	130232, 141724, 170730, 171174
104766:	.WORD	151044, 151060, 105172, 145212
104776:	.WORD	105306, 105432, 146036, 103264
105006:	.WORD	103260, 144442, 143034, 143362
105016:	.WORD	166420, 170062, 170052, 167512
105026:	.WORD	147450, 142244, 142506

105034:	0E 67 4F 54 4F 57 0F 00				  .gOTOW..
105044:	00 0D 0A 00 FF FF FF FF FF FF FF 0A

; command STOP
105062:	MOV	007360,007420
105070:	MOV	R1,007422
; command END
105074:	TST	007416
105100:	BEQ	105112
105102:	TST	007432
105106:	BNE	105112
105110:	TRAP	077		; error 31 - wrong note in the PLAY operator
105112:	TRAP	002		; print CR, LF
105114:	MOV	#105234,R0	; string 'ost v stroke' (stop in a line)
105120:	TRAP	066		; print a string pointed to by r0
105122:	TRAP	004		; display the line number 0EF0
105124:	TRAP	002		; print CR, LF
105126:	CLR	007360
105132:	JMP	103332
105136:	MOV	R1,-(SP)
105140:	TRAP	126		; get a variable name to r4
105142:	BVS	105166		; branch if name not found
105144:	CMPB	R2,#050		; '('
105150:	BEQ	105160
105152:	CMPB	R2,#075
105156:	BNE	105166
105160:	CLC
105162:	MOV	(SP)+,R1
105164:	RETURN
105166:	SEC
105170:	BR	105162

; command CONT
105172:	MOV	007420,007360
105200:	BNE	105206
105202:	JMP	103332
105206:	MOV	007360,R0
105212:	MOV	007422,R1
105216:	MOV	#001,007364
105224:	CLR	007420
105230:	JMP	103144

105220:	01 00 60 84  37 0A 78 84  77 00 C8 FB  4F 43 54 20  ..`.7.x.w.H{OCT 
105240:	42 20 43 54  50 4F 4B 45  20 00 4E 89  37 0A 40 84  B CTPOKE .N.7.@.

; command RUN
105252:	TRAP	116
105254:	CLR	007360
105260:	MOV	007362,R1
105264:	INC	R1
105266:	MOV	#013507,006370
105274:	MOV	#001,007364
105302:	JMP	103166

; command RESUME
105306:	TST	007416
105312:	BNE	105316
105314:	TRAP	101		; error 32 - wrong PLOT function
105316:	TRAP	072		; get a character other than space to r2
105320:	INC	007432
105324:	DEC	R1
105326:	TRAP	070		; is r2 a digit?
105330:	BEQ	105366		; branch if r2 is a decimal digit
105332:	TRAP	140		; get a pair of characters to r4
105334:	CMP	R4,#047105	; "NE"
105340:	BNE	105430
105342:	TRAP	140		; get a pair of characters to r4
105344:	CMP	R4,#054124	; "XT"
105350:	BNE	105430
105352:	MOV	007412,R0
105356:	TRAP	074
105360:	BNE	105426
105362:	TRAP	102		; move the pointer r1 to the end of the line
105364:	BR	105404
105366:	TRAP	010		; ATOI
105370:	TST	R0
105372:	BNE	105400
105374:	MOV	007412,R0
105400:	TRAP	074
105402:	BNE	105426
105404:	NEG	007416
105410:	TST	006542
105414:	BEQ	105422
105416:	CALL	125226
105422:	JMP	103230
105426:	TRAP	075		; error 30 - wrong parameters
105430:	TRAP	103		; error 33 - illegal use of the RENUM operator

; command ON
105432:	INC	007200
105436:	TRAP	140		; get a pair of characters to r4
105440:	CMP	R4,#042522	; "ER"
105444:	BNE	105506
105446:	TRAP	140		; get a pair of characters to r4
105450:	CMP	R4,#051117	; "RO"
105454:	BNE	105506
105456:	TRAP	072		; get a character other than space to r2
105460:	CMP	R2,#122		; 'R'
105464:	BNE	105506
105466:	TRAP	140		; get a pair of characters to r4
105470:	CMP	R4,#043517	; "GO"
105474:	BNE	105506
105476:	TRAP	140		; get a pair of characters to r4
105500:	CMP	R4,#052117	; "TO"
105504:	BEQ	105522
105506:	TRAP	003		; error 1 - unknown operator

; command GOSUB
105510:	MOV	007360,R0
105514:	BIS	#020000,R0
105520:	TRAP	112
; command GOTO
105522:	TRAP	072		; get a character other than space to r2
105524:	DEC	R1
105526:	TRAP	136		; evaluate an arithmetical expression
105530:	TRAP	040		; FIX
105532:	TST	007200
105536:	BEQ	105556
105540:	CLR	007200
105544:	MOV	R0,007416
105550:	TRAP	102		; move the pointer r1 to the end of the line
105552:	JMP	103230
105556:	TRAP	074
105560:	BNE	105574
105562:	MOV	#001,007364
105570:	JMP	103230
105574:	TRAP	005		; error 2 - illegal GOTO or GOSUB operator

; command RESTORE
105576:	CLR	007370
105602:	BR	106026

; command RETURN
105604:	CLR	-(SP)
105606:	MOV	#020000,R4
105612:	TRAP	134		; r3 = pointer to the variable table
105614:	BEQ	105672
105616:	MOV	#017777,R0
105622:	TRAP	114
105624:	BEQ	105634
105626:	MOV	R3,(SP)
105630:	TST	(R3)+
105632:	BR	105622
105634:	MOV	(SP)+,R3
105636:	BEQ	105672
105640:	MOV	(R3),R0
105642:	BIC	R4,R0
105644:	INC	R0
105646:	MOV	#002,R4
105652:	TRAP	120
105654:	CMP	R0,#001
105660:	BNE	105666
105662:	JMP	105126
105666:	TRAP	074
105670:	BR	105562
105672:	TRAP	011		; error 4 - RETURN without GOSUB

; command DIM
105674:	TRAP	144		; search for a variable
105676:	BVS	105756		; error if invalid variable name
105700:	BNE	106034		; error if the variable already exists
105702:	MOV	R4,-(SP)	; encoded variable name
105704:	TRAP	072		; get a character other than space to r2
105706:	CMP	R2,#050
105712:	BNE	105756
105714:	TRAP	010		; ATOI
105716:	TRAP	124
105720:	BNE	105756
105722:	MOV	R0,-(SP)
105724:	SWAB	(SP)
105726:	TRAP	072		; get a character other than space to r2
105730:	CMPB	R2,#054
105734:	BNE	105750
105736:	TRAP	010		; ATOI
105740:	TRAP	124
105742:	BNE	105756
105744:	BIS	R0,(SP)
105746:	TRAP	072		; get a character other than space to r2
105750:	CMP	R2,#051
105754:	BEQ	105760
105756:	TRAP	033		; error 13 - wrong size in the DIM operator
105760:	MOV	(SP)+,R2
105762:	MOV	(SP)+,R0
105764:	MOV	R1,-(SP)
105766:	TRAP	112
105770:	MOV	R2,R0
105772:	TRAP	112
105774:	MOV	R2,R1
105776:	SWAB	R1
106000:	TRAP	122
106002:	BVS	106032
106004:	TRAP	104		; check the available stack space
106006:	BLO	106032
106010:	ADD	R0,R5
106012:	MOV	(SP)+,R1
106014:	TRAP	072		; get a character other than space to r2
106016:	CMP	R2,#054
106022:	BEQ	105674
106024:	DEC	R1
106026:	JMP	103144
106032:	TRAP	035		; error 14 - not enough memory for the array
106034:	TRAP	043		; error 17 - array of this name already defined

; command DEF
106036:	TRAP	140		; get a pair of characters to r4
106040:	CMP	R4,#043116	; "FN"
106044:	BNE	106134
106046:	TRAP	072		; get a character other than space to r2
106050:	TRAP	070		; is r2 a digit?
106052:	BEQ	106134		; branch if r2 is a decimal digit
106054:	BVS	106134
106056:	BIS	#060000,R2
106062:	MOV	R2,R0
106064:	TRAP	112
106066:	TRAP	072		; get a character other than space to r2
106070:	CMP	R2,#050
106074:	BNE	106134
106076:	TRAP	126		; get a variable name to r4
106100:	BVS	106134		; branch if name not found
106102:	MOV	R4,R0
106104:	TRAP	112
106106:	CMP	R2,#051
106112:	BNE	106134
106114:	TRAP	072		; get a character other than space to r2
106116:	CMP	R2,#075
106122:	BNE	106134
106124:	MOV	R1,R0
106126:	TRAP	112
106130:	TRAP	110
106132:	BR	106026
106134:	TRAP	037		; error 15 - wrong DEF syntax


; Original labels and comments copied from equivalent FOCAL-11 functions.

; trap 5E - EVAL, evaluate an arithmetical expression pointed to by r1.
; On exit r2,r3,r4 will contain the numeric value of the expression, r1 will
; contain the address where the scan failed. If the scan fails on any
; character other than a right parenthesis, r1 will point to the character
; where the failure occurred. If the scan ended on a right parenthesis, r1
; will point to the character following the prenthesis and the V bit will be
; set. If the V bit is set on any parameter other than the last or is cleared
; on the last parameter, a mismatching perenthesis error has occurred.
106136:	CLR	R0
106140:	TRAP	112
106142:	MOV	#177777,-(SP)	; push null (-1) on the stack
; EVAL02:
106146:	TRAP	104		; check the available stack space
106150:	BLO	106514
106152:	TRAP	072		; get a character other than space to r2
106154:	CMP	R2,#053		; is it a '+'?
106160:	BEQ	106202
106162:	CMP	R2,#055		; is it a '-'?
106166:	BNE	106204
106170:	MOV	R2,R0		; set operand2 = 0
106172:	CLR	R2
106174:	CLR	R3
106176:	CLR	R4
106200:	BR	106222
; EVAL03:
106202:	TRAP	072		; get a character other than space to r2
; EVAL01
106204:	CMP	R2,#050		; is it an opening parenthesis?
106210:	BNE	106230		; no
106212:	CLR	-(SP)		; push a zero on the stack
106214:	INC	177776(R5)	; increment the parentheses count
106220:	BR	106146
; EVAL05:
106222:	TRAP	142		; push operand r4,r3,r2 on the stack
106224:	MOV	R0,-(SP)	; push operator on the stack
106226:	BR	106202
; EVAL04:
106230:	DEC	R1		; move the character pointer back one
106232:	MOV	-(R5),-(SP)	; store the parentheses count
106234:	CALL	106542		; get an operand
106240:	MOV	(SP)+,(R5)+	; restore the parentheses count
; EVAL12:
;
; GTOPR - get an operator to r0. Look for +,-,*,/,^, and ).
106242:	MOV	R2,-(SP)	; save the character
106244:	TRAP	072		; get a character other than space to r2
106246:	MOV	#106525,R0	; get address of list #EVAL07+7
; GTPR01:
106252:	CMPB	-(R0),R2	; is character a legal operator?
106254:	BEQ	106274		; yes
106256:	CMP	R0,#106517	; has search failed?
106262:	BHI	106252		; no
106264:	CLR	R0		; yes, set r0=0 and backup
106266:	DEC	R1		; pointer to point of failure
; GTPR03:
106270:	MOV	(SP)+,R2	; restore the character
106272:	BR	106300
; GTPR02:
106274:	MOV	R2,R0		; put the character in r0
106276:	BR	106270
; end of the GTOPR module
;
106300:	TST	(SP)		; is the stack null?
106302:	BLE	106442		; yes
; EVAL06:
106304:	MOV	R1,-(SP)	; save the text pointer
106306:	MOV	#106525,R1	; get the table address #EVAL07+7
; EVAL08:
106312:	CMPB	-(R1),R0	; find the operator
106314:	BNE	106312		; it must be found
106316:	ASR	R1		; clear the low order bit
106320:	MOV	R1,(R5)+
106322:	MOV	#106525,R1	; get the table address #EVAL07+7
; EVAL09:
106326:	CMPB	-(R1),000002(SP)	; find the operator
106332:	BNE	106326		; it must be found
106334:	ASR	R1		; clear the low order bit
106336:	MOV	R1,(R5)+	; save it for now
106340:	MOV	(SP)+,R1	; restore the text pointer
106342:	CMP	-(R5),-(R5)	; is priority of operator1 > operator2?
106344:	BLT	106222		; no
106346:	MOV	R0,(R5)+	; yes, save operator2
106350:	MOV	#106525,R0	; get table address
; EVAL10:
106354:	CMPB	-(R0),(SP)	; find the operator
106356:	BNE	106354		; it must be found
106360:	SUB	#106520,R0	; get the displacement, #EVAL07+2
106364:	ASL	R0
106366:	ADD	#106526,R0	; get routine address
106372:	MOV	R0,(R5)+	; save it
106374:	TST	(SP)+		; discard old operator
106376:	MOV	SP,R0		; get the destination address
106400:	TRAP	142		; push the source r4,r3,r2 on the stack
106402:	MOV	R1,-(SP)	; save the text pointer
106404:	MOV	SP,R1
106406:	TST	(R1)+		; get source address
106410:	MOV	-(R5),R2	; get routine address
106412:	MOV	-(R5),-(SP)	; save operator2
106414:	CALL	@000000(R2)	; go compute value
106420:	MOV	(SP)+,R0	; restore operator2
106422:	MOV	(SP)+,R1	; restore text pointer
106424:	ADD	#006,SP		; discard source
106430:	MOV	(SP)+,R2	; place result in operand2
106432:	MOV	(SP)+,R3
106434:	MOV	(SP)+,R4
106436:	TST	(SP)		; is stack null?
106440:	BGT	106304		; no, take care of the rest of the stack
; EVAL17:
106442:	CMP	R0,#051		; is operator a closing parenthesis?
106446:	BEQ	106470		; yes
106450:	TST	R0		; no, is it a null?
106452:	BGT	106222		; no
106454:	TST	-(R5)		; yes, pop null
106456:	BNE	106466
106460:	TST	(SP)+
106462:	CLEAR	CVZN
106464:	RETURN			; return with result in r2,r3,r4
; EVAL13:
106466:	TRAP	017		; error 7 - mismatched parentheses
; EVAL14:
106470:	TST	-(R5)		; is parentheneses count zero?
106472:	BNE	106502		; no
; EVAL16:
106474:	TST	(SP)+		; pop null
106476:	SET	V		; error
106500:	RETURN
; EVAL15:
106502:	TST	(SP)
106504:	BLT	106474		; jump if stack = -1
106506:	TST	(SP)+		; pop null off stack
106510:	DEC	(R5)+		; decrease the parenteneses count by one
106512:	BR	106242

106514:	TRAP	001		; error 0 - out of memory

; EVAL07:
106516:	.BYTE	000, 051			; closing parenthesis
106520:	.BYTE	053, 055, 052, 057, 136		; arithmetical operators +-*/^
106525:	.EVEN
; EVAL11:
106526:	.WORD	113720, 114144, 114500, 114252, 115320	; corresponding procedures

; GETOP - get an operand.
; Upon entry r1 points to the start of an operand.
; Upon exit r2,r3,r4 contain the value of the operand.
106542:	MOV	R1,-(SP)	; save the text pointer
106544:	TRAP	072		; get a character other than space to r2
106546:	TRAP	070		; is r2 a digit?
106550:	BVS	106610		; the character is a terminator
106552:	BNE	106620		; branch if r2 is not a decimal digit
; GTP18:
; the character is a numeric
106554:	MOV	(SP)+,R1	; restore the text pointer
106556:	SUB	#006,SP		; reserve space for the number
106562:	MOV	SP,R0		; move address for the number to r0
106564:	TRAP	006		; ATOF
106566:	BVS	106540
106570:	MOV	(SP)+,R2	; place the number in r2,r3,r4
106572:	MOV	(SP)+,R3
106574:	MOV	(SP)+,R4
106576:	RETURN
;
106600:	MOV	(R0)+,R2
106602:	MOV	(R0)+,R3
106604:	MOV	(R0)+,R4
106606:	RETURN
;
; GTP15:
; the character is a terminator
106610:	CMP	R2,#056		; does the number begin with a decimal point?
106614:	BEQ	106554		; yes
106616:	BR	107142		; no
;
106620:	CMP	R2,#106		; 'F'
106624:	BEQ	107144
106626:	MOV	#177700,-(SP)
106632:	BIC	(SP),R2
106634:	MOV	R2,R0
106636:	TRAP	130		; multiply r0 by 6
106640:	TRAP	130		; multiply r0 by 6
106642:	TRAP	072		; get a character other than space to r2
106644:	TRAP	070		; is r2 a digit?
106646:	BVS	107140
106650:	BEQ	107140
106652:	BIC	(SP),R2
106654:	ADD	R2,R0
106656:	TRAP	130		; multiply r0 by 6
106660:	TRAP	130		; multiply r0 by 6
106662:	CMP	R0,#051104	; encoded keyword "PI"
106666:	BNE	106710
; function PI
106670:	MOV	#117056,R0	; PI/2
106674:	MOV	(R0)+,R2
106676:	MOV	(R0)+,R3
106700:	MOV	(R0)+,R4
106702:	INC	R4		; r2-r4 <- PI
106704:	TST	(SP)+
106706:	BR	106474
106710:	TRAP	072		; get a character other than space to r2
106712:	TRAP	070		; is r2 a digit?
106714:	BVS	107140
106716:	BEQ	107140
106720:	BIC	(SP)+,R2
106722:	ADD	R2,R0
106724:	CMP	R0,#027613	; encoded keyword "INC"
106730:	BNE	106734
106732:	BR	107070		; function INC
106734:	CMP	R0,#015752	; encoded keyword "ERR"
106740:	BNE	106750
; function ERR
106742:	MOV	007414,R3
106746:	BR	106756
106750:	CMP	R0,#015744	; encoded keyword "ERL"
106754:	BNE	106766
; function ERL
106756:	CLR	R2
106760:	MOV	#100017,R4
106764:	BR	106474

106766:	MOV	#107426,R3
106772:	CMP	(R3)+,R0
106774:	BEQ	107006
106776:	CMP	R3,#107454
107002:	BLO	106772
107004:	BR	107372
107006:	TRAP	072		; get a character other than space to r2
107010:	CMP	R2,#050
107014:	BNE	107372
107016:	MOV	000024(R3),-(SP)
107022:	TRAP	136		; evaluate an arithmetical expression
107024:	BVC	107236
107026:	MOV	(SP)+,R0
107030:	TRAP	142		; push r4,r3,r2 on the stack
107032:	MOV	R0,R2
107034:	MOV	SP,R0
107036:	MOV	R1,-(SP)
107040:	MOV	R0,R1
107042:	SUB	#006,SP
107046:	MOV	SP,R0
107050:	CALL	(R2)
107052:	MOV	(SP)+,R2
107054:	MOV	(SP)+,R3
107056:	MOV	(SP)+,R4
107060:	MOV	(SP)+,R1
107062:	ADD	#010,SP
107066:	RETURN

; function INC
107070:	CMPB	#337,006606	; key FK ?
107076:	BNE	107104
107100:	CLR	006606
107104:	MOV	R1,-(SP)
107106:	CALL	137520		; get the ASCII code of the pressed key in r2
107112:	SUB	#006,SP
107116:	MOV	SP,R0
107120:	MOV	R2,R1
107122:	TRAP	036		; FLT, convert integer R1 to float
107124:	MOV	(SP)+,R2
107126:	MOV	(SP)+,R3
107130:	MOV	(SP)+,R4
107132:	MOV	(SP)+,R1
107134:	JMP	106474

107140:	TST	(SP)+
107142:	BR	107372
107144:	TRAP	072		; get a character other than space to r2
107146:	CMP	R2,#116		; 'N'
107152:	BNE	107372
107154:	TRAP	072		; get a character other than space to r2
107156:	TRAP	070		; is r2 a digit?
107160:	BVS	107372
107162:	BEQ	107372
107164:	TRAP	134		; r3 = pointer to the variable table
107166:	BEQ	107406
107170:	CLR	R0
107172:	BIS	#060000,R2
107176:	MOV	R2,R4
107200:	TRAP	114
107202:	BEQ	107372
107204:	TST	(R3)+
107206:	MOV	(R3)+,R4
107210:	MOV	(R3)+,-(SP)
107212:	TRAP	134		; r3 = pointer to the variable table
107214:	TRAP	114
107216:	BNE	107276
107220:	TRAP	072		; get a character other than space to r2
107222:	CMP	R2,#050
107226:	BNE	107140
107230:	MOV	R4,-(SP)
107232:	TRAP	136		; evaluate an arithmetical expression
107234:	BVS	107240
107236:	TRAP	017		; error 7 - mismatched parentheses
107240:	MOV	(SP)+,R0
107242:	MOV	R5,-(SP)
107244:	TRAP	112
107246:	CLR	R0
107250:	TRAP	112
107252:	TRAP	150
107254:	MOV	R1,-(SP)
107256:	MOV	000004(SP),R1
107262:	TRAP	136		; evaluate an arithmetical expression
107264:	BVS	107236
107266:	MOV	(SP)+,R1
107270:	MOV	(SP)+,R5
107272:	CMP	(SP)+,(SP)+
107274:	RETURN
107276:	CMP	(R3)+,(R3)+
107300:	MOV	(SP)+,R0
107302:	MOV	(R3)+,-(SP)
107304:	MOV	(R3)+,-(SP)
107306:	MOV	(R3)+,-(SP)
107310:	MOV	R3,-(SP)
107312:	MOV	R0,-(SP)
107314:	TRAP	072		; get a character other than space to r2
107316:	CMP	R2,#050
107322:	BNE	107420
107324:	TRAP	136		; evaluate an arithmetical expression
107326:	BVC	107236
107330:	MOV	R1,R0
107332:	MOV	000002(SP),R1
107336:	MOV	R4,-(R1)
107340:	MOV	R3,-(R1)
107342:	MOV	R2,-(R1)
107344:	MOV	(SP)+,R1
107346:	MOV	R0,-(SP)
107350:	TRAP	136		; evaluate an arithmetical expression
107352:	BVS	107236
107354:	MOV	(SP)+,R1
107356:	MOV	(SP)+,R0
107360:	MOV	(SP)+,-(R0)
107362:	MOV	(SP)+,-(R0)
107364:	MOV	(SP)+,-(R0)
107366:	TST	(SP)+
107370:	RETURN
107372:	MOV	(SP)+,R1
107374:	TRAP	144
107376:	BVS	107406
107400:	BEQ	107406
107402:	JMP	106600
107406:	TRAP	367		; error 123 - variable doesn't exist
107410:	CLR	R2
107412:	CLR	R3
107414:	CLR	R4
107416:	RETURN
107420:	ADD	#012,SP
107424:	BR	107372

; keywords stored in a format similar to Radix-50, but with a subset of 36
; characters instead of 40
107426:	.WORD	060602, 010537, 003756, 016300	; SIN, COS, ATN, EXP
107436:	.WORD	037343, 002553, 061246, 027634	; LOG, ABS, SQR, INT
107446:	.WORD	056434, 060472, 000000		; RND, SGN

; addresses of corresponding procedures
107454:	.WORD	116624, 116766, 117072, 116064
107464:	.WORD	115570, 114172, 117454, 115074
107474:	.WORD	111512, 114224, 000000

; trap 144 - search for a variable of a name pointed to by r1
; returned values:
; r0 - pointer to the value
; r1 - pointer to the parsed string
; r2 - first unprocessed character other than space
; r4 - encoded variable name: letter in bits 11-6, digit in bits 5-0
; V flag set if invalid variable name
; Z flag set if the variable doesn't exist
107502:	TRAP	126		; get a variable name to r4
107504:	BVS	107552		; return with V set if name not found
107506:	DEC	R1
107510:	CLR	R0
107512:	TRAP	134		; r3 = pointer to the variable table
107514:	BEQ	107550
107516:	TRAP	114
107520:	BEQ	107550
107522:	CMP	(SP),#105676
107526:	BEQ	107556
107530:	TST	(R3)+
107532:	CMPB	(R1),#050	; '('
107536:	BNE	107554
107540:	INC	R1
107542:	MOV	R4,-(SP)
107544:	TRAP	132
107546:	MOV	(SP)+,R4
107550:	TST	R0
107552:	RETURN
107554:	TST	(R3)+
107556:	MOV	R3,R0
107560:	RETURN

; command LET
107562:	TRAP	144		; search for a variable
107564:	BVS	107626		; invalid variable name
107566:	BNE	107574		; skip if variable already exists
107570:	MOV	R4,R0		; encoded variable name
107572:	TRAP	146		; create the variable
107574:	MOV	R0,-(SP)
107576:	TRAP	072		; get a character other than space to r2
107600:	CMP	R2,#075		; '='
107604:	BNE	107626
107606:	TRAP	136		; evaluate an arithmetical expression
107610:	BVS	107630
107612:	MOV	(SP)+,R0
107614:	MOV	R2,(R0)+
107616:	MOV	R3,(R0)+
107620:	MOV	R4,(R0)+
107622:	JMP	103144
107626:	TRAP	021		; error 8 - illegal LET operator
107630:	TRAP	017		; error 7 - mismatched quotation marks

; command IF
107632:	TRAP	136		; evaluate an arithmetical expression
107634:	BVS	107630
107636:	TRAP	142		; push r4,r3,r2 on the stack
107640:	TRAP	140		; get a pair of characters to r4
107642:	CMP	R2,#076
107646:	BEQ	107662
107650:	CMP	R2,#075
107654:	BEQ	107662
107656:	DEC	R1
107660:	CLRB	R4
107662:	MOV	#107742,R2
107666:	CMP	R4,(R2)+
107670:	BEQ	107702
107672:	CMP	R2,#107756
107676:	BLO	107666
107700:	TRAP	023		; error 9 - illegal relation operator
107702:	SUB	#107744,R2
107706:	ASL	R2
107710:	ADD	#107756,R2
107714:	MOV	R2,-(SP)
107716:	TRAP	136		; evaluate an arithmetical expression
107720:	BVS	107630
107722:	MOV	R1,-(SP)
107724:	MOV	SP,R1
107726:	CMP	(R1)+,(R1)+
107730:	TRAP	142		; push r4,r3,r2 on the stack
107732:	MOV	SP,R0
107734:	TRAP	034		; CMPF
107736:	JMP	@000010(SP)

107742:	3E 3C 3D 3C  00 3C 3D 3E  00 3E 00 3D	><=<.<=>.>.=

107756:	BNE	110026
107760:	BR	110004
107762:	BLE	110026
107764:	BR	110004
107766:	BLT	110026
107770:	BR	110004
107772:	BGE	110026
107774:	BR	110004
107776:	BGT	110026
110000:	BR	110004
110002:	BEQ	110026
110004:	ADD	#006,SP
110010:	MOV	(SP)+,R1
110012:	ADD	#010,SP
;
; commands REM, DATA
110016:	TRAP	102		; move the pointer r1 to the end of the line
110020:	DEC	R1
110022:	JMP	103144
110026:	ADD	#006,SP
110032:	MOV	(SP)+,R1
110034:	ADD	#010,SP
110040:	TRAP	140		; get a pair of characters to r4
110042:	CMP	R4,#052110	; "TH"
110046:	BNE	110102
110050:	TRAP	140		; get a pair of characters to r4
110052:	CMP	R4,#042516	; "EN"
110056:	BNE	110120
110060:	TRAP	072		; get a character other than space to r2
110062:	DEC	R1
110064:	TRAP	070		; is r2 a digit?
110066:	BVS	110076
110070:	BNE	110120
110072:	JMP	105522
110076:	JMP	103546
110102:	CMP	R4,#043517	; "GO"
110106:	BNE	110120
110110:	TRAP	140		; get a pair of characters to r4
110112:	CMP	R4,#052117	; "TO"
110116:	BEQ	110072
110120:	TRAP	025		; error 10 - illegal IF operator

; command PRINT
110122:	CLR	-(SP)
110124:	MOV	#034,R0
110130:	TRAP	104		; check the available stack space
110132:	BLO	110374
110134:	TRAP	072		; get a character other than space to r2
110136:	CMPB	R2,#074
110142:	BNE	110152
110144:	CALL	124410
110150:	BR	110134
110152:	CMPB	R2,#054
110156:	BEQ	110250
110160:	CMPB	R2,#073
110164:	BEQ	110312
110166:	CMPB	R2,#042
110172:	BEQ	110322
110174:	CMPB	R2,#072
110200:	BEQ	110350
110202:	CMPB	R2,#012
110206:	BEQ	110350
110210:	TST	(SP)
110212:	BLT	110320
110214:	DEC	R1
110216:	TRAP	136		; evaluate an arithmetical expression
110220:	BVS	110320
110222:	MOV	R1,-(SP)
110224:	CALL	112420		; floating point to ASCII conversion
110230:	MOV	SP,R0		; pointer to the output string
110232:	TRAP	066		; print a string pointed to by r0
110234:	ADD	#024,SP
110240:	MOV	(SP)+,R1
110242:	MOV	#177777,(SP)
110246:	BR	110124
110250:	MOV	007372,R0
110254:	CMP	R0,#070
110260:	BLT	110266
110262:	TRAP	002		; print CR, LF
110264:	BR	110312
110266:	NEG	R0
110270:	BGT	110300
110272:	ADD	#016,R0
110276:	BR	110270
110300:	MOVB	#040,R2
110304:	TRAP	000		; print character r2
110306:	DEC	R0
110310:	BGT	110304
110312:	MOV	#001,(SP)
110316:	BR	110124
110320:	TRAP	027		; error 11 - illegal PRINT operator
110322:	MOVB	(R1)+,R2
110324:	TRAP	000		; print character r2
110326:	CMPB	(R1),#012
110332:	BEQ	110320
110334:	CMPB	(R1),#042
110340:	BNE	110322
110342:	INC	R1
110344:	CLR	(SP)
110346:	BR	110124
110350:	TST	(SP)+
110352:	BGT	110356
110354:	TRAP	002		; print CR, LF
110356:	CALL	125226
110362:	DEC	R1
110364:	CLR	007440
110370:	JMP	103144
110374:	TRAP	001		; error 0 - out of memory

; command INPUT
110376:	CLR	-(SP)
110400:	CALL	110604
110404:	BVC	110410
110406:	TRAP	045		; error 12 - input line too long (more than 80
				;characters)
110410:	CLR	-(SP)
110412:	MOV	R1,-(SP)
110414:	MOV	#077,R2
110420:	TRAP	000		; print character r2
110422:	TRAP	100		; input a line from the keyboard
110424:	CALL	110502
110430:	BVS	110476
110432:	BGT	110466
110434:	BLT	110472
110436:	MOV	(SP)+,R1
110440:	TST	(SP)+
110442:	TST	(SP)+
110444:	BNE	110442
110446:	DEC	R1
110450:	TST	007364
110454:	BNE	110462
110456:	MOVB	#012,(R1)
110462:	JMP	103144
110466:	TRAP	365		; error 122 - too much data entered
110470:	BR	110414
110472:	TRAP	363		; error 121 - not enough data entered
110474:	BR	110414
110476:	TRAP	361		; error 120 - illegal characters entered
110500:	BR	110414
110502:	MOV	SP,R4
110504:	CMP	(R4)+,(R4)+
110506:	TST	(R4)+
110510:	TST	(R4)+
110512:	BNE	110510
110514:	TST	-(R4)
110516:	MOV	-(R4),R0
110520:	BEQ	110574
110522:	MOV	R4,-(SP)
110524:	TRAP	006		; ATOF
110526:	BVS	110600
110530:	MOV	(SP)+,R4
110532:	CMPB	(R1),#054
110536:	BEQ	110560
110540:	CMPB	(R1),#072
110544:	BEQ	110564
110546:	CMPB	(R1),#012
110552:	BEQ	110564
110554:	SET	V
110556:	RETURN
110560:	INC	R1
110562:	BR	110516
110564:	MOV	-(R4),R0
110566:	BEQ	110556
110570:	SET	N
110572:	RETURN
110574:	CLEAR	CVZN
110576:	RETURN
110600:	TST	(SP)+
110602:	BR	110554
110604:	TRAP	144
110606:	BVS	110660
110610:	BNE	110616
110612:	MOV	R4,R0
110614:	TRAP	146
110616:	MOV	(SP)+,R2
110620:	MOV	R0,-(SP)
110622:	MOV	#004,R0
110626:	TRAP	104		; check the available stack space
110630:	BLO	110664
110632:	MOV	R2,-(SP)
110634:	TRAP	072		; get a character other than space to r2
110636:	CMPB	R2,#054
110642:	BEQ	110604
110644:	CMPB	R2,#072
110650:	BEQ	110662
110652:	CMPB	R2,#012
110656:	BEQ	110662
110660:	SET	V
110662:	RETURN
110664:	TRAP	001		; error 0 - out of memory

; command READ
110666:	MOV	#001,-(SP)
110672:	CLR	-(SP)
110674:	CALL	110604
110700:	BVC	110704
110702:	TRAP	047		; error 19 - wrong variable in the READ operator
110704:	CLR	-(SP)
110706:	MOV	R1,-(SP)
110710:	MOV	007370,R1
110714:	BNE	110724
110716:	MOV	007362,R1
110722:	BR	111000
110724:	CMPB	(R1),#012
110730:	BEQ	111000
110732:	CALL	110502
110736:	BVS	111016
110740:	BLT	110770
110742:	MOV	R1,007370
110746:	MOV	(SP)+,R1
110750:	TST	(SP)+
110752:	TST	(SP)+
110754:	BNE	110752
110756:	TST	(SP)+
110760:	BEQ	110756
110762:	DEC	R1
110764:	JMP	103144
110770:	TST	(R4)+
110772:	CLR	(R4)+
110774:	TST	(R4)
110776:	BNE	110772
111000:	TRAP	134		; r3 = pointer to the variable table
111002:	CMPB	#207,(R1)+
111006:	BEQ	110724
111010:	CMP	R1,R3
111012:	BLO	111002
111014:	TRAP	051		; error 20 - not enough DATA to READ
111016:	TRAP	053		; error 21 - wrong DATA format

; command FOR
111020:	TRAP	126		; get a variable name to r4
; missing test whether a variable name was found ???
111022:	CMP	R2,#075		; '='
111026:	BNE	111264
111030:	CLR	R0
111032:	MOV	R4,-(SP)
111034:	TRAP	134		; r3 = pointer to the variable table
111036:	TRAP	114
111040:	BNE	111050
111042:	MOV	R4,R0
111044:	TRAP	146
111046:	BR	111054
111050:	MOV	R3,R0
111052:	CMP	(R0)+,(R0)+
111054:	MOV	R0,-(SP)
111056:	CLR	R0
111060:	TRAP	134		; r3 = pointer to the variable table
111062:	BIS	#040000,R4
111066:	TRAP	114
111070:	BEQ	111110
111072:	MOV	R4,-(SP)
111074:	MOV	R1,-(SP)
111076:	MOV	#020,R4
111102:	TRAP	120
111104:	MOV	(SP)+,R1
111106:	MOV	(SP)+,R4
111110:	MOV	R4,R0
111112:	TRAP	112
111114:	MOV	R1,R0
111116:	TRAP	112
111120:	TRAP	136		; evaluate an arithmetical expression
111122:	MOV	(SP),R0
111124:	MOV	R2,(R0)+
111126:	MOV	R3,(R0)+
111130:	MOV	R4,(R0)+
111132:	TRAP	140		; get a pair of characters to r4
111134:	CMP	R4,#052117	; "TO"
111140:	BNE	111264
111142:	TRAP	136		; evaluate an arithmetical expression
111144:	TRAP	150
111146:	CMPB	(R1),#123
111152:	BNE	111202
111154:	TRAP	140		; get a pair of characters to r4
111156:	CMP	R4,#051524	; "ST"
111162:	BNE	111264
111164:	TRAP	140		; get a pair of characters to r4
111166:	CMP	R4,#042520	; "EP"
111172:	BNE	111264
111174:	TRAP	136		; evaluate an arithmetical expression
111176:	TRAP	150
111200:	BR	111216
111202:	CLR	R2
111204:	MOV	#040000,R3
111210:	MOV	#100001,R4
111214:	BR	111176
111216:	MOV	(SP),R0
111220:	MOV	R1,-(SP)
111222:	MOV	R5,R1
111224:	SUB	#014,R1
111230:	MOV	R1,-(SP)
111232:	TRAP	034		; CMPF
111234:	BEQ	111252
111236:	BLT	111266
111240:	MOV	(SP)+,R1
111242:	TST	000010(R1)
111246:	BLT	111276
111250:	BR	111254
111252:	TST	(SP)+
111254:	MOV	(SP)+,R1
111256:	CMP	(SP)+,(SP)+
111260:	JMP	103144
111264:	TRAP	055		; error 22 - illegal FOR operator
111266:	MOV	(SP)+,R1
111270:	TST	000010(R1)
111274:	BLT	111254
111276:	MOV	(SP)+,R1
111300:	TST	(SP)+
111302:	TRAP	134		; r3 = pointer to the variable table
111304:	CMPB	(R1)+,#217
111310:	BEQ	111320
111312:	CMP	R1,R3
111314:	BLO	111304
111316:	TRAP	057		; error 23 - FOR without NEXT
111320:	TRAP	126		; get a variable name to r4
111322:	CMP	R4,(SP)
111324:	BNE	111304
111326:	TST	(SP)+
111330:	DEC	R1
111332:	BR	111260

; command NEXT
111334:	CLR	R0
111336:	TRAP	126		; get a variable name to r4
111340:	MOV	R4,-(SP)
111342:	TRAP	134		; r3 = pointer to the variable table
111344:	TRAP	114
111346:	BEQ	111464
111350:	MOV	R3,-(SP)
111352:	BIS	#040000,R4
111356:	TRAP	134		; r3 = pointer to the variable table
111360:	TRAP	114
111362:	BEQ	111464
111364:	MOV	R1,-(SP)
111366:	CMP	(R3)+,(R3)+
111370:	MOV	R3,R1
111372:	ADD	#006,R1
111376:	MOV	000002(SP),R0
111402:	MOV	R3,-(SP)
111404:	CMP	(R0)+,(R0)+
111406:	MOV	R0,-(SP)
111410:	TRAP	020		; ADDF
111412:	MOV	(SP)+,R0
111414:	MOV	(SP),R3
111416:	MOV	R3,R1
111420:	TST	000010(R3)
111424:	BPL	111434
111426:	TRAP	034		; CMPF
111430:	BGT	111466
111432:	BR	111440
111434:	TRAP	034		; CMPF
111436:	BLT	111466
111440:	MOV	(SP),R0
111442:	MOV	-(R0),R1
111444:	TRAP	110
111446:	MOV	R1,R4
111450:	MOV	(SP)+,R1
111452:	TST	(SP)+
111454:	MOV	(SP),R0
111456:	MOV	R4,-(SP)
111460:	CMP	(R0)+,(R0)+
111462:	BR	111230
111464:	TRAP	061		; error 24 - NEXT without FOR
111466:	MOV	(SP)+,R1
111470:	ADD	#006,R1
111474:	MOV	000002(SP),R0
111500:	CMP	(R0)+,(R0)+
111502:	TRAP	022		; SUBF
111504:	MOV	(SP)+,R1
111506:	CMP	(SP)+,(SP)+
111510:	BR	111330

; function RND
111512:	MOV	R0,-(SP)
111514:	MOV	006370,R0
111520:	MOV	006372,R1
111524:	TRAP	016		; IMUL
111526:	BIC	#100000,R0
111532:	MOV	R0,006370
111536:	MOV	R0,R1
111540:	MOV	(SP),R0
111542:	TRAP	036		; FLT, convert integer R1 to float
111544:	MOV	(SP)+,R0
111546:	SUB	#017,000004(R0)
111554:	RETURN

; command RANDOMIZE
111556:	MOV	006376,006370
111564:	BIS	#001,006370
111572:	JMP	103144


; The binary <-> ASCII number conversion routines are apparently based on the
; floating point library of the RT-11 operating system. The original labels
; and comments are preserved.

; trap 006 - ATOF (documented), conversion of an ASCII string to a FP number
; on entry r1 points to the string
; on exit r1 points to the first invalid character,
; result (3 words) stored at memory location pointed to by r0
;
; bit 0 - switch S
; bit 1 - switch V, set if an overflow occurred
; bit 2 - switch E, set if character 'E' encountered
; bit 3 - switch D, set if a decimal point encountered
; bit 4 - switch A
; bit 5 - switch B
; bit 6 - set if negative number
; bit 7 - set if negative exponent
; bit 8 - switch M
111576:	MOV	R5,-(SP)
111600:	MOV	R0,-(SP)
111602:	CLR	(R0)+
111604:	CLR	(R0)+
111606:	CLR	(R0)
111610:	CLR	-(SP)
111612:	CLR	-(SP)
111614:	CLR	-(SP)		; clear the switches
; M.AFXN:
111616:	TRAP	072		; get a character other than space to r2
111620:	CMPB	#105,R2		; 'E'
111624:	BEQ	112016
111626:	CMPB	#055,R2		; '-'
111632:	BEQ	112060
111634:	CMPB	#053,R2		; '+'
111640:	BEQ	112052
111642:	CMPB	#056,R2		; decimal point
111646:	BEQ	112036
111650:	TRAP	070		; is r2 a digit?
111652:	BNE	112126		; branch if r2 is not a decimal digit
111654:	SUB	#060,R2		; convert the digit to binary
111660:	MOV	R1,-(SP)
111662:	BIT	#000004,000002(SP)	; test the E switch
111670:	BNE	111760		; branch if collecting exponent
111672:	SUB	#006,SP
111676:	MOV	SP,R0
111700:	MOV	R2,R1
111702:	TRAP	036		; FLT, convert integer R1 to float
111704:	MOV	000016(SP),R0
111710:	MOV	#112362,R1	; floating point constant 10
111714:	TRAP	030		; MULF, multiply by 10
111716:	BVS	112174
111720:	MOV	000016(SP),R0
111724:	MOV	SP,R1
111726:	TRAP	020		; ADDF, add current digit
111730:	BIT	#000010,000010(SP)	; test the D switch
111736:	BEQ	111744		; if 0, don't touch EXP2
111740:	DEC	000012(SP)	; decrement EXP2
111744:	ADD	#006,SP
; M.AFSS:
111750:	MOV	(SP)+,R1	; get digit SEFA
111752:	BIS	#000001,(SP)	; set the S switch
111756:	BR	112130		; go get another digit
; M.AFXP
111760:	MOV	R2,-(SP)
111762:	MOV	000010(SP),R3
111766:	MOV	#012,R5
111772:	CLR	R2
111774:	CLR	R4
111776:	CMP	R3,#001724	; check for large exponent
112002:	BGT	112204
112004:	TRAP	062		; unsigned 32-bit integer multiplication
112006:	ADD	(SP)+,R3
112010:	MOV	R3,000006(SP)	; save EXP1 back on stack
112014:	BR	111750		; set the S switch
; M.AFE:
112016:	BIT	#000004,(SP)	; first E?
112022:	BNE	112166		; no error
112024:	BIS	#000004,(SP)	; set the E switch
112030:	BIC	#000001,(SP)	; have a fraction?
112034:	BR	112130		; get next character
; M.AFD:
112036:	BIT	#000014,(SP)	; test the E and D switches
112042:	BNE	112166		; either one is an error
112044:	BIS	#000010,(SP)	; set the D switch
112050:	BR	112130		; get next character
; M.AFPL:
112052:	BIC	#000400,(SP)	; clear the M switch
112056:	BR	112062
; M.AFMI:
112060:	BIS	#000400,(SP)	; set the M switch
112064:	BIT	#000004,(SP)	; test the E switch
112070:	BNE	112132		; branch if sign of exponent
112072:	BIT	#000001,(SP)	; test the S switch
112076:	BNE	112126
112100:	BIT	#000030,(SP)	; test the A and D switches
112104:	BNE	112166		; error if any set
112106:	BIS	#000020,(SP)	; set the A switch
112112:	BIT	#000400,(SP)	; test the M switch
112116:	BEQ	112130		; exit if plus
112120:	BIS	#000100,(SP)	; set minus sign
112124:	BR	112130		; PDP-11 branches don't reach more than 128...
112126:	BR	112210
; M.AFXN:
112130:	BR	111616
; M.AFSE:
112132:	BIT	#000001,(SP)	; test the S switch
112136:	BNE	112126
112140:	BIT	(SP),#000040	; test the B switch
112144:	BNE	112166
112146:	BIS	#000040,(SP)	; set the B switch
112152:	BIT	#000400,(SP)	; test the M switch
112156:	BEQ	112130		; exit if plus
112160:	BIS	#000200,(SP)	; negative exponent
112164:	BR	112130
; M.AFVS:
112166:	BIS	#000002,(SP)	; set the V switch
112172:	BR	112126
112174:	ADD	#010,SP
112200:	MOV	(SP)+,R1
112202:	BR	112166
; M.AFVU:
112204:	CMP	(SP)+,(SP)+
112206:	BR	112166
; M.AFX6:
112210:	MOV	R1,-(SP)
112212:	BIT	#000100,000002(SP)
112220:	BEQ	112232		; number not negative
112222:	MOV	000010(SP),R0
112226:	MOV	R0,R1
112230:	TRAP	024		; NEGF
; M.AFX2:
112232:	BIT	#000200,000002(SP)	; negative exponent?
112240:	BEQ	112260		; branch if not
112242:	NEG	000006(SP)
112246:	BVC	112260		; branch if exponent valid
112250:	BIS	#000002,000002(SP)	; invalid exponent, set the V switch
112256:	BR	112334
; M.AFX3:
112260:	ADD	000004(SP),000006(SP)
112266:	BEQ	112334		; branch if EXP1+EXP2=0
112270:	BLT	112314		; if less than 0 divide
112272:	MOV	000010(SP),R0
112276:	MOV	#112362,R1	; floating point constant 10
112302:	TRAP	030		; MULF
112304:	DEC	000006(SP)	; decrement and test
112310:	BGT	112272		; loop
112312:	BR	112334
; M.AFDV:
112314:	MOV	000010(SP),R0
112320:	MOV	#112362,R1	; floating point constant 10
112324:	TRAP	026		; DIVF
112326:	INC	000006(SP)	; increment and test
112332:	BLT	112314		; loop
; M.AFX5:
112334:	MOV	(SP)+,R1	; restore the character pointer
112336:	DEC	R1
112340:	MOV	(SP)+,R4	; save switches
112342:	ADD	#006,SP
112346:	MOV	(SP)+,R5
112350:	BIT	#000002,R4	; test the V switch
112354:	BEQ	112360		; normal return
; error return
112356:	SET	V
112360:	RETURN

112362:	.WORD	000000, 050000, 100004	; 10
112370:	.WORD	000000, 040000, 100001	;1
112376:	.WORD	000000, 075022, 100024	; 1000000
112404:	.WORD	040000, 046113, 100030	; 10000000
112412:	.WORD	000000, 040000, 100000	; 0.5

; FTOA - floating point to ASCII conversion
; expects the floating point number in r2,r3,r4
; r2 - lower word of the mantissa, r3 - upper word of the mantissa
; r4 - biased exponent EXP1
; returns the output string on the stack
; typical calling sequence:
; CALL	112420		; FTOA
; MOV	SP,R0		; pointer to the output string
; TRAP	066		; print a string pointed to by R0
; ADD	#024,SP		; reclaim the stack space
112420:	MOV	#012,R0
112424:	CLR	-(SP)
112426:	DEC	R0
112430:	BGT	112424
112432:	TRAP	142		; push r4,r3,r2 on the stack
112434:	MOV	#030040,000010(SP)
112442:	MOVB	#040,000012(SP)
112450:	TST	R3		; upper word of the mantissa
112452:	BEQ	112770		; skip if the number is equal 0
112454:	BGT	112472		; skip if the number is positive
; negative number
112456:	MOV	SP,R0
112460:	MOV	R0,R1
112462:	TRAP	024		; NEGF
112464:	MOVB	#055,000010(SP)	; '-'
;
; multiply or divide the number by 10 as many times as is needed to bring it
; in the range 1e6 <= x < 1e7
; compensate the multiplication or division by changing the exponent EXP2 with
; base 10 (decimal)
112472:	MOV	#112376,R1	; floating point constant 1000000
112476:	MOV	SP,R0
112500:	TRAP	034		; CMPF
112502:	BGT	112534
;
112504:	MOV	#112404,R0	; floating point constant 10000000
112510:	MOV	SP,R1
112512:	TRAP	034		; CMPF
112514:	BLT	112552		; branch if in range
112516:	MOV	#112362,R1	; floating point constant 10
112522:	MOV	SP,R0
112524:	TRAP	026		; DIVF
112526:	INC	000006(SP)	; increment exponent EXP2
112532:	BR	112504		; repeat range check
;
112534:	MOV	#112362,R1	; floating point constant 10
112540:	MOV	SP,R0
112542:	TRAP	030		; MULF
112544:	DEC	000006(SP)	; decrement exponent EXP2
112550:	BR	112472		; repeat range check
;
; rounding
112552:	MOV	#112412,R1	; floating point constant 0.5
112556:	MOV	SP,R0
112560:	TRAP	020		; ADDF
;
; convert the number to unsigned 32-bit integer (get rid of the exponent EXP1)
112562:	SUB	#100037,000004(SP)
112570:	ASR	000002(SP)	; upper word of the mantissa
112574:	ROR	(SP)		; lower word of the mantissa
112576:	INC	000004(SP)	; exponent EXP1 with base 2 (decimal)
112602:	BNE	112570
;
112604:	MOV	SP,R0
112606:	ADD	#016,R0
112612:	MOV	SP,R1
112614:	MOV	R0,-(SP)
112616:	TRAP	014		; JTOA, 32-bit integer to ASCII conversion
112620:	MOV	(SP)+,R0
112622:	ADD	#003,R0		; skip first three spaces
112626:	CMPB	#040,(R0)	; space?
112632:	BEQ	112642		; branch if yes
112634:	INC	000006(SP)	; exponent EXP2, move the decimal point
112640:	BR	112644
; M.XA7:
112642:	INC	R0		; fourth position
112644:	ADD	#007,000006(SP)
112652:	MOV	#010,R1
112656:	MOV	R0,R2
112660:	ADD	#007,R2
112664:	DEC	R1
112666:	CMPB	#060,-(R2)
112672:	BEQ	112664
112674:	MOV	SP,R4
112676:	ADD	#011,R4
112702:	CMP	#010,000006(SP)	; exponent EXP2
112710:	BLE	113032		; scientific notation if exponent too large
112712:	CMP	#-8,000006(SP)
112720:	BGE	113032		; scientific notation if exponent too small
;
; standard decimal notation
112722:	MOV	R1,R3
112724:	NEG	R3
112726:	ADD	000006(SP),R3
112732:	ADD	#007,R3
112736:	BLT	113032
112740:	MOV	000006(SP),R3
112744:	BLT	113000
112746:	BGT	113016
112750:	MOVB	#056,(R4)+	; decimal point
112754:	MOVB	(R0)+,(R4)+	; shift one digit left
112756:	CMP	R0,R2
112760:	BLOS	112754		; loop
112762:	MOVB	#040,(R4)+
112766:	CLRB	(R4)
112770:	ADD	#010,SP
112774:	MOV	000022(SP),PC
;
113000:	MOVB	#056,(R4)+	; decimal point
113004:	MOVB	#060,(R4)+	; insert zeroes
113010:	INC	R3
113012:	BLT	113004		; loop
113014:	BR	112754
;
113016:	MOVB	(R0)+,(R4)+
113020:	DEC	R3
113022:	BGT	113016
113024:	CMP	R0,R2
113026:	BLOS	112750
113030:	BR	112762
;
; normalized scientific notation
113032:	MOVB	#056,(R4)+	; decimal point
113036:	MOVB	(R0)+,(R4)+	; shift one digit left
113040:	CMP	R0,R2
113042:	BLOS	113036		; loop
113044:	MOVB	#105,(R4)+	; 'E'
113050:	ADD	#006,SP
113054:	MOV	(SP),R1
113056:	MOV	SP,R0
113060:	ADD	#014,R0
113064:	MOV	R0,-(SP)
113066:	MOV	R4,-(SP)
113070:	TRAP	012		; ITOA
113072:	MOV	(SP)+,R4
113074:	MOV	(SP)+,R0
113076:	CMPB	(R0)+,#040
113102:	BEQ	113076
113104:	CMPB	-(R0),#055	; '-'
113110:	BEQ	113116
113112:	MOVB	#040,(R4)+
113116:	MOVB	(R0)+,(R4)+
113120:	CMPB	(R0),#040
113124:	BNE	113116
113126:	MOVB	#040,(R4)+
113132:	CLRB	(R4)
113134:	TST	(SP)+
113136:	MOV	000022(SP),PC

; trap 010 - ATOI (documented), conversion of an ASCII string to an unsigned
; integer
; on entry r1 points to the string
; on exit r1 points to the first invalid character,
; result (1 word) stored in r0
113142:	CLR	R0
113144:	CALL	101274		; get a character other than space
113150:	CALL	100600		; test if r2 is a digit
113154:	BNE	113204		; branch if not
113156:	SUB	#060,R2		; create binary number from ASCII
113162:	ASL	R0		; multiply by 10 (decimal)
113164:	ADD	R0,R2
113166:	ASL	R0
113170:	ASL	R0
113172:	ADD	R2,R0
113174:	BIT	#160000,R0
113200:	BEQ	113144
113202:	TRAP	041		; error 16 - wrong line number or dimension
113204:	DEC	R1
113206:	RETURN

; trap 012 - ITOA (documented), conversion of an 16-bit integer to ASCII string
; on entry r1 contains the number and r0 points to the memory location where
; the result should be stored
113210:	MOV	R0,-(SP)	; save DEFA
113212:	CLR	-(SP)		; clear high order of integer
113214:	MOV	R1,-(SP)	; get integer
113216:	BGE	113224		; skip if positive
113220:	COM	000002(SP)	; propagate sign through high order
113224:	MOV	SP,R1		; set SEFA
113226:	SUB	#014,SP		; expand stack
113232:	MOV	SP,R0
113234:	TRAP	014		; JTOA, 32-bit integer to ASCII conversion
113236:	MOV	SP,R1
113240:	MOV	000020(SP),R0	; users DEFA
113244:	ADD	#005,R1		; first five are spaces
113250:	MOV	#007,R2		; seven digits
113254:	MOVB	(R1)+,(R0)+
113256:	DEC	R2		; move ASCII string
113260:	BGT	113254		; loop
113262:	ADD	#022,SP		; remove junk
113266:	RETURN

; trap 014 - JTOA, conversion of an 32-bit integer to ASCII string
; on entry r1 points the number and r0 points to the memory location where
; the result should be stored
113270:	MOV	R5,-(SP)
113272:	MOV	R0,-(SP)
113274:	CLR	-(SP)		; sign control word
113276:	MOV	(R1)+,R3	; low order
113300:	MOV	(R1),R2		; high order
113302:	BGE	113314		; skip if positive
; negative
113304:	NEG	R2
113306:	NEG	R3		; complement but...
113310:	SBC	R2
113312:	INC	(SP)		; ...remember sign
113314:	MOV	#012,R5		; lower word of the dividend = 10 decimal
113320:	CLR	R4		; upper word of the dividend = 0
113322:	MOV	#-1,-(SP)	; flag
; M.JA01:
113326:	CLR	R0
113330:	CLR	R1
113332:	TRAP	064		; unsigned 32-bit integer division
113334:	MOV	R1,-(SP)	; push remainder
113336:	BIS	R2,R0		; test the quotient r2,r3 for 0
113340:	BIS	R3,R0
113342:	TST	R0		; superfluous?
113344:	BNE	113326		; loop
113346:	MOV	SP,R5		; count the number of digits
113350:	INC	R4
113352:	TST	(R5)+		; check for flag
113354:	BGE	113350		; loop
113356:	DEC	R4
113360:	MOV	#013,R3
113364:	SUB	R4,R3		; r3 <- number of leading spaces + sign
113366:	DEC	R3
113370:	MOV	000002(R5),R0
; M.JA02:
113374:	TST	R3		; count exhausted?
113376:	BLE	113410		; branch if yes
113400:	MOVB	#040,(R0)+	; insert leading spaces
113404:	DEC	R3
113406:	BR	113374		; loop
; M.JA03:
113410:	TST	(R5)		; test for sign
113412:	BEQ	113422
113414:	MOVB	#055,(R0)+	; '-'
113420:	BR	113426
; M.JA04:
113422:	MOVB	#040,(R0)+	; space
; M.JA05:
113426:	ADD	#060,(SP)	; convert digits to ASCII
113432:	MOVB	(SP)+,(R0)+
113434:	TST	(SP)		; check flag
113436:	BGE	113426		; loop
113440:	MOVB	#040,(R0)	; trailing space
113444:	ADD	#006,SP
113450:	MOV	(SP)+,R5
113452:	RETURN

; End of code borrowed from the RT-11 operating system.


; trap 016 - IMUL (documented), unsigned 16-bit integer multiplication
; r0 - multiplicand, r1 - multiplier, r0,r1 - product (the upper word in r0)
113454:	MOV	R5,-(SP)
113456:	MOV	R0,R3
113460:	MOV	R1,R5
113462:	CLR	R2
113464:	CLR	R4
113466:	TRAP	062		; unsigned 32-bit integer multiplication
113470:	MOV	R3,R0
113472:	MOV	R2,R1
113474:	MOV	(SP)+,R5
113476:	RETURN

; trap 062 - unsigned 32-bit integer multiplication
; r2,r3 - multiplier (the upper word in r2)
; r4,r5 - multiplicand (the upper word in r4)
; r0,r1,r2,r3 - product (the upper word in r0)
113500:	CLR	R0		; initial product = 0
113502:	CLR	R1
113504:	MOV	#041,-(SP)	; bit counter
; multiplication loop
113510:	ROR	R0		; shift the product and multiplier one bit down
113512:	ROR	R1
113514:	ROR	R2
113516:	ROR	R3
113520:	BHIS	113530		; if least significant bit of multiplier is 1
113522:	ADD	R5,R1		; ... then add the multiplicand to the product
113524:	ADC	R0
113526:	ADD	R4,R0
113530:	DEC	(SP)		; bit counter
113532:	BNE	113510		; loop
113534:	TST	(SP)+
113536:	RETURN

; trap 064 - unsigned 32-bit integer division
; r0,r2,r2,r3 - dividend (the upper word in r0)
; r4,r5 - divisor (the upper word in r4)
; r2,r3 - quotient (the upper word in r2)
; r0,r1 - remainder (the upper word in r0)
113540:	MOV	#040,-(SP)	; bit counter
; negated divisor goes on the stack
113544:	MOV	R4,-(SP)
113546:	MOV	R5,-(SP)
113550:	NEG	000002(SP)
113554:	NEG	(SP)
113556:	SBC	000002(SP)
113562:	ADD	(SP),R1
113564:	ADC	R0
113566:	ADD	000002(SP),R0
113572:	BLO	113706		; overflow
113574:	CLR	-(SP)
; division loop
113576:	ROL	R3		; shift the dividend/quotient one bit up
113600:	ROL	R2
113602:	ROL	R1
113604:	ROL	R0
113606:	TST	(SP)
113610:	BEQ	113632
; subtract the divisor from the dividend
113612:	CLR	(SP)
113614:	ADD	000002(SP),R1
113620:	ADC	R0
113622:	ADC	(SP)
113624:	ADD	000004(SP),R0
113630:	BR	113642
; the dividend was less than the divisor, take back the subtraction
113632:	ADD	R5,R1		; add the divisor to the dividend
113634:	ADC	R0
113636:	ADC	(SP)
113640:	ADD	R4,R0
113642:	ADC	(SP)
113644:	TST	(SP)
113646:	BEQ	113652
113650:	INC	R3		; increment the quotient
113652:	DEC	000006(SP)	; bit counter
113656:	BGT	113576		; loop
113660:	ROR	R3
113662:	BLO	113674
113664:	ADD	R5,R1
113666:	ADC	R0
113670:	ADD	R4,R0
113672:	CLC
113674:	ROL	R3
113676:	ADD	#010,SP
113702:	CLEAR	V
113704:	RETURN
; overflow
113706:	ADD	#006,SP
113712:	TRAP	373		; error 125 - multiplication/division overflow
113714:	SET	V
113716:	RETURN

; trap 020 - ADDF (documented), floating point addition
; addends pointed to by r0 and r1, sum pointed to by r0
113720:	MOV	R5,-(SP)
113722:	MOV	R0,-(SP)	; save the pointer to the sum
; first addend
113724:	MOV	(R1)+,-(SP)	; lower word of the mantissa
113726:	MOV	(R1)+,-(SP)	; upper word of the mantissa
113730:	MOV	(R1),-(SP)	; exponent
; second addend
113732:	MOV	(R0)+,R2	; lower word of the mantissa
113734:	MOV	(R0)+,R1	; upper word of the mantissa
113736:	MOV	(R0),R0		; exponent
113740:	CMP	R0,(SP)		; compare exponents
113742:	BLOS	113770
; swap addends
113744:	MOV	SP,R4
113746:	MOV	R0,R3
113750:	MOV	(R4),R0
113752:	MOV	R3,(R4)+
113754:	MOV	R1,R3
113756:	MOV	(R4),R1
113760:	MOV	R3,(R4)+
113762:	MOV	R2,R3
113764:	MOV	(R4),R2
113766:	MOV	R3,(R4)+
; larger addend is pointed to by SP
; smaller addend: exponent in r0, mantissa in r1,r2
113770:	SUB	(SP),R0		; difference between the exponents
113772:	BEQ	114056		; no alignment required
113774:	BPL	114004		; should never happen ???
113776:	CMP	R0,#-1F
114002:	BGE	114016
; smaller addend is insignificant, the answer is the larger addend
114004:	MOV	000002(SP),R5
114010:	MOV	000004(SP),R3
114014:	BR	114106
; the mantissa of the smaller addend needs to be shifted until the exponents
; are equal
114016:	CMP	R0,#-10		; difference between exponents
114022:	BGT	114042
; we can spare on shifts
114024:	ADD	#020,R0
114030:	MOV	R1,R2		; upper word -> lower word
114032:	CLR	R1		; 0 -> upper word
114034:	TST	R2		; negative number?
114036:	BPL	114042		; skip if not
114040:	COM	R1		; FFFF -> upper word
114042:	TST	R0
114044:	BEQ	114056
; this loop shifts the mantissa of the smaller addend -r0 times
114046:	ASR	R1		; upper word of the mantissa
114050:	ROR	R2		; lower word of the mantissa
114052:	INC	R0
114054:	BNE	114046		; loop
; perform the addition of both mantissas
114056:	MOV	000002(SP),R5
114062:	MOV	000004(SP),R3
114066:	ADD	R2,R3
114070:	ADC	R5
114072:	BVS	114136
114074:	ADD	R1,R5
114076:	BVC	114106
; overflow
114100:	ROR	R5		; shift the mantissa right
114102:	ROR	R3
114104:	INC	(SP)		; increment the exponent
; save the result in the memory
114106:	MOV	000006(SP),R0	; pointer where the sum is to be stored
114112:	MOV	R0,R1		; save the pointer
114114:	MOV	R3,(R0)+	; lower word of the mantissa
114116:	MOV	R5,(R0)+	; upper word of the mantissa
114120:	MOV	(SP),(R0)+	; exponent
114122:	MOV	R1,R0		; restore the pointer
114124:	ADD	#010,SP
114130:	MOV	(SP)+,R5
114132:	JMP	114704		; normalisation
;
114136:	ADD	R1,R5
114140:	BCS	114106		; branch if negative
114142:	BR	114100

; trap 022 - SUBF (documented), floating point subtraction
; minuend pointed to by r0, subtrahend pointed to by r1,
; remainder pointed to by r0
114144:	MOV	R0,R4
114146:	SUB	#006,SP
114152:	MOV	SP,R0
114154:	TRAP	024		; NEGF
114156:	MOV	R4,R0
114160:	MOV	SP,R1
114162:	TRAP	020		; ADDF
114164:	ADD	#006,SP
114170:	RETURN

; function ABS
114172:	TRAP	032		; MOVF
114174:	TST	000002(R1)
114200:	BGE	114222

; trap 024 - NEGF (documented), floating point negation
; argument pointed to by r1, result pointed to by r0
114202:	MOV	(R1)+,R2
114204:	MOV	(R1)+,R3
114206:	NEG	R3
114210:	NEG	R2
114212:	SBC	R3
114214:	MOV	R2,(R0)+
114216:	MOV	R3,(R0)+
114220:	MOV	(R1)+,(R0)+
114222:	RETURN

; function SGN
114224:	TRAP	032		; MOVF
114226:	MOV	#112370,R1	; floating point constant 1
114232:	TST	000002(R0)
114236:	BGT	114246
114240:	BEQ	114250
114242:	TRAP	024		; NEGF
114244:	RETURN
114246:	TRAP	032		; MOVF
114250:	RETURN

; trap 026 - DIVF (documented), floating point division
; dividend pointed to by r0, divisor pointed to by r1,
; quotient pointed to by r0
114252:	MOV	R5,-(SP)
114254:	MOV	R0,-(SP)	; save the pointer to the quotient
114256:	CLR	-(SP)		; sign of the factor
; divisor
114260:	MOV	(R1)+,R5	; lower word of the mantissa
114262:	MOV	(R1)+,R4	; upper word of the mantissa
114264:	TST	R4
114266:	BEQ	114466		; branch if division by 0 attempted
114270:	BGE	114302		; skip if positive
; negative
114272:	NEG	R4
114274:	NEG	R5		; complement but...
114276:	SBC	R4
114300:	INC	(SP)		; ...remember sign
; dividend
114302:	MOV	(R0)+,R3	; lower word of the mantissa
114304:	MOV	(R0)+,R2	; upper word of the mantissa
114306:	BEQ	114656		; branch if the dividend is equal 0
114310:	BGT	114322		; skip if positive
; negative
114312:	NEG	R2
114314:	NEG	R3		; complement but...
114316:	SBC	R2
114320:	DEC	(SP)		; ...remember sign
; calculate the exponent of the quotient
114322:	MOV	(R1),R1		; exponent of the divisor
114324:	NEG	R1
114326:	ADD	(R0),R1		; subtract it from the exponent of the dividend
114330:	ROR	R1
114332:	ROL	R1
114334:	BVC	114466		; overflow
114336:	ADD	#100000,R1	; bias
114342:	MOV	R1,-(SP)
; divide the mantissas
114344:	MOV	R3,R1
114346:	MOV	R2,R0
114350:	CLR	R2
114352:	CLR	R3
114354:	ROR	R0
114356:	ROR	R1
114360:	ROR	R2
114362:	TRAP	064		; unsigned 32-bit integer division
114364:	NEG	R4
114366:	NEG	R5
114370:	SBC	R4
114372:	ASL	R1
114374:	ROL	R0
114376:	ADD	R5,R1
114400:	ADC	R0
114402:	ADD	R4,R0
114404:	BLT	114414
114406:	ADD	#001,R3
114412:	ADC	R2
114414:	CLC
114416:	ROR	R2
114420:	ROR	R3
114422:	INC	(SP)
114424:	TST	000002(SP)
114430:	BEQ	114440
114432:	NEG	R2
114434:	NEG	R3
114436:	SBC	R2
114440:	MOV	000004(SP),R0
114444:	MOV	R3,(R0)+
114446:	MOV	R2,(R0)+
114450:	MOV	(SP)+,(R0)
114452:	CMP	(SP)+,(SP)+
114454:	MOV	(SP)+,R5
114456:	CMP	-(R0),-(R0)
114460:	MOV	R0,R1
114462:	JMP	114704		; normalisation
114466:	CMP	(SP)+,(SP)+
114470:	TRAP	373		; error 125 - multiplication/division overflow
114472:	MOV	(SP)+,R5
114474:	SET	V
114476:	RETURN

; trap 030 - MULF (documented), floating point multiplication
; factors pointed to by r0 and r1, product pointed to by r0
114500:	MOV	R5,-(SP)
114502:	MOV	R0,-(SP)	; save the pointer to the product
; second factor
114504:	MOV	(R1)+,R5	; lower word of the mantissa
114506:	MOV	(R1)+,R4	; upper word of the mantissa
114510:	MOV	(R1),R1		; exponent
114512:	CLR	-(SP)		; sign of the product
114514:	TST	R4
114516:	BEQ	114656		; branch if the factor is equal 0
114520:	BPL	114532		; skip if positive
; negative
114522:	NEG	R4
114524:	NEG	R5		; complement but...
114526:	SBC	R4
114530:	DEC	(SP)		; ...remember sign
; first factor
114532:	MOV	(R0)+,R3	; lower word of the mantissa
114534:	MOV	(R0)+,R2	; upper word of the mantissa
114536:	BEQ	114656		; branch if the factor is equal 0
114540:	BPL	114552		; skip if positive
; negative
114542:	NEG	R2
114544:	NEG	R3		; complement but...
114546:	SBC	R2
114550:	INC	(SP)		; ...remember sign
; calculate the exponent of the product
114552:	ADD	(R0),R1		; sum of the exponents of the factors
114554:	ROR	R1
114556:	ROL	R1
114560:	BVC	114466		; overflow
114562:	ADD	#100000,R1	; bias
114566:	MOV	R1,-(SP)
; multiply the mantissas
114570:	TRAP	062		; unsigned 32-bit integer multiplication
; normalisation
114572:	INC	(SP)
114574:	ROL	R2
114576:	ROL	R1
114600:	ROL	R0		; shift the mantissa one bit left...
114602:	BVS	114610		; ...until first bit is not zero
114604:	DEC	(SP)		; exponent
114606:	BR	114574		; loop
; rounding
114610:	ROR	R0
114612:	ROR	R1
114614:	ADC	R1
114616:	ADC	R0
114620:	BVC	114626
114622:	INC	(SP)
114624:	BR	114610
114626:	MOV	(SP)+,R2	; exponent
; apply the sign
114630:	TST	(SP)+
114632:	BEQ	114642		; skip if positive
; complement the mantissa
114634:	NEG	R0
114636:	NEG	R1
114640:	SBC	R0
; save the result in the memory
114642:	MOV	(SP)+,R3	; pointer where the result is to be stored
114644:	MOV	R1,(R3)+	; lower word of the mantissa
114646:	MOV	R0,(R3)+	; upper word of the mantissa
114650:	MOV	R2,(R3)		; exponent
114652:	MOV	(SP)+,R5
114654:	RETURN
; result = 0
114656:	CLR	R0
114660:	CLR	R1
114662:	CLR	R2
114664:	TST	(SP)+
114666:	BR	114642

; trap 036 - FLT (documented), convert an integer number to a floating point,
; expects the argument in r1 and the pointer to memory location where the
; result should be stored in r0
114670:	CLR	(R0)+
114672:	MOV	R1,(R0)+
114674:	MOV	#100017,(R0)
114700:	CMP	-(R0),-(R0)
114702:	MOV	R0,R1
114704:	MOV	(R1)+,R4	; low word of mantissa
114706:	MOV	(R1)+,R2	; high word of mantissa
114710:	MOV	(R1)+,R3	; exponent
114712:	MOV	R3,R1
; test the floating point number for 0
114714:	TST	R2
114716:	BNE	114730
114720:	TST	R4
114722:	BNE	114730
114724:	CLR	R3
114726:	BR	114770
; floating point normalisation
114730:	INC	R3
114732:	DEC	R3		; reduce exponent by one
114734:	ASL	R4		; low word of mantissa
114736:	ROL	R2		; high word of mantissa
114740:	BVC	114732
114742:	BHIS	114764
114744:	BNE	114764
114746:	TST	R4
114750:	BNE	114762
114752:	SEC
114754:	ROR	R2
114756:	INC	R3
114760:	INC	R1
114762:	SEC
114764:	ROR	R2
114766:	ROR	R4
114770:	MOV	R4,(R0)+
114772:	MOV	R2,(R0)+
114774:	MOV	R3,(R0)+
114776:	CMP	R3,R1
115000:	BHI	115006
115002:	CLEAR	V
115004:	RETURN
115006:	SET	V
115010:	RETURN

; trap 032 - MOVF
115012:	MOV	R1,R2
115014:	MOV	R0,R4
115016:	MOV	(R2)+,(R4)+
115020:	MOV	(R2)+,(R4)+
115022:	MOV	(R2)+,(R4)+
115024:	RETURN

; trap 034 - CMPF (documented), floating point comparison
; compared numbers pointed to by r0 and r1, sets flags as CMP
115026:	MOV	R1,-(SP)
115030:	TRAP	054		; push a number pointed to by R0 on the stack
115032:	MOV	SP,R0
115034:	MOV	000006(SP),R1
115040:	TRAP	022		; SUBF
115042:	MOV	000002(SP),R1
115046:	ADD	#010,SP
115052:	NEG	R1
115054:	RETURN

; trap 054 - push the floating point number pointed to by R0 on the stack
115056:	MOV	(SP)+,R2	; return address
115060:	ADD	#006,R0
115064:	MOV	-(R0),-(SP)
115066:	MOV	-(R0),-(SP)
115070:	MOV	-(R0),-(SP)
115072:	MOV	R2,PC

; function INT
115074:	MOV	(R1)+,R3
115076:	MOV	(R1)+,R2
115100:	MOV	(R1),R4
115102:	BPL	115146
115104:	CMP	-(R1),-(R1)
115106:	CMP	R4,#100037
115112:	BHIS	115012
115114:	SUB	#100037,R4
115120:	ASR	R2
115122:	ROR	R3
115124:	INC	R4
115126:	BLT	115120
115130:	MOV	R0,R1
115132:	MOV	R3,(R0)+
115134:	MOV	R2,(R0)+
115136:	MOV	#100037,(R0)
115142:	MOV	R1,R0
115144:	BR	114704		; normalisation
115146:	TST	R2
115150:	BPL	115162
115152:	MOV	#112370,R1	; floating point constant 1
115156:	JMP	114202
115162:	CLR	(R0)+
115164:	CLR	(R0)+
115166:	CLR	(R0)
115170:	RETURN

; trap 042
115172:	MOV	(R1)+,R2
115174:	MOV	(R1)+,R3
115176:	MOV	(R1),R4

; trap 040 - FIX (documented), convert a floating point number to an integer
; r2, r3, r4 -> r0
115200:	CMP	R4,#100017
115204:	BHI	115234
115206:	BEQ	115230
115210:	CMP	R4,#100000
115214:	BLO	115236
115216:	SUB	#100017,R4
115222:	ASR	R3
115224:	INC	R4
115226:	BNE	115222
115230:	MOV	R3,R0
115232:	RETURN
115234:	TRAP	371		; error 124 - number out of FIX operator range
115236:	CLR	R0
115240:	RETURN

9AA2:	      0F 42  41 53 49 43  20 56 32 2E  30 20 28 63  ...BASIC V2.0 (c
115260:	29 20 31 39  38 37 0D 0A  00 0E 6D 49  4E 53 4B 2E  ) 1987....mINSK.
115300:	20 70 6F 20  69 4E 54 45  47 52 41 4C  0F 0D 0A 00   po iNTEGRAL....

; operator ^ (power)
115320:	MOV	(R1),R3
115322:	MOV	000002(R1),R2
115326:	MOV	000004(R1),R4
115332:	BPL	115356
115334:	SUB	#100037,R4
115340:	BPL	115354
115342:	ASR	R2
115344:	ROR	R3
115346:	BLO	115356
115350:	INC	R4
115352:	BLT	115342
115354:	BR	115362
115356:	JMP	115520
115362:	MOV	R0,-(SP)
115364:	TRAP	054		; push a number pointed to by R0 on the stack
115366:	MOV	R1,R0
115370:	TRAP	054		; push a number pointed to by R0 on the stack
115372:	MOV	#112370,R1	; floating point constant 1
115376:	MOV	000014(SP),R0
115402:	TRAP	032		; MOVF
115404:	MOV	SP,R0
115406:	MOV	R0,-(SP)
115410:	MOV	R0,-(SP)
115412:	ADD	#006,(SP)
115416:	MOV	000002(SP),R0
115422:	MOV	R0,R1
115424:	CALL	115074		; INT
115430:	TST	000006(SP)
115434:	BGT	115450
115436:	BLT	115474
115440:	ADD	#022,SP
115444:	CLEAR	V
115446:	RETURN
115450:	MOV	(SP),R1
115452:	MOV	000020(SP),R0
115456:	TRAP	030		; MULF
115460:	MOV	#112370,R1	; floating point constant 1
115464:	MOV	000002(SP),R0
115470:	TRAP	022		; SUBF
115472:	BR	115430
115474:	MOV	(SP),R1
115476:	MOV	000020(SP),R0
115502:	TRAP	026		; DIVF
115504:	MOV	#112370,R1	; floating point constant 1
115510:	MOV	000002(SP),R0
115514:	TRAP	020		; ADDF
115516:	BR	115430
115520:	MOV	R1,-(SP)
115522:	MOV	R0,-(SP)
115524:	SUB	#006,SP
115530:	MOV	R0,R1
115532:	MOV	SP,R0
115534:	CALL	115570		; LOG
115540:	MOV	000010(SP),R1
115544:	MOV	SP,R0
115546:	TRAP	030		; MULF
115550:	MOV	000006(SP),R0
115554:	MOV	SP,R1
115556:	CALL	116064		; EXP
115562:	ADD	#012,SP
115566:	RETURN


; The routines for the trigonometric, exponential and square root functions
; are apparently based on the floating point library of the RT-11 operating
; system. The original labels and comments are preserved.

; function LOG
115570:	TRAP	056
115572:	TST	000002(R0)
115576:	BGT	115610
115600:	TRAP	377		; error 127 - exponent/logarithm overflow
115602:	ADD	#004,SP
115606:	RETURN
115610:	MOV	R0,R1
115612:	TST	(R1)+
115614:	BNE	115646
115616:	CMP	(R1)+,#040000
115622:	BNE	115646
115624:	CMP	(R1)+,#100001
115630:	BNE	115646
115632:	CLR	(R0)+
115634:	CLR	(R0)+
115636:	CLR	(R0)+
115640:	ADD	#004,SP
115644:	RETURN
115646:	MOV	000004(R0),-(SP)
115652:	ADD	#100000,(SP)
115656:	MOV	#100000,000004(R0)
115664:	MOV	(SP),R1
115666:	SUB	#006,SP
115672:	MOV	SP,R0
115674:	TRAP	036		; FLT, convert integer R1 to float
115676:	MOV	000010(SP),R0
115702:	TRAP	054		; push a number pointed to by R0 on the stack
115704:	MOV	#116020,R1
115710:	TRAP	022		; SUBF
115712:	MOV	SP,R0
115714:	MOV	#116020,R1
115720:	TRAP	020		; ADDF
115722:	MOV	000016(SP),R0
115726:	MOV	SP,R1
115730:	TRAP	026		; DIVF
115732:	MOV	#116034,R4
115736:	MOV	000016(SP),R0
115742:	MOV	#004,R3
115746:	TRAP	050		; M.SETU
115750:	TRAP	052		; M.DOPO
115752:	MOV	000016(SP),R0
115756:	MOV	#116312,R1
115762:	TRAP	022		; SUBF
115764:	ADD	#006,SP
115770:	MOV	SP,R0
115772:	MOV	#116026,R1
115776:	TRAP	030		; MULF
116000:	MOV	SP,R1
116002:	MOV	000010(SP),R0
116006:	TRAP	020		; ADDF
116010:	ADD	#014,SP
116014:	CLEAR	V
116016:	RETURN

116020:	.WORD	074626, 055202, 100000	; 0.7071067794 = SQR (0.5)
116026:	.WORD	005776, 054271, 100000	; 0.6931471815 = LN (2)
116034:	.WORD	125112, 046414, 077777	; 0.3009745054
116042:	.WORD	007411, 063120, 077777	; 0.3996590993
116050:	.WORD	066333, 052525, 100000	; 0.6666694707
116056:	.WORD	177772, 077777, 100001	; 1.9999999944

; function EXP - operand pointed to by r1, result pointed to by r0
116064:	TRAP	056		; M.INI2, push the pointers on the stack
116066:	CMP	000004(R0),#100016	; check the exponent
116074:	BHI	115600		; overflow
116076:	MOV	#116304,R1
116102:	TRAP	046
116104:	MOV	000002(SP),R0
116110:	MOV	#116312,R1
116114:	TRAP	030		; MULF, Y=frac(Y*log(e) base 2)*ln(2)/2
116116:	MOV	000002(SP),R0
116122:	TRAP	054		; push a number pointed to by R0 on the stack
116124:	TRAP	054		; push a number pointed to by R0 on the stack
116126:	MOV	SP,R0
116130:	MOV	#116320,R1
116134:	TRAP	020		; ADDF
116136:	MOV	SP,R0
116140:	MOV	R0,R1
116142:	TRAP	024		; NEGF
116144:	INC	000012(SP)
116150:	MOV	000016(SP),R0
116154:	MOV	R0,R1
116156:	TRAP	030		; MULF
116160:	MOV	000016(SP),R0
116164:	MOV	#116334,R1
116170:	TRAP	020		; ADDF
116172:	MOV	#116326,R0
116176:	TRAP	054		; push a number pointed to by R0 on the stack
116200:	MOV	SP,R0
116202:	MOV	000024(SP),R1
116206:	TRAP	026		; DIVF
116210:	MOV	SP,R0
116212:	MOV	R0,R1
116214:	ADD	#006,R1
116220:	TRAP	020		; ADDF
116222:	MOV	SP,R1
116224:	MOV	R1,R0
116226:	ADD	#014,R0
116232:	TRAP	026		; DIVF
116234:	ADD	#014,SP
116240:	MOV	SP,R0
116242:	MOV	#112370,R1	; floating point constant 1
116246:	TRAP	020		; ADDF
116250:	MOV	SP,R0
116252:	MOV	R0,R1
116254:	TRAP	030		; MULF
116256:	MOV	SP,R1
116260:	MOV	000010(SP),R0
116264:	TRAP	032		; MOVF
116266:	MOV	000010(SP),R0
116272:	ADD	000006(SP),000004(R0)
116300:	JMP	116010

116304:	.WORD	016624, 056125, 100001	; 1.4426950402 = log(e) base 2 = 1 / (ln 2)
116312:	.WORD	005776, 054271, 077777	; 0.3465735908 = (ln 2)/2
116320:	.WORD	037347, 117741, 100004	; -12.015016742
116326:	.WORD	041565, 132306, 100012	; -601.804265499
116334:	.WORD	026570, 074056, 100006	; 60.090190649

; trap 052 - M.DOPO
; evaluates a polynomial according to the parameters on the stack (see M.SETU)
; 2(SP) = number of constants
; A(SP) = starting address of constants
116342:	SUB	#002,000002(SP)	; subtract 2 from the counter
116350:	MOV	000010(SP),R0
116354:	MOV	000012(SP),R1	; address of the first constant
116360:	MOV	R0,-(SP)
116362:	TRAP	030		; MULF
; M.LOOP:
116364:	ADD	#006,000014(SP)	; move to the next constant
116372:	MOV	(SP),R0
116374:	MOV	000014(SP),R1
116400:	TRAP	020		; ADDF, DEST=DEST+constant
116402:	TST	000004(SP)	; test the counter
116406:	BEQ	116426		; branch if done
116410:	MOV	(SP),R0
116412:	MOV	000010(SP),R1
116416:	TRAP	030		; MULF, DEST=DEST*X^2
116420:	DEC	000004(SP)	; decrement the counter
116424:	BR	116364
; M.HANK:
116426:	MOV	(SP),R0
116430:	MOV	000006(SP),R1
116434:	TRAP	030		; MULF
116436:	TST	(SP)+
116440:	MOV	(SP)+,R3
116442:	ADD	#026,SP
116446:	MOV	R3,-(SP)
116450:	RETURN

; trap 044 - M.INIT
116452:	MOV	(SP)+,R3	; return address
116454:	CLR	-(SP)		; clear a flag
116456:	MOV	R1,-(SP)	; push SOURCE pointer
116460:	MOV	R0,-(SP)	; push DEST pointer
116462:	TRAP	032		; MOVF, move SOURCE to DEST
116464:	MOV	R3,PC

; trap 056 - M.INI2
116466:	MOV	(SP)+,R3
116470:	BR	116456

; trap 050 - M.SETU
116472:	MOV	(SP)+,R1
116474:	TRAP	054		; push a number pointed to by R0 on the stack
116476:	MOV	R1,-(SP)
116500:	MOV	R4,-(SP)
116502:	MOV	R3,-(SP)
116504:	MOV	R0,-(SP)
116506:	MOV	R0,R1
116510:	TRAP	030		; MULF
116512:	MOV	(SP)+,R0
116514:	MOV	(SP)+,R3
116516:	MOV	(SP)+,R4
116520:	MOV	(SP)+,R1
116522:	TRAP	054		; push a number pointed to by R0 on the stack
116524:	MOV	R4,-(SP)
116526:	MOV	R0,-(SP)
116530:	MOV	#006,-(SP)
116534:	ADD	SP,(SP)
116536:	MOV	#016,-(SP)
116542:	ADD	SP,(SP)
116544:	MOV	R3,-(SP)
116546:	MOV	R1,PC

; trap 046 - M.FRAC, compute fractional part
116550:	MOV	000002(SP),R0
116554:	TRAP	030		; MULF
116556:	MOV	(SP)+,000002(SP)	; pop return address
116562:	MOV	(SP),R1
116564:	TRAP	042
116566:	MOV	R0,-(SP)
116570:	MOV	(SP),R1
116572:	SUB	#006,SP
116576:	MOV	SP,R0
116600:	TRAP	036		; FLT, convert integer R1 to float
116602:	MOV	SP,R1
116604:	MOV	000010(SP),R0
116610:	TRAP	022		; SUBF
116612:	ADD	#006,SP
116616:	MOV	000004(SP),-(SP)
116622:	RETURN

; function SIN
116624:	TRAP	044		; M.INIT
116626:	TST	000002(R0)
116632:	BGE	116646		; skip if the operand not negative
; operand negative
116634:	MOV	R0,R1
116636:	TRAP	024		; NEGF
116640:	INC	000004(SP)	; set neg_flag
116644:	BR	116656
; M.NOTN:
116646:	BNE	116656		; skip if the operand not equal 0
; M.EXIT:
116650:	ADD	#006,SP
116654:	RETURN
; M.NOTE:
116656:	MOV	#117012,R1	; 2/PI
116662:	TRAP	046
116664:	MOV	(SP)+,R2
116666:	BIC	#177774,R2	; get two low order bits
116672:	ASL	R2		; multiply by 2
116674:	ADD	#117002,R2	; address of the branch table
116700:	MOV	(R2),PC		; branch through the table

; M.Q2:
116702:	MOV	#112370,R1	; floating point constant 1
116706:	MOV	(SP),R0
116710:	TRAP	022		; SUBF
; M.Q3:
116712:	MOV	(SP),R0
116714:	MOV	R0,R1
116716:	TRAP	024		; NEGF
116720:	BR	116732
; M.Q4:
116722:	MOV	#112370,R1	; floating point constant 1
116726:	MOV	(SP),R0
116730:	TRAP	022		; SUBF
; M.EVAL:
116732:	MOV	(SP),R0
116734:	MOV	#117020,R4
116740:	MOV	#006,R3
116744:	TRAP	050		; M.SETU
116746:	TRAP	052		; M.DOPO
116750:	TST	000004(SP)	; neg_flag set?
116754:	BEQ	116650		; branch if not
; negate the result
116756:	MOV	(SP),R0
116760:	MOV	R0,R1
116762:	TRAP	024		; NEGF
116764:	BR	116650

; function COS
116766:	TRAP	044		; M.INIT
116770:	MOV	#117056,R1	; PI/2
116774:	TRAP	020		; ADDF
116776:	MOV	(SP),R0
117000:	BR	116626

117002:	.WORD	116732, 116702, 116712, 116722	; M.EVAL, M.Q2, M.Q3, M.Q4

117012:	.WORD	140671, 050574, 100000	; 0.6366197732 = 2/PI

117020:	.WORD	017676, 106516, 077756	; -0.000003418172245
117026:	.WORD	175316, 051777, 077764	; 0.00016021713395
117034:	.WORD	156214, 131513, 077771	; -0.004681620238
117042:	.WORD	167376, 050632, 077775	; 0.07969258714
117050:	.WORD	006165, 126521, 100000	; -0.6459640912

117056:	.WORD	166516, 062207, 100001	; 1.5707963239 = PI/2
117064:	.WORD	015207, 043575, 077773	; 0.017453292487

; function ATN
117072:	CLR	-(SP)
117074:	TRAP	044		; M.INIT
117076:	TST	000002(R0)	; is operand equal 0 ?
117102:	BEQ	117364		; branch if yes
117104:	BGE	117116		; skip if the operand not negative
; operand negative
117106:	INC	000006(SP)	; set neg_flag
117112:	MOV	R0,R1
117114:	TRAP	024		; NEGF
; M.P2:
117116:	MOV	#112370,R1	; floating point constant 1
117122:	MOV	(SP),R0
117124:	TRAP	034		; CMPF
117126:	BGE	117166
117130:	INC	000004(SP)	; X is > 1, set a_flag
117134:	MOV	#112370,R0	; floating point constant 1
117140:	TRAP	054		; push a number pointed to by R0 on the stack
117142:	MOV	SP,R0
117144:	MOV	000006(SP),R1
117150:	TRAP	026		; DIVF, let X = 1/X
117152:	MOV	SP,R1
117154:	MOV	000006(SP),R0
117160:	TRAP	032		; MOVF
117162:	ADD	#006,SP
; M.P:
117166:	MOV	#117374,R1	; floating point constant 2 - SQR (3)
117172:	MOV	(SP),R0
117174:	TRAP	034		; CMPF, is X < 2 - SQR (3)
117176:	BLE	117210
117200:	CLR	-(SP)
117202:	CLR	-(SP)
117204:	CLR	-(SP)
117206:	BR	117270
; let X=(X*SQR(3)-1)/(X+SQR(3))
; let C=PI/6
; M.BR4:
117210:	MOV	#117410,R0	; floating point constant PI/6
117214:	TRAP	054		; push a number pointed to by R0 on the stack
117216:	MOV	000006(SP),R0
117222:	TRAP	054		; push a number pointed to by R0 on the stack
117224:	MOV	#117402,R1
117230:	TRAP	030		; MULF
117232:	MOV	000014(SP),R0
117236:	MOV	#112370,R1	; floating point constant 1
117242:	TRAP	022		; SUBF
117244:	MOV	SP,R0
117246:	MOV	#117402,R1
117252:	TRAP	020		; ADDF
117254:	MOV	000014(SP),R0
117260:	MOV	SP,R1
117262:	TRAP	026		; DIVF
117264:	ADD	#006,SP
117270:	MOV	000006(SP),R0
117274:	MOV	#117416,R4
117300:	MOV	#005,R3
117304:	TRAP	050		; M.SETU
117306:	TRAP	052		; M.DOPO
117310:	MOV	SP,R1
117312:	MOV	000006(SP),R0
117316:	TRAP	020		; ADDF
117320:	ADD	#006,SP
117324:	TST	000004(SP)
117330:	BEQ	117350
117332:	MOV	(SP),R0
117334:	MOV	#117056,R1	; PI/2
117340:	TRAP	022		; SUBF
117342:	MOV	(SP),R0
117344:	MOV	R0,R1
117346:	TRAP	024		; NEGF
117350:	TST	000006(SP)
117354:	BEQ	117364
117356:	MOV	(SP),R0
117360:	MOV	R0,R1
117362:	TRAP	024		; NEGF
117364:	ADD	#010,SP
117370:	CLEAR	V
117372:	RETURN

117374:	.WORD	050574, 042230, 077777	; 0.2679491928 = 2 - SQR (3)
117402:	.WORD	165640, 067331, 100001	; 1.7320508063 = SQR (3)
117410:	.WORD	044336, 041405, 100000	; 0.5235987743 = PI/6
117416:	.WORD	113440, 060462, 077775	; 0.09491954930
117424:	.WORD	107717, 133556, 077776	; -0.1417346058
117432:	.WORD	155646, 063141, 077776	; 0.1999653475
117440:	.WORD	131012, 125252, 077777	; -0.3333328939
117446:	.WORD	177776, 077777, 100000	; 0.9999999991

; function SQR - radicand pointed to by r1, result pointed to by r0
; algorithm: rough estimation followed by Newton's iteration
117454:	TRAP	044		; M.INIT
117456:	TST	000002(R0)	; test the high word of mantissa
117462:	BEQ	117620		; if zero, we have the answer
117464:	BGE	117476		; negative?
117466:	INC	000004(SP)	; yes, set neg_flag
117472:	MOV	R0,R1
117474:	TRAP	024		; NEGF
117476:	CLR	000002(SP)	; clear odd_flag (exponent odd or even)
117502:	MOV	(SP),R0		; pointer to the DEST
117504:	CMP	(R0)+,(R0)+	; = add #4,r0
117506:	ADD	#100000,(R0)	; get rid of the bias of the DEST exponent
117512:	ASR	(R0)		; divide the DEST exponent by 2
117514:	ADC	000002(SP)	; let odd_flag=Carry bit
117520:	MOV	(R0),-(SP)	; save DEST exponent on the stack
117522:	MOV	#100000,(R0)	; set DEST exponent=8000
117526:	MOV	000002(SP),R0	; pointer to the DEST
117532:	TRAP	054		; push a number pointed to by R0 on the stack
; linear approximation SQR(X) = X*0.590+0.417 for X in range 0.5 to 1
117534:	MOV	#117710,R1	; constant 0.5901620695
117540:	TRAP	030		; MULF
117542:	MOV	000010(SP),R0
117546:	MOV	#117702,R1	; constant 0.4173075990
117552:	TRAP	020		; ADDF
; do three times the Newton's iteration
117554:	TRAP	060		; M.APPR
117556:	TRAP	060		; M.APPR
117560:	TRAP	060		; M.APPR
117562:	ADD	6(SP),4(R0)	; add saved exponent to the DEST exponent
117570:	ADD	#010,SP
117574:	TST	000002(SP)	; was odd_flag set?
117600:	BEQ	117610		; skip if not
117602:	MOV	#117674,R1	; constant SQR(2)
117606:	TRAP	030		; MULF, multiply DEST by SQR(2)
117610:	TST	000004(SP)	; neg_flag set?
117614:	BEQ	117620		; skip if not
117616:	TRAP	375		; error 126 - negative radicand
117620:	ADD	#006,SP
117624:	CLEAR	V
117626:	RETURN

; trap 30 - M.APPR, approximation of the form .5(Y0+X/Y0)
117630:	MOV	SP,R0
117632:	TST	(R0)+
117634:	TRAP	054		; push a number pointed to by R0 on the stack
117636:	MOV	SP,R0
117640:	MOV	000020(SP),R1
117644:	TRAP	026		; DIVF
117646:	MOV	SP,R1
117650:	MOV	000020(SP),R0
117654:	TRAP	020		; ADDF, X=X0/X+X
117656:	MOV	000020(SP),R0
117662:	DEC	000004(R0)	; decrement exponent of X
117666:	ADD	#006,SP
117672:	RETURN

117674:	.WORD	074626, 055202, 100001	; 1.4142135587 = SQR (2)
117702:	.WORD	125672, 065324, 077777	; 0.4173075990
117710:	.WORD	067102, 045612, 100000	; 0.5901620695

; End of code borrowed from the RT-11 operating system.


; start the BASIC system
117716:	MOV	#200,SP
117722:	MOV	#100,R2
117726:	CLR	-(R2)
117730:	MOV	#100000,-(R2)
117734:	TST	R2
117736:	BNE	117726
117740:	MOV	#000137,(R2)+
117744:	MOV	#117716,(R2)+	; vector of the BASIC system start
117750:	MOV	#100212,@#034	; vector TRAP
117756:	CALL	145154	; RAM initialisation
117762:	TRAP	154
117764:	TRAP	002		; print CR, LF
117766:	MOV	#037476,R1
117772:	MOV	#115242,R0	; string 'BASIC V2.0 (c) 1987'
117776:	TRAP	066		; print a string pointed to by r0
120000:	MOV	R1,SP
120002:	MOV	R1,006400
120006:	MOV	#F58,R1
120012:	MOV	R1,007362
120016:	MOV	R1,R5
120020:	MOVB	#012,(R5)+
120024:	CLR	007400
120030:	JMP	103332

; display character r2
120034:	CMPB	#040,R2
120040:	BLOS	120046		; branch if a printable character
120042:	CALL	122056
120046:	CALL	121760
120052:	CALL	120156
120056:	CMP	006506,006524
120064:	BLE	120106
120066:	CLR	006506
120072:	MOV	#120112,-(SP)
120076:	CALL	120114	; save registers on the stack
120102:	JMP	122174
120106:	CALL	121760
120112:	RETURN

; save registers on the stack
120114:	MOV	R4,-(SP)
120116:	MOV	R3,-(SP)
120120:	MOV	R2,-(SP)
120122:	MOV	R1,-(SP)
120124:	MOV	R0,-(SP)
120126:	MOV	000012(SP),-(SP)
120132:	MOV	R5,000014(SP)
120136:	RETURN

; restore registers from the stack
120140:	MOV	(SP)+,R5
120142:	MOV	(SP)+,R0
120144:	MOV	(SP)+,R1
120146:	MOV	(SP)+,R2
120150:	MOV	(SP)+,R3
120152:	MOV	(SP)+,R4
120154:	RTS	R5

120156:	CALL	120114		; save registers on the stack
120162:	BIT	#020,006534
120170:	BEQ	120212
120172:	BIT	#200,R2
120176:	BEQ	120212
120200:	BIC	#200,R2
120204:	MOV	006104,006110
120212:	CMPB	R2,#040
120216:	BGE	120224
120220:	JMP	121362
120224:	TST	006120
120230:	BNE	120246
120232:	BIT	#040,006534
120240:	BNE	120246
120242:	JMP	121362
120246:	MOVB	R2,R1
120250:	MOV	006514,006526
120256:	MOV	006074,R5	; height of a character in pixels
120262:	MOV	006506,-(SP)
120266:	MOV	006120,-(SP)
120272:	MOV	#D68,R4
120276:	MOV	R1,-(SP)
120300:	CMPB	R1,#077
120304:	BLE	120322
120306:	MOV	#100,R3
120312:	MOV	006110,006106
120320:	BR	120334
;
120322:	MOV	#040,R3
120326:	MOV	#174716,006106	; font table
120334:	SUB	R3,R1
120336:	MUL	006100,R1	; number of bits for each character
120342:	MOVB	006526,R3
120346:	MUL	006076,R3	; width of a character in pixels
120352:	ADD	R1,R3
120354:	CLR	R2
120356:	DIV	#010,R2
120362:	CLR	R1
120364:	ADD	006106,R2
120370:	BISB	(R2)+,R1
120372:	SWAB	R1
120374:	BISB	(R2),R1
120376:	ADD	006076,R3	; width of a character in pixels
120402:	SUB	#010,R3
120406:	ASH	R3,R1
120410:	SWAB	R1
120412:	MOV	#010,R3
120416:	SUB	006076,R3	; width of a character in pixels
120422:	ASH	R3,R1
120424:	TST	006532
120430:	BEQ	120510
120432:	CMP	006532,#002
120440:	BLT	120470
120442:	CLR	R0
120444:	MOV	006076,R3	; width of a character in pixels
120450:	ASLB	R1
120452:	RORB	R0
120454:	SOB	R3,120450
120456:	MOV	R0,R1
120460:	CMP	#002,006532
120466:	BEQ	120510
120470:	MOV	#D68,R4
120474:	MOV	006076,R3	; width of a character in pixels
120500:	ROLB	R1
120502:	ROLB	(R4)+
120504:	SOB	R3,120500
120506:	BR	120512
120510:	MOVB	R1,(R4)+
120512:	ADD	006116,006526
120520:	MOV	(SP)+,R1
120522:	DEC	R5
120524:	BEQ	120532
120526:	JMP	120276
120532:	BIT	#001,006532
120540:	BNE	120554
120542:	MOV	006074,R5	; height of a character in pixels
120546:	MOV	006076,R4	; width of a character in pixels
120552:	BR	120600
120554:	MOV	#010,R3
120560:	MOV	#D68,R4
120564:	ASLB	(R4)+
120566:	SOB	R3,120564
120570:	MOV	006076,R5	; width of a character in pixels
120574:	MOV	006074,R4	; height of a character in pixels
120600:	BIT	#001,006534
120606:	BEQ	120624
120610:	MOV	#004,R3
120614:	MOV	#D68,R2
120620:	COM	(R2)+
120622:	SOB	R3,120620
120624:	INC	R5
120626:	MOV	#D68,R3
120632:	MOV	R4,-(SP)
120634:	MOVB	(R3)+,R1
120636:	MOV	R3,-(SP)
120640:	MOV	006506,-(SP)
120644:	MOV	#010,-(SP)
120650:	MOV	R1,R0
120652:	CLR	R1
120654:	MOV	006132,R3
120660:	BIC	#177400,R0
120664:	ASL	R0
120666:	ASL	R1
120670:	BIS	R0,R1
120672:	CLRB	R1
120674:	DEC	(SP)
120676:	BGT	121022
120700:	MOV	#177400,006544
120706:	MOV	006120,(SP)
120712:	CMP	#001,R5
120716:	BNE	120726
120720:	MOV	#001,R2
120724:	BR	120732
120726:	MOV	006130,R2
120732:	CMP	006120,006424
120740:	BLT	120766
120742:	MOV	006424,006120
120750:	DEC	006120
120754:	DEC	(SP)
120756:	CALL	122514
120762:	INC	006652
120766:	CALL	121436		; plot a dot
120772:	INC	006120
120776:	SOB	R2,120732
121000:	MOV	(SP)+,006120
121004:	TST	R4
121006:	BEQ	121106
121010:	MOV	#010,-(SP)
121014:	ADD	(SP),006506
121020:	CLR	R1
121022:	SOB	R3,120666
121024:	SOB	R4,120654
121026:	BIC	#177400,R0
121032:	ASL	R0
121034:	ASL	R1
121036:	BIS	R0,R1
121040:	CLRB	R1
121042:	TST	(SP)
121044:	BEQ	120700
121046:	DEC	(SP)
121050:	BEQ	120700
121052:	MOV	(SP),R3
121054:	NEG	R3
121056:	ADD	#010,R3
121062:	MOV	#377,R2
121066:	SEC
121070:	ROR	R2
121072:	SOB	R3,121070
121074:	CLRB	R2
121076:	MOV	R2,006544
121102:	ASH	(SP),R1
121104:	BR	120706
121106:	ADD	006130,006120
121114:	MOV	(SP)+,006506
121120:	MOV	(SP)+,R3
121122:	MOV	(SP),R4
121124:	DEC	R5
121126:	BEQ	121134
121130:	JMP	120634
121134:	TST	(SP)+
121136:	BIT	#001,006530
121144:	BEQ	121266
121146:	TST	(SP)+
121150:	SUB	006130,006120
121156:	TST	006652
121162:	BEQ	121216
121164:	CLR	006652
121170:	MOV	006124,R4
121174:	CALL	122514
121200:	SOB	R4,121174
121202:	MOV	006424,006120
121210:	SUB	006124,006120
121216:	MOV	(SP)+,006506
121222:	CMP	#001,006530
121230:	BNE	121242
121232:	ADD	006124,006120
121240:	BR	121362
121242:	SUB	006520,006120
121250:	SUB	006520,006120
121256:	ADD	006124,006120
121264:	BR	121362
121266:	MOV	(SP)+,006120
121272:	TST	006652
121276:	BEQ	121336
121300:	CLR	006652
121304:	MOV	006124,R4
121310:	DEC	R4
121312:	BEQ	121322
121314:	CALL	122514
121320:	BR	121310
121322:	MOV	006424,006120
121330:	SUB	006520,006120
121336:	TST	006530
121342:	BNE	121352
121344:	ADD	006516,(SP)
121350:	BR	121356
121352:	SUB	006516,(SP)
121356:	MOV	(SP)+,006506
121362:	MOV	#D68,R4
121366:	MOV	#004,R3
121372:	CLR	(R4)+
121374:	SOB	R3,121372
121376:	CALL	120140		; restore registers from the stack
121402:	MOV	#177400,006544
121410:	RETURN
121412:	TST	007400
121416:	BEQ	121436		; plot a dot
121420:	MOV	006706,SP
121424:	MOV	006712,R5
121430:	MOV	006716,R1
121434:	RETURN

; plot a dot
121436:	BIC	#177760,006126
121444:	CMP	#004,006126
121452:	BLT	121702
121454:	BIT	#100,006534	; screen or plotter?
121462:	BEQ	121506
; plotter
121464:	MOV	006506,007016
121472:	MOV	006120,007020
121500:	CALL	074356
121504:	BR	121702
; screen
121506:	CALL	120114		; save registers on the stack
121512:	MOV	006120,R3	; coordinate Y
121516:	CMP	R3,006424	; height of the screen in pixels
121522:	BHIS	121676		; out of the screen
121524:	MOV	006506,R5	; coordinate X
121530:	CMP	R5,006426	; width of the screen in pixels
121534:	BHIS	121676		; out of the screen
121536:	MOV	006434,R0
121542:	SUB	006506,R0
121546:	BPL	121562
121550:	SUB	#010,R0
121554:	ASH	R0,R1
121556:	NEG	R0
121560:	ASH	R0,R1
121562:	CLR	R4
121564:	CLR	R2
121566:	DIV	#040,R2
121572:	DIV	#010,R4
121576:	MUL	#017,R3
121602:	ADD	R4,R3
121604:	ASL	R3
121606:	ADD	R2,R3
121610:	MOV	R5,R0
121612:	CLR	R5
121614:	MOV	R3,R2
121616:	ADD	006402,R2	; address of the display RAM
121622:	BISB	(R2),R5
121624:	SWAB	R5
121626:	BISB	000002(R2),R5
121632:	ASHC	R0,R4
121634:	BIC	#377,R1
121640:	CLR	R2
121642:	MOVB	006126,R2
121646:	ASL	R2
121650:	CALL	@121736(R2)
121654:	NEG	R0
121656:	ASHC	R0,R4
121660:	ADD	006402,R3	; address of the display RAM
121664:	MOVB	R5,000002(R3)
121670:	SWAB	R5
121672:	MOVB	R5,(R3)
121674:	CLC
121676:	CALL	120140		; restore registers from the stack
121702:	RETURN

121704:	BIC	R1,R5
121706:	RETURN

121710:	BIC	006544,R5
121714:	BIS	R1,R5
121716:	RETURN

121720:	XOR	R1,R5
121722:	RETURN

121724:	CLR	R1
121726:	BIS	R5,R1
121730:	MOV	R1,000004(SP)
121734:	RETURN

; display modes
121736:	.WORD	121704
121740:	.WORD	121710
121742:	.WORD	121720
121744:	.WORD	121714
121746:	.WORD	121724

121750:	MOVB	(R1)+,(R4)+
121752:	CMPB	(R1)+,(R4)+
121754:	SOB	R3,121750
121756:	RETURN

121760:	TST	006540
121764:	BNE	122054
121766:	MOV	006506,-(SP)
121772:	MOV	006120,-(SP)
121776:	MOVB	006126,-(SP)
122002:	MOVB	#002,006126
122010:	ADD	006520,006120
122016:	SUB	006124,006120
122024:	MOV	R1,-(SP)
122026:	MOV	#174000,R1
122032:	CALL	121436		; plot a dot
122036:	MOV	(SP)+,R1
122040:	MOVB	(SP)+,006126
122044:	MOV	(SP)+,006120
122050:	MOV	(SP)+,006506
122054:	RETURN

122056:	CMPB	#016,R2
122062:	BNE	122112
122064:	MOV	006104,006110
122072:	BIT	#020,006534
122100:	BEQ	122132
122102:	MOV	#200,006504
122110:	BR	122132
122112:	CMPB	#017,R2
122116:	BNE	122134
122120:	MOV	006102,006110
122126:	CLR	006504
122132:	BR	122320
122134:	CALL	120114		; save registers on the stack
122140:	MOV	#122166,R0
122144:	CLR	R3
122146:	BISB	(R0)+,R3
122150:	BEQ	122314
122152:	CMPB	R2,(R0)+
122154:	BNE	122144
122156:	CALL	121760
122162:	ASL	R3
122164:	ADD	R3,PC

122166:	.BYTE	03 0A 14 0D 00 00

122174:	CMP	006522,006120
122202:	BGT	122226
122204:	MOV	006520,R2
122210:	CALL	122514
122214:	SOB	R2,122210
122216:	MOV	006522,006120
122224:	BR	122310
122226:	ADD	006520,006120
122234:	BR	122310
122236:	CLR	006506
122242:	BR	122310
122244:	SUB	006516,006506
122252:	BGE	122306
122254:	MOV	006524,006506
122262:	SUB	006520,006120
122270:	CMP	#010,006120
122276:	BLE	122306
122300:	MOV	006522,006120
122306:	RETURN
122310:	CALL	121760
122314:	CALL	120140		; restore registers from the stack
122320:	TST	(SP)+
122322:	RETURN

122324:	MOV	R0,-(SP)
122326:	MOV	R1,-(SP)
122330:	MOV	006130,R1
122334:	MUL	006112,R1
122340:	ADD	006124,R1
122344:	MOV	R1,006520
122350:	MOV	006132,R1
122354:	MUL	006114,R1
122360:	ADD	006122,R1
122364:	MOV	R1,006516
122370:	CLR	R0
122372:	MOV	006424,R1
122376:	SUB	#010,R1
122402:	DIV	006520,R0
122406:	ADD	006520,R1
122412:	NEG	R1
122414:	ADD	006424,R1
122420:	MOV	R1,006522
122424:	CLR	R0
122426:	MOV	006426,R1
122432:	DIV	006516,R0
122436:	ADD	006516,R1
122442:	NEG	R1
122444:	ADD	006426,R1
122450:	MOV	R1,006524
122454:	MOV	(SP)+,R1
122456:	MOV	(SP)+,R0
122460:	RETURN

122462:	CALL	121760
122466:	CALL	122244
122472:	MOVB	#040,R2
122476:	CALL	120156
122502:	CALL	122244
122506:	CALL	121760
122512:	RETURN
122514:	BIT	#100,006534	; screen or plotter?
122522:	BEQ	122532
; plotter
122524:	CALL	075260
122530:	RETURN
; screen
122532:	MOV	R1,-(SP)
122534:	MOV	R3,-(SP)
122536:	MOV	R4,-(SP)
122540:	MOV	006426,R1
122544:	ASR	R1
122546:	ASR	R1
122550:	ASR	R1
122552:	MOV	R1,-(SP)
122554:	MOV	006432,R3
122560:	DEC	R3
122562:	MUL	R1,R3
122564:	MOV	R3,-(SP)
122566:	TST	006536
122572:	BNE	122610
122574:	MOV	006426,R4
122600:	ASL	R4
122602:	SUB	006426,R3
122606:	BR	122612
; display scroll
122610:	CLR	R4
122612:	ADD	006402,R4	; address of the display RAM
122616:	ASL	R1
122620:	ADD	R4,R1
122622:	CALL	121750
122626:	MOV	006402,R1	; address of the display RAM
122632:	INC	R1
122634:	MOV	000002(SP),R3
122640:	CALL	121750
122644:	MOV	006402,R4	; address of the display RAM
122650:	INC	R4
122652:	MOV	(SP)+,R3
122654:	CALL	121750
122660:	MOV	(SP)+,R3
122662:	CLRB	(R4)+
122664:	INC	R4
122666:	SOB	R3,122662
122670:	MOV	(SP)+,R4
122672:	MOV	(SP)+,R3
122674:	MOV	(SP)+,R1
122676:	RETURN

; command AUTO
122700:	TRAP	106		; get a pair of integer numbers
122702:	TST	R3		; first number
122704:	BNE	122712
122706:	MOV	#012,R3		; default value 10 for the first number
122712:	MOV	R3,007212
122716:	TST	R4		; second number
122720:	BNE	122750
122722:	CMP	#054,R2		; was a comma between the numbers?
122726:	BNE	122744
122730:	TST	007214
122734:	BEQ	122744
122736:	MOV	007214,R4
122742:	BR	122750
122744:	MOV	#012,R4		; default value 10 for the second number
122750:	MOV	R4,007214
122754:	MOV	#001,006560
122762:	JMP	123634

122766:	SUB	#010,SP
122772:	MOV	SP,R0
122774:	MOV	007212,R1
123000:	TRAP	012		; ITOA
123002:	MOV	SP,R0
123004:	TST	(R0)+
123006:	CLRB	000006(SP)
123012:	MOV	#007236,R3	; input line buffer
123016:	CMPB	#040,(R0)+
123022:	BEQ	123016
123024:	DEC	R0
123026:	MOVB	(R0),R2
123030:	MOVB	(R0)+,(R3)+
123032:	BEQ	123040
123034:	TRAP	000		; print character r2
123036:	BR	123026
123040:	DEC	R3
123042:	ADD	007214,007212
123050:	ADD	#010,SP
123054:	RETURN

; command WAIT
123056:	MOV	#125712,R4	; evaluate the argument to the variable 0E86
123062:	MOV	#001,R3		; number of arguments
123066:	CALL	126326		; evaluate arguments to integer variables
123072:	ASL	R0
123074:	MOV	R0,007424	; counter decremented at each EVNT interrupt
123100:	BIS	#000020,@#165026	; RTC register B, enable SQW
123106:	MOV	#000127,@#165024	; RTC register A,
				; DV=010 (OSC1=32768Hz), RS=1011 (SQW=32Hz)
123114:	TST	007424		; counter decremented at each EVNT interrupt
123120:	BLE	123130
123122:	TST	007400
123126:	BEQ	123114
123130:	BIC	#020,@#165026	; RTC register B, disable SQW
123136:	MOV	#101,@#165024	; RTC register A,
				; DV=010 (OSC1=32768Hz), RS=0000 (SQW=none)
123144:	JMP	123634

; command PLAY
123150:	MOV	#125714,R4	; evaluate arguments to variables 0E86, 0E88
123154:	MOV	#002,R3		; number of arguments
123160:	CALL	126326		; evaluate arguments to integer variables
123164:	CMP	#050,007206
123172:	BHIS	123176
123174:	TRAP	077		; error 31 - wrong note in the PLAY operator
123176:	MOV	007206,R2
123202:	ASL	R2
123204:	CALL	123214
123210:	JMP	123634

; play a note specified in R2 of duration time specified in R0
123214:	MOV	R0,007424	; counter decremented at each EVNT interrupt
123220:	MOV	#127,@#165024	; RTC register A,
				; DV=010 (OSC1=32768Hz), RS=1011 (SQW=32Hz)
123226:	MOV	123344(R2),@#164022
123234:	MOV	#373,@#164024
123242:	CLR	@#164026	; start of the transfer
123246:	CALL	123334
123252:	BIS	#020,@#165026	; RTC register B, enable SQW
123260:	CLR	@#164020	; transmit dummy data
123264:	CALL	123334
123270:	TST	007424		; counter decremented at each EVNT interrupt
123274:	BLE	123300		; branch if specified time elapsed
123276:	BR	123260
123300:	TST	@#164026	; end of the transfer
123304:	CALL	123334
123310:	BIC	#020,@#165026	; RTC register B, disable SQW
123316:	MOV	#163,@#164024
123324:	MOV	#242,@#164024
123332:	RETURN

123334:	TSTB	@#164024
123340:	BPL	123334
123342:	RETURN

; tone frequency table, notes 0 (F4 = 349.23Hz) to 40 (A7 = 3520.0Hz)
; frequency = 800kHz / table_entry
123344:	.WORD	004363, 004162, 003771, 003606
123354:	.WORD	003432, 003264, 003124, 002771
123364:	.WORD	002643, 002522, 002406, 002275
123374:	.WORD	002171, 002071, 001774, 001703
123404:	.WORD	001615, 001532, 001452, 001374
123414:	.WORD	001322, 001251, 001203, 001137
123424:	.WORD	001075, 001035, 000776, 000742
123434:	.WORD	000707, 000655, 000625, 000576
123444:	.WORD	000551, 000525, 000501, 000457
123454:	.WORD	000436, 000416, 000377, 000361
123464:	.WORD	000343

; command DIS
123466:	CALL	123474
123472:	BR	123634

123474:	MOV	006506,-(SP)
123500:	MOV	006120,-(SP)
123504:	CALL	141066
123510:	CLR	006536
123514:	MOV	(SP)+,006120
123520:	MOV	(SP)+,006506
123524:	TST	006120
123530:	BNE	123544
123532:	CLR	006506
123536:	MOV	#010,006120
123544:	TST	006540
123550:	BEQ	123562
123552:	CLR	006540
123556:	CALL	121760
123562:	RETURN

123564:	MOV	006402,R3	; address of the display RAM
123570:	MOV	#000740,R2	; size of the display RAM (03C0 bytes)
123574:	CLR	(R3)+
123576:	SOB	R2,123574
123600:	BIS	#040,006534
123606:	CLR	006506
123612:	CLR	006120
123616:	INC	006536
123622:	INC	006540
123626:	RETURN

; command CLS
123630:	CALL	123564
123634:	TRAP	110
123636:	JMP	103144

; command LOCATE
123642:	MOV	R1,-(SP)
123644:	CALL	121760
123650:	MOV	(SP)+,R1
123652:	MOV	#002,R3		; number of arguments
123656:	MOV	#125720,R4	; evaluate arguments to variables 0D46, 0C50
123662:	CALL	126326		; evaluate arguments to integer variables
123666:	MOV	R1,-(SP)
123670:	CALL	121760
123674:	MOV	(SP)+,R1
123676:	BR	123634
123700:	CALL	120114		; save registers on the stack
123704:	MOV	#D76,R0
123710:	MOV	#001,007162
123716:	MOV	#001,007164
123724:	MOV	000006(R0),R1
123730:	SUB	000002(R0),R1
123734:	BGE	123744
123736:	NEG	007162
123742:	NEG	R1
123744:	MOV	000010(R0),R2
123750:	SUB	000004(R0),R2
123754:	BGE	123764
123756:	NEG	007164
123762:	NEG	R2
123764:	MOV	R2,-(SP)
123766:	SUB	R1,(SP)
123770:	BLE	124016
123772:	MOV	007162,R3
123776:	MOV	007164,007162
124004:	MOV	R3,007164
124010:	MOV	R2,R3
124012:	MOV	R1,R2
124014:	MOV	R3,R1
124016:	MOV	R2,R3
124020:	ASL	R3
124022:	MOV	R3,007210
124026:	SUB	R1,R3
124030:	MOV	R3,007204
124034:	MOV	R1,R3
124036:	ASL	R3
124040:	MOV	R3,007206
124044:	SUB	007210,007206
124052:	TST	(SP)
124054:	BLE	124074
124056:	MOV	000002(R0),R5
124062:	MOV	000004(R0),R4
124066:	MOV	000010(R0),R3
124072:	BR	124110
124074:	MOV	000002(R0),R4
124100:	MOV	000004(R0),R5
124104:	MOV	000006(R0),R3
124110:	BIT	#010,006534
124116:	BEQ	124140
124120:	BR	124144
124122:	BIT	#010,006534
124130:	BEQ	124140
124132:	CALL	044022
124136:	BR	124144
124140:	CALL	124216
124144:	CMP	R4,R3
124146:	BEQ	124206
124150:	ADD	007162,R4
124154:	TST	007204
124160:	BGE	124172
124162:	ADD	007210,007204
124170:	BR	124122
124172:	ADD	007164,R5
124176:	SUB	007206,007204
124204:	BR	124122
124206:	TST	(SP)+
124210:	CALL	120140		; restore registers from the stack
124214:	RETURN
124216:	TST	000002(SP)
124222:	BLE	124236
124224:	MOV	R5,006506
124230:	MOV	R4,006120
124234:	BR	124246
124236:	MOV	R4,006506
124242:	MOV	R5,006120
124246:	MOVB	006126,-(SP)
124252:	MOVB	006564,006126
124260:	MOV	R1,-(SP)
124262:	MOV	#100000,R1
124266:	CALL	121412
124272:	MOV	(SP)+,R1
124274:	MOVB	(SP)+,006126
124300:	RETURN
124302:	CALL	124312
124306:	JMP	110122
124312:	CALL	121760
124316:	BIS	#140,006534	; output to the plotter
124324:	MOV	006506,007034
124332:	MOV	006120,007036
124340:	MOV	007016,006506
124346:	MOV	007020,006120
124354:	MOV	006454,006424
124362:	MOV	006456,006426
124370:	MOV	#002,006132
124376:	CALL	122324
124402:	INC	006540
124406:	RETURN
124410:	INC	006542
124414:	TST	007440
124420:	BEQ	124426
124422:	CLR	006122
124426:	MOV	#124436,-(SP)
124432:	JMP	126024
124436:	TRAP	072		; get a character other than space to r2
124440:	CMPB	R2,#076
124444:	BEQ	124456
124446:	CMPB	R2,#073
124452:	BEQ	124426
124454:	TRAP	071		; error 28 - illegal PRINT syntax
124456:	TST	007440
124462:	BNE	124470
124464:	JMP	125160
124470:	MOV	R3,-(SP)
124472:	MOV	006440,R3
124476:	MUL	#004,R3
124502:	MOV	R3,007042
124506:	ASR	R3
124510:	MOV	R3,006450
124514:	MUL	#003,R3
124520:	MOV	R3,007044
124524:	ASL	R3
124526:	MOV	R3,006444
124532:	TST	006122
124536:	BEQ	124554
124540:	MOV	006122,006450
124546:	ADD	006124,006444
124554:	MOV	007044,R3
124560:	ADD	006450,R3
124564:	MOV	R3,-(SP)
124566:	MOV	007042,R3
124572:	ASL	R3
124574:	ADD	006450,R3
124600:	MOV	R3,-(SP)
124602:	MOV	006442,R3
124606:	SUB	006446,R3
124612:	BEQ	125150
124614:	MOV	006442,R3
124620:	ASL	R3
124622:	ADD	R3,PC
124624:	BR	125066
124626:	BR	124766
124630:	BR	124716
124632:	CMP	006446,#001
124640:	BEQ	124666
124642:	BLT	124700
124644:	MOV	007042,007044
124652:	MOV	000002(SP),007042
124660:	NEG	007042
124664:	BR	125150
124666:	MOV	(SP),007044
124672:	CLR	007042
124676:	BR	125150
124700:	MOV	007042,007044
124706:	MOV	000002(SP),007042
124714:	BR	125150
124716:	CMP	006446,#001
124724:	BEQ	124744
124726:	BLT	124754
124730:	MOV	000002(SP),007044
124736:	NEG	007044
124742:	BR	125150
124744:	MOV	000002(SP),007044
124752:	BR	125150
124754:	MOV	(SP),007042
124760:	CLR	007044
124764:	BR	125150
124766:	CMP	006446,#002
124774:	BEQ	125016
124776:	BLT	125044
125000:	CLR	007042
125004:	MOV	(SP),007044
125010:	NEG	007044
125014:	BR	125150
125016:	MOV	007042,007044
125024:	NEG	007044
125030:	MOV	000002(SP),007042
125036:	NEG	007042
125042:	BR	125150
125044:	MOV	007042,007044
125052:	NEG	007044
125056:	MOV	000002(SP),007042
125064:	BR	125150
125066:	CMP	006446,#002
125074:	BEQ	125120
125076:	BLT	125136
125100:	NEG	007042
125104:	MOV	000002(SP),007044
125112:	NEG	007044
125116:	BR	125150
125120:	MOV	(SP),007042
125124:	NEG	007042
125130:	CLR	007044
125134:	BR	125150
125136:	NEG	007042
125142:	MOV	000002(SP),007044
125150:	TST	(SP)+
125152:	TST	(SP)+
125154:	MOV	(SP)+,R3
125156:	RETURN
125160:	CALL	121760
125164:	TST	006130
125170:	BNE	125200
125172:	MOV	#001,006130
125200:	TST	006132
125204:	BNE	125214
125206:	MOV	#001,006132
125214:	CALL	122324
125220:	CALL	121760
125224:	RETURN

125226:	CLR	006542
125232:	BIC	#020,006534
125240:	TST	007440
125244:	BEQ	125300
125246:	MOV	#002,006440
125254:	MOV	#030,006444
125262:	MOV	#004,006450
125270:	CLR	006446
125274:	CLR	006442
125300:	CALL	121760
125304:	MOV	#001,006130
125312:	MOV	#001,006132
125320:	CLR	006530
125324:	CLR	006532
125330:	MOVB	#001,006126
125336:	MOV	#001,006116
125344:	CLR	006514
125350:	BIC	#001,006534
125356:	MOV	006074,006112	; height of a character in pixels
125364:	MOV	006076,006114	; width of a character in pixels
125372:	MOV	#001,006122
125400:	MOV	#001,006124
125406:	BIT	#100,006534	; screen or plotter?
125414:	BEQ	125500
; plotter
125416:	CLR	006540
125422:	MOV	006506,007016
125430:	MOV	006120,007020
125436:	MOV	007034,006506
125444:	MOV	007036,006120
125452:	MOV	#100,006424
125460:	MOV	#170,006426
125466:	BIC	#100,006534	; set output to the screen
125474:	CALL	121760
; screen
125500:	CALL	122324
125504:	CALL	121760
125510:	RETURN

125512:	MOV	#006570,R3
125516:	MOVB	#003,006564
125524:	MOV	R1,-(SP)
125526:	MOV	R3,R4
125530:	CMP	(R4)+,(R4)+
125532:	MOV	#002,R2
125536:	MOV	#002,R0
125542:	MOV	(R4),R1
125544:	MOV	(R3),(R4)
125546:	CALL	123700
125552:	MOV	R1,(R4)+
125554:	TST	(R3)+
125556:	SOB	R0,125542
125560:	MOV	R3,R4
125562:	CMP	-(R4),-(R4)
125564:	SOB	R2,125536
125566:	MOV	(SP)+,R1
125570:	RETURN

; evaluate an arithmetical expression to an integer in R0
125572:	TRAP	072		; get a character other than space to r2
125574:	DEC	R1
125576:	CMPB	R2,#072		; colon?
125602:	BEQ	125704
125604:	CMPB	R2,#012		; end of the line?
125610:	BEQ	125704
125612:	MOV	R3,-(SP)
125614:	MOV	R4,-(SP)
125616:	TRAP	136		; evaluate an arithmetical expression
125620:	TRAP	040		; FIX
125622:	MOV	(SP)+,R4
125624:	MOV	(SP)+,R3
125626:	TRAP	072		; get a character other than space to r2
125630:	CMPB	R2,#054		; comma?
125634:	BEQ	125700
125636:	CMPB	R2,#072		; colon?
125642:	BEQ	125676
125644:	CMPB	R2,#012		; end of the line?
125650:	BEQ	125676
125652:	TST	006542
125656:	BEQ	125674
125660:	CMPB	R2,#073		; semicolon?
125664:	BEQ	125676
125666:	CMPB	R2,#076		; '>'
125672:	BEQ	125676
125674:	TRAP	071		; error 28 - wrong PRINT syntax
125676:	DEC	R1
125700:	CLC
125702:	RETURN
125704:	DEC	R1
125706:	SEC
125710:	RETURN

; addresses of integer variables to which arguments of various commands are
; evaluated
125712:	.WORD	007206			; WAIT
125714:	.WORD	007206, 007210		; PLAY
125720:	.WORD	006506, 006120		; LOCATE
125724:	.WORD	006130, 006132
125730:	.WORD	006440
125732:	.WORD	006532
125734:	.WORD	006442
125736:	.WORD	006122, 006124
125742:	.WORD	006530
125744:	.WORD	006446
125746:	.WORD	006506, 006120
125752:	.WORD	007016, 007020
125756:	.WORD	007204, 007206, 007210
125764:	.WORD	007204, 007206, 007210
125772:	.WORD	006572, 006574, 006570

; command DRAW
126000:	MOV	R3,-(SP)
126002:	MOV	006506,006512
126010:	MOV	006120,006510
126016:	BIS	#200,006534
126024:	TRAP	072		; get a character other than space to r2
126026:	MOV	#126114,R0
126032:	CLR	R3		; those two instructions could be replaced...
126034:	BIS	(R0)+,R3	; ...with a single MOV (R0)+,R3
126036:	BNE	126042
126040:	TRAP	073		; error 29 - wrong DRAW function
126042:	CMP	R2,(R0)+
126044:	BNE	126032
126046:	ASL	R3
126050:	TST	006542
126054:	BNE	126112
126056:	MOV	SP,006706
126062:	MOV	R1,006716
126066:	MOV	R5,006712
126072:	BIT	#100,006534	; screen or plotter?
126100:	BNE	126112		; skip if plotter
; screen
126102:	MOV	#126216,-(SP)
126106:	MOV	SP,006706
126112:	ADD	R3,PC

; offset to the handler routine, command code
126114:	.WORD	000215, 'O'	; AC4C+2*008D = AD66
	.WORD	000517, 'H'	; AC4C+2*014F = AEEA
	.WORD	000447, 'D'	; AC4C+2*0127 = AE9A
	.WORD	000537, 'E'	; AC4C+2*015F = AF0A
	.WORD	000231, 'I'	; AC4C+2*0099 = AD7E
	.WORD	000321, 'A'	; AC4C+2*00D1 = ADEE
	.WORD	000544, 'C'	; AC4C+2*0164 = AF14
	.WORD	000564, 'X'	; AC4C+2*0174 = AF34
	.WORD	000723, 'G'	; AC4C+2*01D3 = AFF2
	.WORD	000066, 'S'	; AC4C+2*0036 = ACB8
	.WORD	000133, 'Q'	; AC4C+2*005B = AD02
	.WORD	000114, 'Z'	; AC4C+2*004C = ACE4
	.WORD	000121, 'Y'	; AC4C+2*0051 = ACEE
	.WORD	000340, 'M'	; AC4C+2*00E0 = AE0C
	.WORD	000301, 'N'	; AC4C+2*00C1 = ADCE
	.WORD	000311, 'P'	; AC4C+2*00C9 = ADDE
	.WORD	000000		; end marker

126216:	MOV	(SP)+,R3
126220:	MOV	006512,006506
126226:	MOV	006510,006120
126234:	BIC	#200,006534
126242:	TRAP	110
126244:	TST	007400
126250:	BEQ	126264
126252:	ADD	#014,006506
126260:	JMP	103276
126264:	JMP	103144

; graphic command 'S'
126270:	MOV	#125724,R4	; evaluate arguments to variables 0C58, 0C5A
126274:	MOV	#002,R3		; number of arguments
126300:	TST	007440
126304:	BEQ	126316
126306:	MOV	#125730,R4	; evalueate the argument to the variable 0D20
126312:	MOV	#001,R3		; number of arguments
126316:	TST	006542
126322:	BNE	126326
126324:	TRAP	073		; error 29 - wrong DRAW function
; evaluate arguments to integer variables
; number of arguments in R3
; addresses of integer variables pointed to by R4
126326:	CALL	125572		; evaluate arithm. expression to integer in R0
126332:	BHIS	126336
126334:	TRAP	075		; error 30 - wrong parameters
126336:	MOV	R0,@(R4)+
126340:	SOB	R3,126326
126342:	RETURN

; graphic command 'Z'
126344:	MOV	#125736,R4	; evaluate arguments to variables 0C52, 0C54
126350:	MOV	#002,R3		; number of arguments
126354:	BR	126316

; graphic command 'Y'
126356:	MOV	#125742,R4	; evaluate the argument to the variable 0D58
126362:	TST	007440
126366:	BEQ	126374
126370:	MOV	#125744,R4	; evaluate the argument to the variable 0D26
126374:	MOV	#001,R3		; number of arguments
126400:	BR	126316

; graphic command 'Q'
126402:	MOV	#125732,R4	; evaluate the argument to the variable 0D5A
126406:	MOV	#001,R3		; number of variables
126412:	CALL	126316
126416:	BIC	#177774,006532
126424:	TST	007440
126430:	BEQ	126442
126432:	MOV	006532,006442
126440:	RETURN
126442:	BIT	#001,006532
126450:	BNE	126470
126452:	MOV	006076,006114	; width of a character in pixels
126460:	MOV	006074,006112	; height of a character in pixels
126466:	BR	126504
126470:	MOV	006074,006114	; height of a character in pixels
126476:	MOV	006076,006112	; width of a character in pixels
126504:	MOV	#001,006116
126512:	CLR	006514
126516:	CMP	#002,R0
126522:	BLT	126544
126524:	BEQ	126532
126526:	TST	R0
126530:	BEQ	126544
126532:	MOV	#006,006514
126540:	NEG	006116
126544:	RETURN

; graphic command 'O' - set the current screen position
126546:	BIT	#100,006534	; screen or plotter?
126554:	BEQ	126564
; plotter
126556:	MOV	#125752,R4	; evaluate arguments to variables 0E0E, 0E10
126562:	BR	126570
; screen
126564:	MOV	#125746,R4	; evaluate arguments to variables 0D46, 0C50
126570:	MOV	#002,R3		; number of arguments
126574:	BR	126326		; evaluate arguments to integer variables

; graphic command 'I' - draw a line specified by relative coordinates
126576:	MOV	#006570,-(SP)
126602:	MOV	(SP),R3
126604:	MOV	006506,(R3)+
126610:	MOV	006120,(R3)+
126614:	MOV	#002,R4		; number of arguments
126620:	CALL	125572		; evaluate arithm. expression to integer in R0
126624:	BLO	126714
126626:	MOV	R0,(R3)+
126630:	SOB	R4,126620
126632:	MOV	(SP),R3
126634:	ADD	(R3),000004(R3)
126640:	ADD	000002(R3),000006(R3)
126646:	MOVB	#003,006564
126654:	CALL	123700
126660:	MOV	000004(R3),(R3)
126664:	MOV	000006(R3),000002(R3)
126672:	CMP	(R3)+,(R3)+
126674:	MOV	#002,R4
126700:	CALL	125572		; evaluate arithm. expression to integer in R0
126704:	BLO	126710
126706:	BR	126626
126710:	TST	(SP)+
126712:	RETURN
126714:	TRAP	075		; error 30 - wrong parameters

; graphic command 'N' - inverted print mode (white on black)
126716:	TST	006542
126722:	BNE	126726
126724:	TRAP	073		; error 29 - wrong DRAW function
126726:	BIS	#001,006534
126734:	RETURN

; graphic command 'P' - normal print mode (black on white)
126736:	TST	006542
126742:	BNE	126746
126744:	TRAP	073		; error 29 - wrong DRAW function
126746:	BIC	#001,006534
126754:	RETURN

; graphic command 'A' - draw a rectangle
126756:	MOV	R1,-(SP)
126760:	MOV	#006570,R3
126764:	MOV	#004,R4		; number of arguments
126770:	CALL	125572		; evaluate arithm. expression to integer in R0
126774:	BLO	127012
126776:	MOV	R0,(R3)+
127000:	SOB	R4,126770
127002:	CALL	125512
127006:	MOV	(SP)+,R1
127010:	RETURN
127012:	TRAP	075		; error 30 - wrong parameters

; graphic command 'M' - draw a bitmap specified with hexadecimal numbers
127014:	MOV	#002,R3
127020:	CLR	R2
127022:	CLR	R4
127024:	BIS	R2,R4
127026:	TRAP	072		; get a character other than space to r2
127030:	CMPB	R2,#012
127034:	BEQ	127044
127036:	CMPB	R2,#072
127042:	BNE	127064
127044:	CMP	#002,R3
127050:	BNE	127056
127052:	DEC	R1
127054:	BR	127230
127056:	DEC	R1
127060:	CLR	R2
127062:	BR	127122
127064:	SUB	#060,R2
127070:	BMI	127230
127072:	CMP	R2,#011
127076:	BLE	127120
127100:	SUB	#007,R2
127104:	CMP	R2,#017
127110:	BHI	127230
127112:	CMP	R2,#012
127116:	BLT	127230
127120:	SOB	R3,127024
127122:	MOV	#004,R3
127126:	ASL	R4
127130:	SOB	R3,127126
127132:	BIS	R2,R4
127134:	SWAB	R4
127136:	MOV	R1,-(SP)
127140:	MOV	R4,R1
127142:	CMP	006424,006120
127150:	BGT	127164
127152:	CLR	006120
127156:	ADD	#010,006506
127164:	MOVB	006126,-(SP)
127170:	MOVB	#002,006126
127176:	CALL	121412
127202:	MOV	(SP)+,006126
127206:	MOV	(SP)+,R1
127210:	INC	006120
127214:	CMPB	(R1),#012
127220:	BEQ	127230
127222:	CMPB	(R1),#072
127226:	BNE	127014
127230:	RETURN

; graphic command 'D' - draw a line specified by absolute coordinates
127232:	MOVB	#003,006564
127240:	MOV	#006570,R3
127244:	MOV	#002,R4
127250:	MOV	006506,(R3)+
127254:	MOV	006120,(R3)+
127260:	SOB	R4,127250
127262:	MOV	#006570,R3
127266:	MOV	#004,R4
127272:	CALL	125572		; evaluate arithm. expression to integer in R0
127276:	BHIS	127310
127300:	CMP	#002,R4
127304:	BEQ	127314
127306:	TRAP	075		; error 30 - wrong parameters
127310:	MOV	R0,(R3)+
127312:	SOB	R4,127272
127314:	CALL	123700
127320:	CALL	125572		; evaluate arithm. expression to integer in R0
127324:	BLO	127350
127326:	MOV	#006570,R3
127332:	MOV	006506,(R3)+
127336:	MOV	006120,(R3)+
127342:	MOV	#002,R4
127346:	BR	127310
127350:	RETURN

; graphic command 'H' - plot a dot
127352:	CALL	126564
127356:	MOVB	006126,-(SP)
127362:	MOV	R1,-(SP)
127364:	MOVB	#003,006126
127372:	MOV	#100000,R1
127376:	CALL	121436		; plot a dot
127402:	MOV	(SP)+,R1
127404:	MOVB	(SP)+,006126
127410:	RETURN

; graphic command 'E' - erase a dot or a line
127412:	CLRB	006564
127416:	CALL	127262
127422:	RETURN

; graphic command 'C' - draw a circle
127424:	CLR	006566
127430:	MOV	#D7E,007206
127436:	MOV	#125772,R4	; evaluate argum. to variables 0D7A, 0D7C, 0D78
127442:	MOV	#003,R3		; number of arguments
127446:	CALL	126326		; evaluate arguments to integer variables
127452:	JMP	134544

127456:	.WORD	000000, 040000, 100000

; graphic command 'X' - draw the coordinate axes
127464:	MOV	R1,-(SP)
127466:	MOV	006506,-(SP)
127472:	MOV	006120,-(SP)
127476:	MOV	#125756,R4	; evaluate argum. to variables 0E84, 0E86, 0E88
127502:	MOV	#003,R3		; number of arguments
127506:	CALL	126326		; evaluate arguments to integer variables
127512:	BIC	#177774,007204
127520:	MOV	007204,-(SP)
127524:	MOV	007206,R3
127530:	MOV	R0,R4
127532:	MOV	R0,R1
127534:	MUL	R3,R1
127536:	MOV	#006570,R2
127542:	MOV	006506,(R2)+
127546:	MOV	006120,(R2)+
127552:	MOV	006506,(R2)+
127556:	MOV	006120,(R2)
127562:	BIT	#001,(SP)
127566:	BEQ	127572
127570:	TST	-(R2)
127572:	TST	(SP)
127574:	BEQ	127604
127576:	CMP	#003,(SP)
127602:	BNE	127606
127604:	NEG	R1
127606:	ADD	R1,(R2)
127610:	MOVB	#003,006564
127616:	CALL	123700
127622:	MOV	(SP)+,R0
127624:	MOV	#100000,R1
127630:	MOV	#006570,R2
127634:	CMP	006506,(R2)+
127640:	BLE	127650
127642:	MOV	177776(R2),006506
127650:	CMP	006120,(R2)
127654:	BLE	127662
127656:	MOV	(R2),006120
127662:	INC	R4
127664:	MOVB	006126,-(SP)
127670:	MOVB	#003,006126
127676:	BIT	#001,R0
127702:	BNE	127724
127704:	INC	006506
127710:	CALL	121412
127714:	ADD	R3,006120
127720:	SOB	R4,127710
127722:	BR	127742
127724:	DEC	006120
127730:	CALL	121412
127734:	ADD	R3,006506
127740:	SOB	R4,127730
127742:	MOVB	(SP)+,006126
127746:	MOV	(SP)+,006120
127752:	MOV	(SP)+,006506
127756:	MOV	(SP)+,R1
127760:	RETURN

; graphic command 'G' - draw horizontal or vertical stripes
127762:	MOV	#125764,R4	; evaluate argum. to variables 0E84, 0E86, 0E88
127766:	MOV	#003,R3		; number of arguments
127772:	CALL	126326		; evaluate arguments to integer variables
127776:	BIC	#177774,007204
130004:	MOV	007204,-(SP)
130010:	MOV	007206,R4
130014:	MOV	#006570,R3
130020:	MOV	006506,(R3)
130024:	MOV	(R3)+,-(SP)
130026:	MOV	006120,(R3)
130032:	MOV	(R3)+,-(SP)
130034:	MOV	006506,(R3)
130040:	ADD	R4,(R3)
130042:	MOV	(R3)+,-(SP)
130044:	MOV	006120,(R3)
130050:	ADD	R0,(R3)
130052:	MOV	(R3)+,-(SP)
130054:	CALL	125512
130060:	MOV	#004,R4
130064:	MOV	#006600,R3
130070:	MOV	(SP)+,-(R3)
130072:	SOB	R4,130070
130074:	TST	(SP)
130076:	BEQ	130226
130100:	MOV	#002,R2
130104:	MOV	#006570,R3
130110:	MOV	(R3),R4
130112:	CMP	000004(R3),R4
130116:	BGE	130130
130120:	MOV	000004(R3),(R3)
130124:	MOV	R4,000004(R3)
130130:	TST	(R3)+
130132:	SOB	R2,130110
130134:	MOV	#006570,R3
130140:	CALL	125572		; evaluate arithm. expression to integer in R0
130144:	BHIS	130152
130146:	MOV	#001,R0
130152:	CMP	#001,(SP)
130156:	BNE	130176
130160:	MOV	000006(R3),R4
130164:	MOV	000002(R3),000006(R3)
130172:	TST	(R3)+
130174:	BR	130206
130176:	MOV	000004(R3),R4
130202:	MOV	(R3),000004(R3)
130206:	ADD	R0,(R3)
130210:	CMP	(R3),R4
130212:	BGE	130226
130214:	ADD	R0,000004(R3)
130220:	CALL	123700
130224:	BR	130206
130226:	TST	(SP)+
130230:	RETURN

; command EDIT
130232:	TRAP	106		; get a pair of integer numbers
130234:	MOV	R3,R0		; first number
130236:	TRAP	074
130240:	BVS	130252
130242:	CMP	R0,R2
130244:	BEQ	130256
130246:	TST	R0
130250:	BEQ	130256
130252:	JMP	103276
130256:	BIS	#020,006534
130264:	CLR	006502
130270:	CLR	006504
130274:	MOV	R1,007206
130300:	CLR	007210
130304:	MOV	R1,-(SP)
130306:	CALL	131042
130312:	MOV	#050,006120
130320:	CLR	006506
130324:	MOV	#077,R1
130330:	BIS	#001,006534
130336:	MOV	#131230,R3
130342:	MOVB	(R3)+,R2
130344:	CALL	120034		; display character r2
130350:	SOB	R1,130342
130352:	MOV	#040,R2
130356:	CALL	120156
130362:	MOV	(SP)+,R1
130364:	BIC	#001,006534
130372:	CLR	006506
130376:	MOV	#010,006120
130404:	CLR	006512
130410:	MOV	#010,006510
130416:	MOV	#007236,R3	; input line buffer
130422:	MOV	#050,R2
130426:	MOV	#020040,(R3)+
130432:	SOB	R2,130426
130434:	MOV	#007236,R3	; input line buffer
130440:	MOVB	(R1)+,R2
130442:	BPL	130506
130444:	BIC	#177600,R2
130450:	MOV	#104170,R0
130454:	MOV	R2,R4
130456:	DEC	R4
130460:	BLT	130472
130462:	CMPB	(R0)+,#044
130466:	BNE	130462
130470:	BR	130456
130472:	MOVB	(R0)+,R2
130474:	CMPB	R2,#044
130500:	BEQ	130440
130502:	MOVB	R2,(R3)+
130504:	BR	130472
130506:	CMPB	#016,R2
130512:	BNE	130524
130514:	MOVB	#200,006504
130522:	BR	130536
130524:	CMPB	#017,R2
130530:	BNE	130536
130532:	CLR	006504
130536:	MOVB	R2,(R3)
130540:	CMPB	R2,#077
130544:	BLE	130552
130546:	BISB	006504,(R3)
130552:	TSTB	(R3)+
130554:	CMPB	R2,#012
130560:	BNE	130440
130562:	MOV	R3,R4
130564:	MOVB	#040,-(R4)
130570:	CLR	007154
130574:	CALL	133374
130600:	MOV	R5,-(SP)
130602:	CALL	141400
130606:	MOV	(SP)+,R5
130610:	MOV	#007236,R0	; input line buffer
130614:	MOV	R4,R1
130616:	SUB	#007236,R1	; input line buffer
130622:	CMP	R1,007210
130626:	BGE	130634
130630:	MOV	007210,R1
130634:	CALL	131142
130640:	MOV	#007236,R3	; input line buffer
130644:	CALL	121760
130650:	TST	007046
130654:	BEQ	130676
130656:	MOV	(SP)+,006120
130662:	MOV	(SP)+,006506
130666:	MOV	(SP)+,R3
130670:	CLR	007046
130674:	BR	130712
130676:	MOV	006510,006120
130704:	MOV	006512,006506
130712:	CLR	006540
130716:	CALL	121760
130722:	CALL	131356
130726:	CALL	131000
130732:	CALL	123564
130736:	CALL	123474
130742:	CLR	007154
130746:	CALL	133374
130752:	MOV	#007236,R1	; input line buffer
130756:	TST	007400
130762:	BEQ	130770
130764:	JMP	103276
130770:	MOV	#103276,-(SP)
130774:	JMP	103434
131000:	CMP	R3,R4
131002:	BLOS	131006
131004:	MOV	R3,R4
131006:	MOVB	#012,(R4)+
131012:	CALL	121760
131016:	MOV	#007236,R1	; input line buffer
131022:	CMP	R1,R4
131024:	BGE	131034
131026:	BICB	#200,(R1)+
131032:	BR	131022
131034:	MOV	#007236,R1	; input line buffer
131040:	RETURN
131042:	MOV	006402,R2	; address of the display RAM
131046:	MOV	006424,R3
131052:	MUL	006426,R3
131056:	ASH	#177774,R3
131062:	CLR	(R2)+
131064:	SOB	R3,131062
131066:	MOV	#131326,R3
131072:	MOV	#027,R1
131076:	BIS	#041,006534
131104:	CLR	006120
131110:	CLR	006506
131114:	MOV	#001,006540
131122:	MOVB	(R3)+,R2
131124:	CALL	120034		; display character r2
131130:	SOB	R1,131122
131132:	BIC	#041,006534
131140:	RETURN
131142:	MOVB	(R0)+,R2
131144:	CMPB	R2,#016
131150:	BNE	131212
131152:	MOV	R2,-(SP)
131154:	MOV	#133776,R2
131160:	MOV	R3,-(SP)
131162:	MOV	R1,-(SP)
131164:	MOV	#010,R3
131170:	CALL	132646
131174:	MOV	(SP)+,R1
131176:	MOV	(SP)+,R3
131200:	MOV	(SP)+,R2
131202:	CALL	120034		; display character r2
131206:	SOB	R1,131142
131210:	RETURN
131212:	CMPB	R2,#017
131216:	BNE	131202
131220:	MOV	R2,-(SP)
131222:	MOV	#133766,R2
131226:	BR	131160

131220:	A6 10 C2 15  F6 B7 EC 01  20 20 20 20  20 20 20 20  &.B.v7l.        
131240:	20 20 20 20  20 20 20 20  20 20 20 20  0E 20 73 75              . su
131260:	0F 2F 48 20  2D 0E 20 50  4F 44 53 4B  41 5A 4B 41  ./H -. PODSKAZKA
131300:	09 0F 20 20  20 20 20 20  20 20 20 20  20 20 20 20  ..              
131320:	20 20 20 20  20 20 0F 20  65 64 69 74  20 20 0E 5A        . edit  .Z
131340:	41 4D 20 20  20 20 57 52  20 4C 41 54  0F FF CB B5  AM    WR LAT..K5

131352:	BIS	(R1)+,R1
131354:	45fpp
131356:	BITB	#200,(R3)
131362:	BEQ	131402
131364:	CALL	133326
131370:	MOV	R5,-(SP)
131372:	CALL	141400
131376:	MOV	(SP)+,R5
131400:	BR	131432
131402:	CMPB	#016,(R3)
131406:	BEQ	131364
131410:	CMPB	#017,(R3)
131414:	BEQ	131424
131416:	CMPB	#077,(R3)
131422:	BGE	131432
131424:	CALL	133374
131430:	BR	131370
131432:	CALL	137472		; wait for a key
131436:	BEQ	131356
131440:	TST	007400
131444:	BEQ	131452
131446:	JMP	130732
131452:	CMPB	#015,R2
131456:	BNE	131462
131460:	RETURN
131462:	MOV	#131510,R0
131466:	CLR	R1
131470:	BISB	(R0)+,R1
131472:	BEQ	131554
131474:	CMPB	R2,(R0)+
131476:	BNE	131466
131500:	CALL	121760
131504:	ASL	R1
131506:	ADD	R1,PC

131510:	MOV	016056(R4),@#015124
131516:	MOV	-(R5),(R1)+
131520:	MOV	@(R1)+,@(SP)+
131522:	MOV	(R1),@011507(R3)
131526:	MOV	(R0)+,@000656(R5)
131532:	BLT	131316
131534:	MOV	-(R2),132771
131540:	BGT	131170
131542:	JSR	R2,@007342(R0)
131546:	ILLOP
131550:	SOB	PC,131510
131552:	45fpp
131554:	CMPB	R2,#040
131560:	BLO	131356
131562:	BIT	#001,006502
131570:	BEQ	131600
131572:	CALL	133110
131576:	BR	131356
131600:	CALL	133712
131604:	BR	131356
131606:	ADD	#024,R3
131612:	CMP	R3,#EEE
131616:	BLO	131634
131620:	SUB	#024,R3
131624:	CALL	121760
131630:	JMP	131356
131634:	ADD	006520,006120
131642:	BR	131624
131644:	SUB	#024,R3
131650:	CMP	R3,#007236
131654:	BHIS	131672
131656:	ADD	#024,R3
131662:	CALL	121760
131666:	JMP	131356
131672:	SUB	006520,006120
131700:	BR	131662
131702:	CALL	131000
131706:	SUB	#007236,R4
131712:	MOV	R4,007210
131716:	MOV	#133012,-(SP)
131722:	JMP	103434
131726:	CALL	131000
131732:	SUB	#007236,R4
131736:	MOV	R4,007210
131742:	MOV	#132742,-(SP)
131746:	JMP	103434
131752:	CALL	133650
131756:	BR	131774
131760:	CMP	#007236,R3
131764:	BEQ	131774
131766:	DEC	R3
131770:	CALL	122244
131774:	CALL	121760
132000:	JMP	131356
132004:	CMPB	#016,(R3)
132010:	BNE	132020
132012:	CALL	133440
132016:	BR	132032
132020:	CMPB	#017,(R3)
132024:	BNE	132032
132026:	CALL	133520
132032:	CMP	R3,R4
132034:	BHIS	131774
132036:	MOV	R3,-(SP)
132040:	SUB	R3,R4
132042:	MOV	R4,R1
132044:	DEC	R4
132046:	BEQ	132060
132050:	INC	R3
132052:	MOVB	(R3),-(R3)
132054:	INC	R3
132056:	SOB	R4,132050
132060:	MOVB	#040,(R3)
132064:	MOV	R3,R4
132066:	MOV	(SP)+,R3
132070:	CALL	133600
132074:	BR	131774
132076:	BIT	#001,006502
132104:	BEQ	132122
132106:	BIC	#001,006502
132114:	CALL	133062
132120:	BR	131774
132122:	BIS	#001,006502
132130:	CALL	133070
132134:	BR	131774
132136:	CMPB	(R3),#040
132142:	BEQ	132152
132144:	CALL	133650
132150:	BR	132136
132152:	CMP	R3,R4
132154:	BHIS	131774
132156:	CALL	133650
132162:	CMPB	(R3),#040
132166:	BEQ	132152
132170:	BR	131774
132172:	CMP	#007236,R3
132176:	BEQ	131774
132200:	DEC	R3
132202:	CALL	122244
132206:	CMPB	(R3),#040
132212:	BEQ	132172
132214:	CMP	#007236,R3
132220:	BEQ	131774
132222:	DEC	R3
132224:	CALL	122244
132230:	CMPB	(R3),#040
132234:	BNE	132214
132236:	CALL	133650
132242:	BR	131774
132244:	MOV	006510,006120
132252:	MOV	006512,006506
132260:	MOV	#007236,R3	; input line buffer
132264:	BR	131774
132266:	BR	132430
132270:	BR	132442
132272:	CMP	R3,R4
132274:	BHIS	132264
132276:	MOV	006506,-(SP)
132302:	MOV	006120,-(SP)
132306:	SUB	R3,R4
132310:	MOV	R3,R1
132312:	MOVB	#040,R2
132316:	MOVB	R2,(R3)+
132320:	CALL	120034		; display character r2
132324:	SOB	R4,132316
132326:	CALL	121760
132332:	MOV	R1,R3
132334:	MOV	R3,R4
132336:	MOV	(SP)+,006120
132342:	MOV	(SP)+,006506
132346:	JMP	131774
132352:	CMP	R3,#007236
132356:	BLOS	132346
132360:	CMP	R3,R4
132362:	BNE	132366
132364:	DEC	R4
132366:	CALL	121760
132372:	MOVB	#040,-(R3)
132376:	CALL	122462
132402:	JMP	131356
132406:	CALL	133374
132412:	BR	132420
132414:	CALL	133326
132420:	CALL	133110
132424:	JMP	131356
132430:	CMP	R3,R4
132432:	BHIS	132346
132434:	CALL	133650
132440:	BR	132430
132442:	CALL	121760
132446:	MOV	R3,-(SP)
132450:	MOV	006506,-(SP)
132454:	MOV	006120,-(SP)
132460:	CALL	131000
132464:	MOV	#132474,-(SP)
132470:	JMP	103434
132474:	CALL	131042
132500:	CLR	006506
132504:	MOV	#010,006120
132512:	MOV	#134006,R3
132516:	MOVB	(R3)+,R2
132520:	BMI	132530
132522:	CALL	120034		; display character r2
132526:	BR	132516
132530:	CALL	137472		; wait for a key
132534:	CALL	131042
132540:	MOV	#134212,R2
132544:	MOV	#010,006120
132552:	CLR	006506
132556:	MOV	#010,R4
132562:	CLR	R3
132564:	MOVB	(R2)+,R3
132566:	CALL	132646
132572:	MOVB	(R2)+,R1
132574:	MOV	R2,R3
132576:	MOVB	(R3)+,R2
132600:	CALL	120034		; display character r2
132604:	SOB	R1,132576
132606:	MOV	R3,R2
132610:	SOB	R4,132564
132612:	MOV	#023,R1
132616:	MOVB	(R3)+,R2
132620:	CALL	120034		; display character r2
132624:	SOB	R1,132616
132626:	CALL	137472		; wait for a key
132632:	MOV	007206,R1
132636:	INC	007046
132642:	JMP	130300
132646:	MOV	006120,-(SP)
132652:	MOV	R1,-(SP)
132654:	CLR	R1
132656:	MOV	#176000,006544
132664:	MOVB	(R2)+,R1
132666:	SWAB	R1
132670:	CALL	121436		; plot a dot
132674:	INC	006120
132700:	SOB	R3,132664
132702:	MOV	(SP)+,R1
132704:	MOV	(SP)+,006120
132710:	ADD	006516,006506
132716:	CMP	006506,006524
132724:	BLE	132740
132726:	CLR	006506
132732:	ADD	006520,006120
132740:	RETURN
132742:	MOV	#002,R3
132746:	TSTB	-(R1)
132750:	CMP	R1,#F58
132754:	BLOS	132766
132756:	CMPB	-(R1),#012
132762:	BNE	132756
132764:	SOB	R3,132750
132766:	TSTB	(R1)+
132770:	CALL	121760
132774:	MOV	#001,006540
133002:	MOV	R1,007206
133006:	JMP	130372
133012:	CMP	R1,R5
133014:	BGE	133040
133016:	CALL	121760
133022:	MOV	#001,006540
133030:	MOV	R1,007206
133034:	JMP	130372
133040:	TSTB	-(R1)
133042:	CMPB	-(R1),#012
133046:	BEQ	133056
133050:	CMP	R1,#F58
133054:	BNE	133042
133056:	TSTB	(R1)+
133060:	BR	133016
133062:	MOV	#133754,R2
133066:	BR	133074
133070:	MOV	#133761,R2
133074:	MOV	R5,-(SP)
133076:	MOV	R2,R5
133100:	CALL	141526
133104:	MOV	(SP)+,R5
133106:	RETURN
133110:	CALL	133136
133114:	TST	R1
133116:	BEQ	133130
133120:	CALL	133600
133124:	CALL	133650
133130:	CALL	121760
133134:	RETURN
133136:	CMP	#EEE,R3
133142:	BLOS	133162
133144:	CMP	#EEE,R4
133150:	BLOS	133162
133152:	CMP	R3,R4
133154:	BLO	133166
133156:	CALL	133712
133162:	CLR	R1
133164:	RETURN
133166:	MOV	R4,-(SP)
133170:	SUB	R3,R4
133172:	INC	R4
133174:	MOV	R4,R1
133176:	MOV	(SP),R3
133200:	MOVB	(R3)+,(R3)
133202:	CMPB	-(R3),-(R3)
133204:	SOB	R4,133200
133206:	INC	R3
133210:	MOV	(SP)+,R4
133212:	INC	R4
133214:	CMPB	R2,#077
133220:	BLE	133226
133222:	BISB	006504,R2
133226:	MOVB	R2,(R3)
133230:	CMPB	R2,#016
133234:	BEQ	133244
133236:	CMPB	R2,#017
133242:	BNE	133250
133244:	CALL	133252
133250:	RETURN
133252:	MOV	R3,-(SP)
133254:	TSTB	(R3)+
133256:	CMP	R3,R4
133260:	BEQ	133322
133262:	CMPB	(R3),#077
133266:	BGT	133304
133270:	CMPB	(R3),#016
133274:	BEQ	133322
133276:	CMPB	(R3),#017
133302:	BEQ	133322
133304:	MOVB	(R3),R2
133306:	BICB	#200,R2
133312:	BISB	006504,R2
133316:	MOVB	R2,(R3)
133320:	BR	133254
133322:	MOV	(SP)+,R3
133324:	RETURN
133326:	MOV	006104,006110
133334:	MOV	#200,006504
133342:	BIS	#040,006612
133350:	TST	007154
133354:	BEQ	133364
133356:	BIC	#040,006612
133364:	MOV	#016,006070
133372:	RETURN
133374:	MOV	006102,006110
133402:	CLR	006504
133406:	BIC	#040,006612
133414:	TST	007154
133420:	BEQ	133430
133422:	BIS	#040,006612
133430:	MOV	#017,006070
133436:	RETURN
133440:	MOV	R3,-(SP)
133442:	CMP	R3,#007236
133446:	BLE	133500
133450:	CMPB	-(R3),#016
133454:	BEQ	133514
133456:	BITB	(R3),#200
133462:	BNE	133514
133464:	CMPB	(R3),#017
133470:	BEQ	133500
133472:	CMPB	(R3),#077
133476:	BLE	133442
133500:	CALL	133374
133504:	MOV	(SP)+,R3
133506:	CALL	133252
133512:	RETURN
133514:	MOV	(SP)+,R3
133516:	RETURN
133520:	MOV	R3,-(SP)
133522:	CMP	R3,#007236
133526:	BLE	133560
133530:	CMPB	-(R3),#017
133534:	BEQ	133560
133536:	BITB	#200,(R3)
133542:	BNE	133564
133544:	CMPB	(R3),#016
133550:	BEQ	133564
133552:	CMPB	(R3),#077
133556:	BLE	133522
133560:	MOV	(SP)+,R3
133562:	RETURN
133564:	MOV	(SP)+,R3
133566:	CALL	133326
133572:	CALL	133252
133576:	RETURN
133600:	TST	R1
133602:	BEQ	133646
133604:	MOV	006506,-(SP)
133610:	MOV	006120,-(SP)
133614:	MOV	R3,R0
133616:	MOV	006110,-(SP)
133622:	CALL	131142
133626:	MOV	(SP)+,006110
133632:	CALL	121760
133636:	MOV	(SP)+,006120
133642:	MOV	(SP)+,006506
133646:	RETURN
133650:	CMP	#EEE,R3
133654:	BLOS	133710
133656:	INC	R3
133660:	ADD	006516,006506
133666:	CMP	006524,006506
133674:	BHIS	133710
133676:	CLR	006506
133702:	ADD	006520,006120
133710:	RETURN
133712:	CMP	#EED,R3
133716:	BLO	133752
133720:	CMPB	R2,#077
133724:	BLE	133732
133726:	BISB	006504,R2
133732:	MOVB	R2,(R3)+
133734:	MOV	#001,R1
133740:	CALL	131144
133744:	CMP	R4,R3
133746:	BHIS	133752
133750:	MOV	R3,R4
133752:	RETURN

133740:	F7 09 80 FA  03 21 01 86  C4 10 87 00  2A 5A 41 4D  w..z.!..D...*ZAM
133760:	00 2A 57 53  54 00 60 80  E0 20 F0 48  48 30 60 80  .*WST.`.` pHH0`.
134000:	E0 20 D0 10  10 10 0E 73  75 0F 2F 41  2D 0E 4E 41  ` P....su./A-.NA
134020:	5E 41 4C 4F  20 53 54 52  4F 4B 49 0D  0A 73 75 0F  ^ALO STROKI..su.
134040:	2F 42 2D 0E  50 52 45 44  59 44 55 5D  45 45 0D 0A  /B-.PREDYDU]EE..
134060:	20 20 20 20  20 53 4C 4F  57 4F 0D 0A  73 75 0F 2F       SLOWO..su./
134100:	45 2D 0E 55  44 41 4C 49  54 58 20 5E  41 53 54 58  E-.UDALITX ^ASTX
134120:	0D 0A 20 20  20 20 20 53  54 52 4F 4B  49 0D 0A 73  ..     STROKI..s
134140:	75 0F 2F 46  2D 0E 53 4C  45 44 55 40  5D 45 45 20  u./F-.SLEDU@]EE 
134160:	53 4C 4F 57  4F 73 75 0F  2F 58 2D 0E  4B 4F 4E 45  SLOWOsu./X-.KONE
134200:	43 20 53 54  52 4F 4B 49  0F FF 06 00  20 10 F8 10  C STROKI.... .x.
134220:	20 0D 0F 2D  0E 57 50 52  41 57 4F 20  20 20 0F 06   ..-.WPRAWO   ..
134240:	00 20 40 F8  40 20 0B 2D  0E 57 4C 45  57 4F 20 20  . @x@ .-.WLEWO  
134260:	0D 0F 06 00  20 90 F8 90  20 0C 2D 0E  57 53 54 41  .... .x. .-.WSTA
134300:	57 49 54 58  20 0F 06 00  20 48 F8 48  20 0B 2D 0E  WITX ... HxH .-.
134320:	55 44 41 4C  49 54 58 0D  0F 06 00 20  70 A8 20 20  UDALITX.... p(  
134340:	16 2D 0E 50  52 45 44 59  44 55 5D 41  51 20 53 54  .-.PREDYDU]AQ ST
134360:	52 4F 4B 41  0D 0A 0F 06  00 20 20 A8  70 20 15 2D  ROKA.....  (p .-
134400:	0E 53 4C 45  44 55 40 5D  41 51 20 53  54 52 4F 4B  .SLEDU@]AQ STROK
134420:	41 0D 0A 0F  06 00 20 70  A8 20 70 18  2D 0E 50 52  A..... p( p.-.PR
134440:	45 44 59 44  55 5D 0F 2E  0E 20 4F 50  45 52 41 54  EDYDU]... OPERAT
134460:	4F 52 0D 0F  06 00 70 20  A8 70 20 15  2D 0E 53 4C  OR....p (p .-.SL
134500:	45 44 55 40  5D 49 4A 20  4F 50 45 52  41 54 4F 52  EDU@]IJ OPERATOR
134520:	0D 77 6B 0F  2D 0E 57 59  48 4F 44 20  49 5A 09 0F  .wk.-.WYHOD IZ..
134540:	45 44 49 54  F7 09 E4 E6  F7 95 03 00  06 54 F7 15  EDITw.dfw....Tw.

134540:	BIC	(R1)+,R5
134542:	BIS	(R1)+,(R1)
134544:	CALL	120114		; save registers on the stack
134550:	MOVB	#003,006564
134556:	MOV	#001,007216
134564:	MOV	#001,007220
134572:	CLR	007222
134576:	MOV	#D76,R0
134602:	TST	(R0)
134604:	BNE	134620
134606:	CLR	000010(R0)
134612:	MOV	000002(R0),000012(R0)
134620:	MOV	000010(R0),R4
134624:	MOV	000012(R0),R5
134630:	CALL	136340
134634:	CALL	136510
134640:	MOV	#001,007162
134646:	MOV	#001,007164
134654:	MOV	000004(R0),007166
134662:	MOV	000006(R0),007170
134670:	ADD	R4,007166
134674:	SUB	R5,007170
134700:	MOV	#177777,-(SP)
134704:	CALL	135474
134710:	CALL	136256
134714:	MOV	007166,R4
134720:	MOV	007170,R5
134724:	BIT	#010,006534
134732:	BEQ	134740
134734:	CALL	044142
134740:	TST	(R0)
134742:	BEQ	134750
134744:	CALL	135406
134750:	BIT	#010,006534
134756:	BEQ	134766
134760:	CALL	044022
134764:	BR	134772
134766:	CALL	124216
134772:	TST	R3
134774:	BGE	135016
134776:	ADD	007162,R4
135002:	SUB	007172,R2
135006:	ADD	007174,R1
135012:	ADD	R2,R3
135014:	BR	135040
135016:	ADD	007162,R4
135022:	ADD	007164,R5
135026:	SUB	007174,R2
135032:	ADD	007176,R1
135036:	SUB	R1,R3
135040:	CMP	R4,007166
135044:	BNE	135060
135046:	CMP	R5,007170
135052:	BNE	135060
135054:	JMP	135354
135060:	TST	R2
135062:	BGE	135072
135064:	CALL	135262
135070:	BR	135040
135072:	TST	R1
135074:	BGE	134750
135076:	CALL	135104
135102:	BR	135040
135104:	MOV	R4,-(SP)
135106:	MOV	R5,R4
135110:	MOV	(SP),R5
135112:	MOV	007162,(SP)
135116:	MOV	007164,007162
135124:	MOV	(SP),007164
135130:	MOV	007166,(SP)
135134:	MOV	007170,007166
135142:	MOV	(SP)+,007170
135146:	NEG	000002(SP)
135152:	MOV	007174,R0
135156:	ASL	R0
135160:	SUB	007176,R0
135164:	MOV	R0,-(SP)
135166:	SUB	007172,R0
135172:	MOV	R0,007172
135176:	SUB	007176,007174
135204:	NEG	007176
135210:	MOV	007174,R0
135214:	ASR	R0
135216:	SUB	R0,R2
135220:	ADD	R1,R2
135222:	NEG	R3
135224:	ADD	R2,R3
135226:	MOV	R1,R0
135230:	ASR	R0
135232:	SUB	R0,R3
135234:	MOV	007176,R0
135240:	ASR	R0
135242:	ASR	R0
135244:	ASR	R0
135246:	ADD	R0,R3
135250:	MOV	(SP)+,R0
135252:	ASR	R0
135254:	NEG	R1
135256:	ADD	R0,R1
135260:	RETURN
135262:	NEG	007164
135266:	MOV	007174,R0
135272:	SUB	007172,R0
135276:	NEG	007172
135302:	MOV	007172,007174
135310:	ADD	R0,007174
135314:	ASL	R0
135316:	ASL	R0
135320:	NEG	007176
135324:	ADD	R0,007176
135330:	NEG	R2
135332:	SUB	R0,R2
135334:	NEG	R3
135336:	SUB	R1,R3
135340:	ADD	R2,R3
135342:	SUB	R0,R1
135344:	MOV	R2,R0
135346:	ASL	R0
135350:	SUB	R0,R1
135352:	RETURN
135354:	BIT	#010,006534
135362:	BEQ	135372
135364:	CALL	044022
135370:	BR	135376
135372:	CALL	124216
135376:	TST	(SP)+
135400:	CALL	120140		; restore registers from the stack
135404:	RETURN
135406:	MOV	R4,-(SP)
135410:	MOV	R5,-(SP)
135412:	MOV	R1,-(SP)
135414:	MOV	R2,-(SP)
135416:	MOV	000014(R0),R4
135422:	MOV	000016(R0),R5
135426:	CALL	136340
135432:	MOV	000004(R0),007166
135440:	MOV	000006(R0),007170
135446:	ADD	R4,007166
135452:	SUB	R5,007170
135456:	CALL	136256
135462:	MOV	(SP)+,R2
135464:	MOV	(SP)+,R1
135466:	MOV	(SP)+,R5
135470:	MOV	(SP)+,R4
135472:	RETURN
135474:	CMPB	#001,007202
135502:	BNE	135644
135504:	MOV	007220,007172
135512:	ASL	007172
135516:	MOV	007222,007174
135524:	ASL	007174
135530:	MOV	007216,007176
135536:	ASL	007176
135542:	ADD	007174,007176
135550:	ADD	007172,007174
135556:	ADD	007174,007176
135564:	MOV	R5,R2
135566:	ASL	R2
135570:	SUB	007220,R2
135574:	SUB	007222,R2
135600:	MOV	R4,R1
135602:	ASL	R1
135604:	SUB	R2,R1
135606:	MOV	007216,R3
135612:	ASR	R3
135614:	ASR	R3
135616:	NEG	R3
135620:	SUB	R4,R3
135622:	ADD	R2,R3
135624:	ADD	007200,R3
135630:	MOV	R4,-(SP)
135632:	MOV	R5,R4
135634:	MOV	(SP)+,R5
135636:	NEG	000002(SP)
135642:	RETURN
135644:	CMPB	#002,007202
135652:	BNE	136016
135654:	MOV	007216,007172
135662:	ASL	007172
135666:	NEG	007172
135672:	MOV	007222,007174
135700:	ASL	007174
135704:	NEG	007174
135710:	MOV	007220,007176
135716:	ASL	007176
135722:	NEG	007176
135726:	ADD	007174,007176
135734:	ADD	007172,007174
135742:	ADD	007174,007176
135750:	MOV	R4,R2
135752:	ASL	R2
135754:	ADD	007216,R2
135760:	ADD	007222,R2
135764:	MOV	R5,R1
135766:	ASL	R1
135770:	SUB	R2,R1
135772:	MOV	007220,R3
135776:	ASR	R3
136000:	ASR	R3
136002:	ADD	R2,R3
136004:	SUB	R5,R3
136006:	SUB	007200,R3
136012:	JMP	135642
136016:	CMPB	#003,007202
136024:	BNE	136054
136026:	NEG	007164
136032:	NEG	007216
136036:	NEG	007220
136042:	NEG	R4
136044:	NEG	007200
136050:	JMP	135654
136054:	CMPB	#004,007202
136062:	BNE	136112
136064:	NEG	007162
136070:	NEG	007220
136074:	NEG	007216
136100:	NEG	R4
136102:	NEG	007200
136106:	JMP	135504
136112:	CMPB	#005,007202
136120:	BNE	136142
136122:	NEG	007162
136126:	NEG	007164
136132:	NEG	R4
136134:	NEG	R5
136136:	JMP	135504
136142:	CMPB	#006,007202
136150:	BNE	136172
136152:	NEG	007162
136156:	NEG	007164
136162:	NEG	R4
136164:	NEG	R5
136166:	JMP	135654
136172:	CMPB	#007,007202
136200:	BNE	136230
136202:	NEG	007162
136206:	NEG	007216
136212:	NEG	007220
136216:	NEG	R5
136220:	NEG	007200
136224:	JMP	135654
136230:	NEG	007164
136234:	NEG	007220
136240:	NEG	007216
136244:	NEG	R5
136246:	NEG	007200
136252:	JMP	135504
136256:	CMPB	#001,007202
136264:	BNE	136306
136266:	MOV	007166,-(SP)
136272:	MOV	007170,007166
136300:	MOV	(SP)+,007170
136304:	RETURN
136306:	CMPB	#004,007202
136314:	BEQ	136266
136316:	CMPB	#005,007202
136324:	BEQ	136266
136326:	CMPB	#010,007202
136334:	BEQ	136266
136336:	BR	136304
136340:	MOV	R4,R1
136342:	MOV	R5,R2
136344:	TST	R4
136346:	BGE	136432
136350:	TST	R5
136352:	BGE	136404
136354:	NEG	R1
136356:	NEG	R2
136360:	CMP	R1,R2
136362:	BGE	136374
136364:	MOVB	#006,007202
136372:	BR	136506
136374:	MOVB	#005,007202
136402:	BR	136506
136404:	NEG	R1
136406:	CMP	R1,R2
136410:	BGE	136422
136412:	MOVB	#003,007202
136420:	BR	136506
136422:	MOVB	#004,007202
136430:	BR	136506
136432:	TST	R5
136434:	BGT	136464
136436:	NEG	R2
136440:	CMP	R1,R2
136442:	BGE	136454
136444:	MOVB	#007,007202
136452:	BR	136506
136454:	MOVB	#010,007202
136462:	BR	136506
136464:	CMP	R1,R2
136466:	BGE	136500
136470:	MOVB	#002,007202
136476:	BR	136506
136500:	MOVB	#001,007202
136506:	RETURN
136510:	MOV	000002(R0),R1
136514:	MUL	R1,R1
136516:	MOV	R1,007200
136522:	MOV	000010(R0),R1
136526:	MUL	R1,R1
136530:	SUB	R1,007200
136534:	MOV	000012(R0),R1
136540:	MUL	R1,R1
136542:	SUB	R1,007200
136546:	RETURN

; keyboard interrupt service routine
136550:	MOV	#262,@#164024
136556:	MOV	#001,007430	; flag of a pressed key
136564:	CLR	@#164026	; start of the transfer
136570:	TSTB	@#164024
136574:	BPL	136570
136576:	MOV	@#164026,006606	; key scan code, end of the transfer
136604:	TSTB	@#164024
136610:	BPL	136604
136612:	MOV	R2,-(SP)
136614:	TST	007160
136620:	BEQ	136642
136622:	MOV	R0,-(SP)
136624:	MOV	#050,R2		; note C3
136630:	MOV	#001,R0		; duration time 32 ms
136634:	CALL	123214		; make a beep
136640:	MOV	(SP)+,R0
136642:	MOV	006606,R2
136646:	CMPB	R2,#033		; key SU ?
136652:	BNE	136720
136654:	XOR	R2,007156	; SU keyboard mode flag
136660:	MOV	#177740,R2
136664:	XOR	R2,006614
136670:	CALL	141442
136674:	XOR	R2,006614
136700:	MOV	(SP)+,R2
136702:	MOV	#162,@#164024
136710:	MOV	#252,@#164024
136716:	RTI
;
136720:	TSTB	007156		; SU keyboard mode flag
136724:	BEQ	136700		; branch if not SU keyboard mode
136726:	CLR	007156
136732:	CMPB	R2,#027		; key [ ?
136736:	BNE	136746
136740:	XOR	R2,007160
136744:	BR	137252
136746:	CMPB	R2,#063		; key S ?
136752:	BEQ	137162
136754:	CMPB	R2,#357		; key P ?
136760:	BEQ	137024
136762:	CMPB	R2,#013		; key A ?
136766:	BEQ	137270		; display the authors
136770:	CMPB	R2,#157		; key L ?
136774:	BNE	136700
136776:	TST	@#164036
137002:	BMI	136700
137004:	MOV	#001,007502
137012:	MFPS	-(SP)
137014:	MOV	#136700,-(SP)
137020:	JMP	142656

137024:	MOV	006374,-(SP)
137030:	BIT	#200,006534
137036:	BEQ	137054
137040:	MOV	006512,006506
137046:	MOV	006510,006120
137054:	CALL	125226
137060:	TST	007502
137064:	BEQ	137110
137066:	MOV	006512,006506
137074:	MOV	006510,006120
137102:	MOV	#001,006126
137110:	CLR	007440
137114:	MOV	#001,006374
137122:	MOV	#136,R2
137126:	TRAP	000		; print character r2
137130:	MOV	#120,R2
137134:	TRAP	000		; print character r2
137136:	MOV	(SP)+,006374
137142:	MOV	#001,007400
137150:	CALL	141442
137154:	CLR	006560
137160:	BR	136700

137162:	CLR	006614
137166:	CALL	141442
137172:	MOV	#352,@#164024
137200:	WAIT
137202:	TST	007156		; SU keyboard mode flag
137206:	BEQ	137200		; branch if not SU keyboard mode
137210:	CLR	007156
137214:	WAIT
137216:	CMPB	006606,#357	; key P ?
137224:	BEQ	137024
137226:	CLR	007156
137232:	CLR	006614
137236:	CALL	141442
137242:	CMPB	006606,#367	; key Q ?
137250:	BNE	137200
137252:	CLR	006606
137256:	CLR	006614
137262:	CALL	141442
137266:	BR	136700

; display the authors
137270:	CLR	006614
137274:	CALL	141442
137300:	CLR	006606
137304:	MOV	R0,-(SP)
137306:	MOV	R2,-(SP)
137310:	MOV	#137334,R0	; string 'Awtory: ...' (Authors: ...)
137314:	TRAP	066		; print a string pointed to by r0
137316:	MOV	(SP)+,R2
137320:	MOV	(SP)+,R0
137322:	JMP	136700

; EVNT interrupt service routine
137326:	DEC	007424		; counter decremented at each EVNT interrupt
137332:	RTI

137320:	80 15 77 00  EA FE F7 0A  3A 50 02 00  0D 0A 0E 61  ..w.j~w.:P.....a
137340:	57 54 4F 52  59 3A 0D 0A  6B 4C 49 4D  45 4E 4B 4F  WTORY:..kLIMENKO
137360:	57 2C 6E 41  55 4D 4F 57  41 20 20 20  66 41 4E 44  W,nAUMOWA   fAND
137400:	45 45 57 41  2C 6B 4F 4E  44 52 41 54  45 4E 4B 4F  EEWA,kONDRATENKO
137420:	65 52 5B 4F  57 41 2C 7B  45 53 54 41  4B 20 20 20  eR[OWA,{ESTAK   
137440:	20 20 20 20  64 45 4E 49  53 45 57 49  5E 2C 73 41      dENISEWI^,sA
137460:	57 5E 45 4E  4B 4F 0F 0D  0A 00 DF 15  A2 00 14 E8  W^ENKO...._."..h

; wait for a key, return the ASCII code of the pressed key in r2
137472:	MOV	#242,@#164024
137500:	CLR	007430		; clear the flag of a pressed key
137504:	WAIT
137506:	TST	007430		; key pressed?
137512:	BEQ	137504		; back to the waiting loop if not
137514:	CLR	007430		; clear the flag of a pressed key
137520:	MOV	R4,-(SP)
137522:	MOV	R5,-(SP)
137524:	MOV	006606,R0	; key scan code
137530:	CLR	006606
137534:	BIC	#177400,R0
137540:	CMP	#337,R0		; key ZV (backspace) ?
137544:	BNE	137566
137546:	TST	006616
137552:	BNE	140142
137554:	XOR	R0,006610
137560:	CALL	141422
137564:	BR	140142
;
137566:	SUB	#012,R0
137572:	ASR	R0
137574:	ASR	R0
137576:	TST	006610
137602:	BEQ	140012
137604:	CMP	R0,#075
137610:	BLE	137614
137612:	BR	140142
137614:	MOV	#140414,R5	; keywords typed with a single key stroke
137620:	MOV	R0,R4
137622:	INC	R0
137624:	CMPB	(R5)+,#044	; '$'
137630:	BNE	137624
137632:	SOB	R0,137624
137634:	BICB	#070,R4
137640:	CMP	R4,#005
137644:	BGT	137746
137646:	MOVB	#040,R2
137652:	BIT	#020,006534
137660:	BEQ	137722
137662:	MOV	R4,-(SP)
137664:	MOV	000004(SP),R4
137670:	BIT	#001,006502
137676:	BEQ	137706
137700:	CALL	133110
137704:	BR	137712
137706:	CALL	133712
137712:	MOV	R4,000004(SP)
137716:	MOV	(SP)+,R4
137720:	BR	137740
137722:	CALL	120034		; display character r2
137726:	MOVB	R2,(R3)+
137730:	CMP	R3,#007357
137734:	BLO	137740
137736:	TRAP	031		; error 12 - input line too long (more than 80
				; characters)
137740:	TST	006610
137744:	BEQ	140142
137746:	MOVB	(R5)+,R2
137750:	CMPB	R2,#052
137754:	BEQ	137764
137756:	CMPB	#044,R2
137762:	BNE	137652
137764:	CLR	006610
137770:	CALL	141422
137774:	CMPB	R2,#052
140000:	BEQ	140142
140002:	CMP	R4,#005
140006:	BLE	137646
140010:	BR	140142
;
140012:	CMP	#064,R0
140016:	BNE	140026
140020:	MOV	#177,R0
140024:	BR	140106
140026:	MOV	#001,R5
140032:	MOV	#020,R2
140036:	CMP	#075,R0
140042:	BEQ	140176
140044:	ASL	R2
140046:	CMPB	#005,R0
140052:	BEQ	140154
140054:	NEG	R2
140056:	CMP	#004,R0
140062:	BEQ	140132
140064:	ADD	PC,R0
140066:	ADD	#000230,R0	; 140066+000230 = 140316, table of key codes
140072:	MOVB	(R0),R0
140074:	CMP	R0,#100
140100:	BLT	140216
140102:	BIS	006612,R0
140106:	BIC	006614,R0
140112:	TST	006614
140116:	BEQ	140144
140120:	CLR	006614
140124:	CALL	141442
140130:	BR	140144
140132:	XOR	R2,006614
140136:	CALL	141442
140142:	CLR	R0
140144:	MOV	(SP)+,R5
140146:	MOV	(SP)+,R4
140150:	MOV	R0,R2
140152:	RETURN

140154:	XOR	R2,006612
140160:	XOR	R5,006070
140164:	MOVB	006070,R0
140170:	CALL	141400
140174:	BR	140106
140176:	XOR	R2,007154
140202:	ASL	R2
140204:	XOR	R2,006612
140210:	CALL	141354
140214:	BR	140142
140216:	CMP	R0,#060
140222:	BLT	140232
140224:	SUB	007154,R0
140230:	BR	140106
140232:	TST	007154
140236:	BEQ	140246
140240:	CMP	R0,#040
140244:	BLE	140254
140246:	ADD	007154,R0
140252:	BR	140106
140254:	CMP	#024,R0
140260:	BNE	140270
140262:	BIS	#002,R0
140266:	BR	140106
140270:	CMP	#023,R0
140274:	BNE	140302
140276:	DEC	R0
140300:	BR	140106
140302:	CMP	#010,R0
140306:	BNE	140106
140310:	MOV	#002,R0
140314:	BR	140106

; table of key codes
140316:	      41 49  52 5B 00 00	  AIR[..
140324:	31 36 42 4A  53 5D 1C 1D	16BJS]..
140334:	32 37 57 4B  54 58 1A 14	27WKTX..
140344:	33 38 47 4C  55 59 2C 20	38GLUY, 
140354:	34 39 44 4D  46 5F 2E 20	49DMF_. 
140364:	35 30 45 4E  48 5C 19 13	50ENH\..
140374:	3A 2F 56 4F  43 40 7F 1B	:/VOC@..
140404:	3B 2D 5A 50  5E 51 0D 00	;-ZP^Q..

; keywords typed with a single key stroke
140414:	24 41 55 54  $AUT
140420:	4F 24 49 4E  50 55 54 24  52 55 4E 24  52 45 54 55  O$INPUT$RUN$RETU
140440:	52 4E 24 2A  24 2A 24 53  49 4E 28 24  43 4F 53 28  RN$*$*$SIN($COS(
140460:	24 44 52 41  57 24 49 4E  49 54 24 53  54 45 50 24  $DRAW$INIT$STEP$
140500:	52 45 53 54  4F 52 45 24  44 49 53 24  47 4F 53 55  RESTORE$DIS$GOSU
140520:	42 24 45 58  50 28 24 4C  4F 47 28 24  57 41 49 54  B$EXP($LOG($WAIT
140540:	24 4B 49 4C  4C 24 53 41  56 45 24 52  45 4D 24 44  $KILL$SAVE$REM$D
140560:	45 56 24 2A  24 41 42 53  28 24 53 47  4E 28 24 47  EV$*$ABS($SGN($G
140600:	4F 54 4F 24  4C 45 54 24  53 54 4F 50  24 52 45 41  OTO$LET$STOP$REA
140620:	44 24 44 45  46 20 46 4E  24 2A 24 53  51 52 28 24  D$DEF FN$*$SQR($
140640:	41 54 4E 28  24 44 41 54  41 24 4C 49  53 54 24 46  ATN($DATA$LIST$F
140660:	4F 52 24 52  41 4E 44 4F  4D 49 5A 45  24 44 49 4D  OR$RANDOMIZE$DIM
140700:	24 2A 24 49  4E 54 28 24  52 4E 44 28  24 45 4E 44  $*$INT($RND($END
140720:	24 4E 45 58  54 24 48 45  4C 50 24 46  49 4C 45 53  $NEXT$HELP$FILES
140740:	24 44 45 4C  45 54 45 24  2A 24 20 4C  4C 49 53 54  $DELETE$*$ LLIST
140760:	20 24 20 4C  46 49 4C 45  53 20 24 45  44 49 54 24   $ LFILES $EDIT$
141000:	4E 41 4D 45  24 43 4C 53  24 4C 4F 41  44 24 2A 24  NAME$CLS$LOAD$*$
141020:	2A 24 20 4C  50 52 49 4E  54 20 24 24  54 48 45 4E  *$ LPRINT $$THEN
141040:	24 50 52 49  4E 54 24 50  4C 41 59 24  4C 4F 43 41  $PRINT$PLAY$LOCA
141060:	54 45 24 24  24  TE$$$
141065:	.EVEN

141066:	CALL	122324
141072:	MOV	006120,-(SP)
141076:	MOV	006506,-(SP)
141102:	MOV	R3,-(SP)
141104:	CLR	006120
141110:	BIS	#041,006534
141116:	CLR	006506
141122:	MOV	R0,-(SP)
141124:	MOV	#027,R0		; number of characters to print
141130:	MOV	#141324,R3	; string "basic v..."
141134:	MOVB	(R3)+,R2
141136:	CALL	120034		; display character r2
141142:	SOB	R0,141134
141144:	CLR	006506
141150:	CLR	006120
141154:	MOV	006126,-(SP)
141160:	MOV	#002,006126
141166:	CLR	R0
141170:	MOV	#012,R2
141174:	MOV	R1,-(SP)
141176:	MOVB	141312(R0),R1
141202:	SWAB	R1
141204:	MOVB	141266(R0),R3
141210:	ADD	R3,006120
141214:	MOVB	141300(R0),R3
141220:	ADD	R3,006506
141224:	CALL	121436		; plot a dot
141230:	INC	R0
141232:	SOB	R2,141176
141234:	MOV	(SP)+,R1
141236:	MOV	(SP)+,006126
141242:	MOV	(SP)+,R0
141244:	MOV	(SP)+,R3
141246:	MOV	(SP)+,006506
141252:	MOV	(SP)+,006120
141256:	BIC	#041,006534
141264:	RETURN

141266:	02 01 01 01 01 FC 01 01 01 01
141300:	30 00 00 00 00 08 00 00 00 00
141312:	70 88 30 43 FB 38 4C 54 64 38

141324:	0F 20 62 61  73 69 63 20  76 20 20 20	. basic v   
141340:	20 0E 20 20  57 52 20 4C  41 54 0F FF   .  WR LAT..

141354:	MOV	#141504,R5
141360:	TST	007154
141364:	BEQ	141372
141366:	MOV	#141507,R5
141372:	CALL	141526
141376:	RETURN
141400:	MOV	#141472,R5
141404:	CMP	#016,006070
141412:	BEQ	141372
141414:	MOV	#141477,R5
141420:	BR	141372
141422:	MOV	#141512,R5
141426:	TST	006610
141432:	BNE	141372
141434:	MOV	#141516,R5
141440:	BR	141372

141442:	MOV	R5,-(SP)
141444:	MOV	#141522,R5
141450:	TST	006614
141454:	BNE	141462
141456:	MOV	#141516,R5
141462:	CALL	141526
141466:	MOV	(SP)+,R5
141470:	RETURN

141472:	.ASCIZ	"fRUS"
141501:	.ASCIZ	"fLAT"
141504:	.ASCIZ	"TW"
141507:	.ASCIZ	"TN"
141512:	.ASCIZ	"BFK"
141516:	.ASCIZ	"B  "
141523:	.ASCIZ	"BSU"

141526:	TST	006536
141532:	BNE	141722
141534:	MOV	006126,-(SP)
141540:	MOV	006534,-(SP)
141544:	MOV	R2,-(SP)
141546:	MOV	006120,-(SP)
141552:	MOV	006506,-(SP)
141556:	MOV	#001,006126
141564:	MOV	#001,006540
141572:	BIC	#100,006534	; set output to the screen
141600:	BIS	#041,006534
141606:	MOV	006110,-(SP)
141612:	MOV	006504,-(SP)
141616:	CLR	006504
141622:	CLR	006120
141626:	MOVB	(R5)+,006506
141632:	BIC	#177400,006506
141640:	MOV	#016,R2
141644:	CALL	120034		; display character r2
141650:	MOVB	(R5)+,R2
141652:	BEQ	141656
141654:	BR	141644
141656:	CLR	006540
141662:	MOV	(SP)+,006504
141666:	MOV	(SP)+,006110
141672:	MOV	(SP)+,006506
141676:	MOV	(SP)+,006120
141702:	MOV	(SP)+,R2
141704:	MOV	(SP)+,006534
141710:	MOV	(SP)+,006126
141714:	BIC	#041,006534
141722:	RETURN

; command MEM
141724:	CALL	120114		; save registers on the stack
141730:	MOV	006110,-(SP)
141734:	MOV	#142136,R0	; string '   '
141740:	TRAP	066		; print a string pointed to by r0
141742:	MOV	006534,-(SP)
141746:	BIS	#001,006534	; inverted print mode
; r0 points to a string 'Raspredelenie pamjati (w bajtah)'
141754:	TRAP	066		; print a string pointed to by r0
141756:	MOV	(SP)+,006534
141762:	MOV	#142213,R0	; string 'Programma: '
141766:	TRAP	066		; print a string pointed to by r0
141770:	MOV	R5,R3
141772:	SUB	007362,R3
141776:	CALL	142070		; r0 <- pointer to a zero terminated buffer
142002:	CALL	142100		; convert word r3 to decimal ASCII
142006:	TRAP	066		; print a string pointed to by r0
142010:	TRAP	002		; print CR, LF
142012:	MOV	#142227,R0	; string 'Svobodno: '
142016:	TRAP	066		; print a string pointed to by r0
142020:	MOV	SP,R3
142022:	SUB	R5,R3
142024:	BHI	142040
142026:	MOV	(SP)+,006110
142032:	CALL	120140		; restore registers from the stack
142036:	TRAP	001		; error 0 - out of memory
142040:	CALL	142070		; r0 <- pointer to a zero terminated buffer
142044:	CALL	142100		; convert word r3 to decimal ASCII
142050:	TRAP	066		; print a string pointed to by r0
142052:	TRAP	002		; print CR, LF
142054:	MOV	(SP)+,006110
142060:	CALL	120140		; restore registers from the stack
142064:	JMP	103144

; r0 <- pointer to a zero terminated buffer
142070:	MOV	#004700,R0
142074:	CLRB	-(R0)
142076:	RETURN

; convert word r3 to decimal ASCII, leading zeros are suppressed,
; on entry r0 should point to the end of the output buffer
142100:	CLR	007206		; number of digits
142104:	CLR	R2
142106:	DIV	#012,R2
142112:	BIS	#060,R3		; remainder
142116:	MOVB	R3,-(R0)
142120:	INC	007206
142124:	TST	R2		; quotient
142126:	BEQ	142134
142130:	MOV	R2,R3
142132:	BR	142104
142134:	RETURN

142120:	B7 0A 32 4A  C2 0B 02 03  83 10 F4 01  87 00 20 20  7.2JB.....t...  
142140:	20 00 20 0E  72 41 53 50  52 45 44 45  4C 45 4E 49   . .rASPREDELENI
142160:	45 20 0D 0A  20 50 41 4D  51 54 49 20  28 57 20 42  E .. PAMQTI (W B
142200:	41 4A 54 41  48 29 20 20  0D 0A 00 70  52 4F 47 52  AJTAH)  ...pROGR
142220:	41 4D 4D 41  3A 20 00 73  57 4F 42 4F  44 4E 4F 20  AMMA: .sWOBODNO 
142240:	3A 20 00 FF  3A 89 C1 0A  97 A0 0A 00  0B 02 F7 0B  : ..:.A.. ....w.

; command USR
142244:	TRAP	072		; get a character other than space to r2
142246:	DEC	R1
142250:	CMPB	R2,#012
142254:	BNE	142304
142256:	TST	007426
142262:	BEQ	142276
142264:	MOV	007426,006400
142272:	CLR	007426
142276:	TRAP	110
142300:	JMP	103276
142304:	CALL	170676		; get an octal number to r0
142310:	DEC	R1
142312:	TST	R0
142314:	BNE	142320
142316:	TRAP	075		; error 30 - wrong parameters
142320:	CALL	142342
142324:	BGT	142454
142326:	MOV	007426,006400
142334:	CLR	007426
142340:	TRAP	001		; error 0 - out of memory
142342:	MOV	006400,007426
142350:	INC	R0
142352:	ASR	R0
142354:	ASL	R0
142356:	SUB	R0,006400
142362:	MOV	R0,006546
142366:	TRAP	116
142370:	TRAP	104		; check the available stack space
142372:	BLE	142452
142374:	MOV	007426,R3
142400:	MOV	006400,R0
142404:	SUB	R3,R0
142406:	ADD	SP,R0
142410:	MOV	SP,R3
142412:	MOV	R0,SP
142414:	CMP	R3,007426
142420:	BHI	142426
142422:	MOV	(R3)+,(R0)+
142424:	BR	142414
142426:	MOV	006400,R0
142432:	CMP	R0,007426
142436:	BHI	142444
142440:	CLR	(R0)+
142442:	BR	142432
142444:	MOV	006546,R0
142450:	TRAP	104		; check the available stack space
142452:	RETURN
142454:	MOV	R1,R3
142456:	MOV	006400,R1
142462:	CALL	142070		; r0 <- pointer to a zero terminated buffer
142466:	MOV	#006,R4		; number of digits
142472:	CALL	100032		; convert the word in r1 to octal ASCII
142476:	TRAP	066		; print a string pointed to by r0
142500:	TRAP	002		; print CR, LF
142502:	MOV	R3,R1
142504:	BR	142276

; command @
; syntax @x where x is a digit in range 0-3
142506:	TST	@#164036
142512:	BMI	142654		; error 51 - expansion block not ready
142514:	BIT	#002,@#164036
142522:	BNE	142654		; error 51 - expansion block not ready
142524:	MOV	#020000,@#164200	; switch the memory banks, MK-92 ROM enabled
142532:	MOV	#004,R3		; number of ROM pages in the MK-92
142536:	CLR	R0
142540:	TRAP	072		; get a character other than space to r2
142542:	TRAP	070		; is r2 a digit?
142544:	BNE	142572		; branch if r2 is not a decimal digit
; select the specified MK-92 ROM page
142546:	BIC	#177774,R2
142552:	ASH	#013,R2
142556:	MOV	R2,R0
142560:	BIS	R2,@#164200
142564:	MOV	#001,R3		; don't try with the next ROM page
142570:	BR	142574
142572:	DEC	R1
; find the MK-92 ROM page which contains valid data
142574:	CMP	#CBB,@#040000
142602:	BNE	142620		; invalid data, try the next ROM page
142604:	CMP	R0,@#040014
142610:	BNE	142620		; invalid data, try the next ROM page
142612:	CALL	040032
142616:	BHIS	142644

; select the next ROM page in the MK-92
142620:	ADD	#800,@#164200
142626:	ADD	#800,R0
142632:	SOB	R3,142574
142634:	MOV	#060000,@#164200
142642:	TRAP	003		; error 1 - unknown operator

142644:	BIS	#040040,@#164200
142652:	JMP	(R2)

142654:	TRAP	147		; error 51 - expansion block not ready

; unidentified interrupt service routine (vector FC)
142656:	MOV	R5,-(SP)
142660:	MOV	R4,-(SP)
142662:	MOV	R3,-(SP)
142664:	MOV	R1,-(SP)
142666:	MOV	R0,-(SP)
142670:	MOV	@#164200,R1
142674:	MOV	#020000,@#164200	; switch the memory banks, MK-92 ROM enabled
142702:	MOV	#040016,R4
142706:	TST	007502
142712:	BLE	142720
142714:	MOV	#040020,R4
142720:	BIT	#002,@#164036
142726:	BNE	142762
142730:	MOV	#004,R3		; number of ROM pages in the MK-92
; find the MK-92 ROM page which contains valid data
142734:	CLR	R0
142736:	CMP	#CBB,@#040000
142744:	BNE	143016		; invalid data, try the next ROM page
142746:	CMP	R0,@#040014
142752:	BNE	143016		; invalid data, try the next ROM page
142754:	TST	(R4)
142756:	BLE	143016		; invalid data, try the next ROM page
142760:	CALL	@(R4)+
142762:	MOV	R1,@#164200
142766:	CLR	007502
142772:	CLR	006606
142776:	CLR	007430		; clear the flag of a pressed key
143002:	MOV	(SP)+,R0
143004:	MOV	(SP)+,R1
143006:	MOV	(SP)+,R3
143010:	MOV	(SP)+,R4
143012:	MOV	(SP)+,R5
143014:	RTI

; select the next ROM page in the MK-92
143016:	ADD	#004000,@#164200
143024:	ADD	#004000,R0
143030:	SOB	R3,142736
143032:	BR	142762

; command TIME
; format example (hours:minutes:seconds): 15:45:30
143034:	CALL	120114		; save registers on the stack
143040:	TRAP	072		; get a character other than space to r2
143042:	DEC	R1
143044:	MOV	#003,R4		; number of items
143050:	MOV	#143354,R5	; parameter boundaries table
143054:	MOV	#006566,R3	; scratch buffer
143060:	MOV	@#165026,007202	; save the RTC register B
143066:	CMPB	R2,#012		; end of line?
143072:	BNE	143100		; branch if parameters present
143074:	JMP	143210		; jump if no parameters
; command with parameters - set time
; copy the parameters to the buffer 0D76..0D7B
143100:	TRAP	010		; ATOI
143102:	CMPB	(R5)+,R0	; test the lower limit
143104:	BGT	143174
143106:	CMPB	(R5)+,R0	; test the upper limit
143110:	BLT	143174
143112:	TRAP	072		; get a character other than space to r2
143114:	CMPB	R2,#072		; data should be followed by a colon...
143120:	BEQ	143130
143122:	CMPB	R4,#001		; ...except of seconds
143126:	BNE	143174
143130:	ASL	R0
143132:	MOV	R0,(R3)+
143134:	SOB	R4,143100	; next data
; copy the contents of the buffer 0D76..0D7B to the RTC registers
143136:	MOV	#003,R4
143142:	MOV	#006566,R3
143146:	MOV	#165010,R5
143152:	BIS	#000400,@#165026	; RTC register B, enable Periodic Interrupts
143160:	MOV	(R3)+,(R5)
143162:	CMPB	R4,#001		; last data?
143166:	BEQ	143320
143170:	CMP	-(R5),-(R5)	; r5 <- r5 - 2
143172:	SOB	R4,143160	; next data
; invalid parameters
143174:	MOV	007202,@#165026	; restore the RTC register B
143202:	CALL	120140		; restore registers from the stack
143206:	TRAP	075		; error 30 - wrong parameters
; command without parameters - display time
143210:	MOV	#003,R4		; number of items
143214:	CALL	142070		; r0 <- pointer to a zero terminated buffer
143220:	MOV	#165000,R5
143224:	BIT	#000400,007202	; Periodic Interrupts enabled?
143232:	BNE	143344		; exit if yes, RTC missing
; read the RTC registers and convert the contents to decimal ASCII
143234:	MOV	(R5),R3
143236:	BIC	#177400,R3
143242:	ASR	R3
143244:	CALL	142100		; convert word r3 to decimal ASCII
143250:	CMP	#002,007206	; two digits?
143256:	BEQ	143264		; skip if yes
143260:	MOVB	#060,-(R0)	; add a leading zero
143264:	CMP	#001,R4		; last data?
143270:	BEQ	143304
143272:	MOVB	#072,-(R0)	; ':'
143276:	CMP	(R5)+,(R5)+	; r5 <- r5 + 4
143300:	MOV	(R5),R3
143302:	SOB	R4,143234	; next data
143304:	TRAP	066		; print a string pointed to by r0
143306:	TRAP	002		; print CR, LF
143310:	MOV	007202,@#165026	; restore the RTC register B
143316:	BR	143344
; write completed
143320:	BIT	#000400,007202	; Periodic Interrupts disabled?
143326:	BEQ	143310		; exit if not, RTC missing
143330:	MOV	#000127,@#165024	; RTC register A,
				; DV=010 (OSC1=32768Hz), RS=1011 (SQW=32Hz)
143336:	MOV	#000016,@#165026	; RTC register B, binary format, 24h mode
;
143344:	CALL	120140		; restore registers from the stack
143350:	JMP	103332

; parameter boundaries - lower and upper limits
143354:	.BYTE	000, 027	; hours 0..23
143356:	.BYTE	000, 073	; minutes 0..59
063360:	.BYTE	000, 073	; seconds 0..59

; command DATE
; format example: 25-SEP-90 SUN
143362:	CALL	120114		; save registers on the stack
143366:	TRAP	072		; get a character other than space to r2
143370:	DEC	R1
143372:	CLR	007210		; counter of data
143376:	CLR	007206
143402:	MOV	#144435,R5	; parameter boundaries table
143406:	MOV	#D76,R3		; scratch buffer
143412:	MOV	@#165026,007202	; save the EA16 register
143420:	CMPB	R2,#012		; end of line?
143424:	BNE	143432		; branch if parameters present
143426:	JMP	144042		; jump if no parameters
; command with parameters - set date
143432:	BIS	#100,@#165026
; day or year (numerical entry expected)
143440:	TRAP	010		; ATOI
143442:	CMPB	(R5)+,R0	; test the lower limit
143444:	BGT	143770
143446:	CMPB	(R5)+,R0	; test the upper limit
143450:	BLT	143770
143452:	MOV	#165016,R5
143456:	CMP	#002,007210	; year? (data #2)
143464:	BNE	143474
143466:	MOV	#165022,R5
143472:	BR	143504
143474:	TRAP	072		; get a character other than space to r2
143476:	CMPB	R2,#055		; '-'
143502:	BNE	143770
143504:	ASL	R0
143506:	MOV	R0,(R3)
143510:	MOV	(R3)+,(R5)+
143512:	CMP	#001,007210	; month?
143520:	BEQ	143744		; prepare for the year
143522:	CMP	#003,007210	; day of the week?
143530:	BEQ	144004		; end of data
143532:	CMP	#002,007210	; year?
143540:	BEQ	143760		; prepare for the day of the week
; 0E88 = #0, prepare for the month
143542:	MOV	#144342,R4	; table of month names
; month or day of the week (alpha entry expected)
143546:	CLR	R0
143550:	MOV	#002,R5
143554:	CMP	#012,R0
143560:	BLT	143770
143562:	CMP	#002,007210
143570:	BNE	143600
143572:	CMP	#007,R0
143576:	BLT	143770
143600:	TRAP	072		; get a character other than space to r2
143602:	TRAP	070		; is r2 a digit?
143604:	BNE	143610		; branch if r2 is not a decimal digit
143606:	BR	143770		; digits not allowed
143610:	INC	R0
143612:	CMPB	(R4),R2
143614:	BEQ	143624
143616:	ADD	#003,R4
143622:	BR	143610
143624:	TRAP	072		; get a character other than space to r2
143626:	TRAP	070		; is r2 a digit?
143630:	BNE	143634		; branch if r2 is not a decimal digit
143632:	BR	143770		; digits not allowed
143634:	TSTB	(R4)+
143636:	CMPB	(R4),R2
143640:	BNE	143652
143642:	CMP	#001,R5
143646:	BEQ	143704
143650:	SOB	R5,143624
143652:	CMPB	#001,R5
143656:	BNE	143670
143660:	INC	R4
143662:	SUB	#003,R1
143666:	BR	143550
143670:	ADD	#002,R4
143674:	SUB	#002,R1
143700:	JMP	143550
143704:	CMP	#002,007210
143712:	BEQ	143730
; month
143714:	MOV	#165020,R5	; write month register
143720:	INC	007210
143724:	JMP	143474
; day of the week
143730:	INC	007210
143734:	MOV	#165014,R5	; write day of the week register
143740:	JMP	143504
; prepare for the year
143744:	INC	007210		; 0E88 <- #2
143750:	MOV	#144437,R5	; table of year boundaries
143754:	JMP	143440
; prepare for the day of the week
143760:	MOV	#144407,R4	; table of day of the week names
143764:	JMP	143546
; invalid data
143770:	MOV	007202,@#165026
143776:	CALL	120140		; restore registers from the stack
144002:	TRAP	075		; error 30 - wrong parameters
; write completed
144004:	BIT	#100,007202
144012:	BEQ	144032
144014:	MOV	#127,@#165024
144022:	MOV	#016,@#165026
144030:	BR	144332
144032:	MOV	007202,@#165026
144040:	BR	144332
; command without parameters - display date
144042:	MOV	#004,007210	; number of items
144050:	BIT	#000400,007202
144056:	BNE	144332
144060:	CALL	142070		; r0 <- pointer to a zero terminated buffer
144064:	MOV	R0,007200
144070:	SUB	#004,R0
144074:	MOV	#165022,R5
144100:	MOV	(R5),R3
144102:	BIC	#177400,R3
144106:	ASR	R3
144110:	CMP	#003,007210
144116:	BEQ	144174		; month
144120:	CMP	#001,007210
144126:	BEQ	144224		; day of the week
144130:	CALL	142100		; convert word r3 to decimal ASCII
144134:	CMP	#002,007206	; two digits?
144142:	BEQ	144150
144144:	MOVB	#060,-(R0)
144150:	CMP	#002,007210
144156:	BEQ	144164
144160:	MOVB	#055,-(R0)	; '-'
144164:	TST	-(R5)
144166:	DEC	007210
144172:	BR	144100
; month
144174:	MOV	#144342,R4	; table of month names
144200:	CMPB	#014,R3
144204:	BLT	143770		; branch if month > 12
144206:	CMPB	#001,R3
144212:	BGT	143770		; branch if month < 1
144214:	MUL	#003,R3
144220:	ADD	R3,R4
144222:	BR	144254
; day of the week
144224:	MOV	#144407,R4	; table of day of the week names
144230:	MOV	R0,R5
144232:	MOV	007200,R0
144236:	CMPB	#007,R3
144242:	BLT	144316		; branch if day > 7
144244:	CMPB	#001,R3
144250:	BGT	144316		; branch if day < 1
144252:	BR	144214
144254:	MOV	#003,R2
144260:	MOVB	-(R4),-(R0)
144262:	SOB	R2,144260
144264:	CMP	#001,007210
144272:	BNE	144160
144274:	MOVB	#040,-(R0)
144300:	MOV	R5,R0
144302:	TRAP	066		; print a string pointed to by r0
144304:	TRAP	002		; print CR, LF
144306:	MOV	007202,@#165026
144314:	BR	144332
144316:	MOV	007202,@#165026
144324:	CALL	120140		; restore registers from the stack
144330:	TRAP	075		; error 30 - wrong parameters
144332:	CALL	120140		; restore registers from the stack
144336:	JMP	103332

144342:	.ASCIZ	"JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"
144407:	.ASCIZ	"MONTUEWENTHUFRISATSUN"

; parameter boundaries - lower and upper limits
144435:	.BYTE	001, 037	; day 1..31
144437:	.BYTE	131, 143	; year 89..99
144441:	.EVEN

; command CALL
144442:	TRAP	072		; get a character other than space to r2
144444:	CMPB	R2,#043
144450:	BNE	144462
144452:	CALL	170676		; get an octal number to r0
144456:	DEC	R1
144460:	BR	144470
144462:	DEC	R1
144464:	TRAP	136		; evaluate an arithmetical expression
144466:	TRAP	040		; FIX
144470:	MOV	R0,-(SP)
144472:	TRAP	072		; get a character other than space to r2
144474:	CMPB	R2,#054
144500:	BEQ	144506
144502:	DEC	R1
144504:	BR	144530
144506:	TRAP	126		; get a variable name to r4
144510:	BVS	144540		; branch if name not found
144512:	DEC	R1
144514:	CLR	R0
144516:	TRAP	134		; r3 = pointer to the variable table
144520:	BEQ	144540
144522:	TRAP	114
144524:	BEQ	144540
144526:	CMP	(R3)+,(R3)+
144530:	CALL	@(SP)+
144532:	TRAP	110
144534:	JMP	103144
144540:	TRAP	075		; error 30 - wrong parameters

; data initialising RAM in address range 0C38..0D41
144542:	      0F 00  0F 00 07 00  05 00 23 00  5C FA 76 FB
144560:	CE F9 5C FA  07 00 05 00  01 00 08 00  01 00 01 00
144600:	01 00 01 00  01 00 01 00  00 00 01 00  02 00 04 00
144620:	00 02 20 20  20 20 20 20  00 00 20 20  20 20 00 00  ..      ..    ..
144640:	00 08 0E 73  62 6F 6A 20  70 6F 20 61  64 72 20 20  ...sboj po adr  
144660:	20 20 20 20  20 0F 00 0E  6F 7B 20 20  20 20 20 20       ...o{      
144700:	20 20 73 74  72 20 0F 00  0E 6F 73 74  20 70 6F 20    str ...ost po 
144720:	61 64 72 65  73 75 20 30  30 30 30 30  30 0F 00 0E  adresu 000000...
144740:	64 77 20 6F  7B 20 6B 61  6E 61 6C 61  20 20 30 30  dw o{ kanala  00
144760:	30 30 30 30  0F 00 0E 6F  7B 20 77 65  6B 20 70 72  0000...o{ wek pr
145000:	65 72 79 77  20 30 30 30  30 30 30 0F  00 0E 0D 0A  eryw 000000.....
145020:	6F 7B 20 20  20 20 0F 20  53 20 20 20  20 52 20 20  o{    . S    R  
145040:	20 00 47 17  03 01 01 00  01 00 F0 0E  00 02 C0 05   .G.......p...@.
145060:	00 00 44 0F  00 00 00 00  00 00 00 00  4A 0F 40 00  ..D.........J.@.
145100:	78 00 00 1E  20 00 70 00  01 00 02 00  00 00 18 00  x... .p.........
145120:	00 00 01 00  FE 0D 00 01  68 01 24 00  8C 01 1C 00  ....~...h.$.....
145140:	01 00 01 00  01 00 7F 00  04 00 09 00

; RAM initialisation
145154:	MOV	#200,R0
145160:	MOV	#017400,R1
145164:	CLR	(R0)+
145166:	SOB	R1,145164
145170:	MOV	#144542,R0
145174:	MOV	#205,R1
145200:	MOV	#C38,R2
145204:	MOV	(R0)+,(R2)+
145206:	SOB	R1,145204
145210:	RETURN

; command PATCH
145212:	CALL	120114		; save registers on the stack
145216:	MOV	@#004,-(SP)
145222:	MOV	#145232,@#004
145230:	BR	145242

145232:	BIS	#001,000002(SP)
145240:	RTI

145242:	CLR	007226
145246:	CALL	145430
145252:	CLR	R3
145254:	CLR	R4
145256:	CALL	137472		; wait for a key
145262:	CMP	#060,R2
145266:	BHI	145320
145270:	CMP	#067,R2
145274:	BLO	145320
145276:	TRAP	000		; print character r2
145300:	BIC	#177770,R2
145304:	ASL	R4
145306:	ASL	R4
145310:	ASL	R4
145312:	ADD	R2,R4
145314:	INC	R3
145316:	BR	145256
145320:	CLR	R0
145322:	CMPB	R2,145372(R0)
145326:	BEQ	145342
145330:	INC	R0
145332:	CMP	R0,#010
145336:	BHIS	145402
145340:	BR	145322
145342:	TRAP	000		; print character r2
145344:	ASL	R0
145346:	JMP	@145352(R0)

145352:	.WORD	145502, 145574, 145702, 145602
145362:	.WORD	145742, 145754, 146016, 145724

145372:	.BYTE	'/', 0D, 1C, 1D
145376:	.BYTE	'@', '\', 'G', 'E'

145402:	CMP	#040,R2
145406:	BHI	145420
145410:	CMP	#177,R2
145414:	BEQ	145420
145416:	TRAP	000		; print character r2
145420:	MOV	#077,R2
145424:	TRAP	000		; print character r2
145426:	BR	145242
145430:	CALL	145444
145434:	MOV	#052,R2
145440:	TRAP	000		; print character r2
145442:	BR	145446
145444:	TRAP	002		; print CR, LF
145446:	RETURN
145450:	TST	R3
145452:	BEQ	145446
145454:	MOV	007224,R0
145460:	CLC
145462:	CMP	#001,007226
145470:	BNE	145476
145472:	MOVB	R4,(R0)
145474:	BR	145446
145476:	MOV	R4,(R0)
145500:	BR	145446
145502:	MOV	#002,007226
145510:	TST	R3
145512:	BEQ	145520
145514:	MOV	R4,007224
145520:	MOV	007224,R4
145524:	ASR	R4
145526:	BLO	145420
145530:	MOV	007224,R0
145534:	CLC
145536:	MOV	(R0),R1
145540:	BLO	145420
145542:	MOV	(R0),R5
145544:	MOV	#006,R4		; number of digits
145550:	MOV	#EF2,R0		; buffer for the octal number 0EEB-0EF0
145554:	CLRB	-(R0)
145556:	CALL	100032		; convert the word in r1 to octal ASCII
145562:	TRAP	066		; print a string pointed to by r0
145564:	MOV	#040,R2
145570:	TRAP	000		; print character r2
145572:	BR	145252
145574:	CALL	145450
145600:	BR	145242
145602:	TST	007226
145606:	BEQ	145420
145610:	CALL	145450
145614:	ADD	007226,007224
145622:	MOV	007224,R1
145626:	CALL	145444
145632:	MOV	#EF2,R0		; buffer for the octal number 0EEB-0EF0
145636:	CLRB	-(R0)
145640:	MOV	#006,R4		; number of digits
145644:	CALL	100032		; convert the word in r1 to octal ASCII
145650:	TRAP	066		; print a string pointed to by r0
145652:	CMP	#002,007226
145660:	BEQ	145672
145662:	MOV	#134,R2
145666:	TRAP	000		; print character r2
145670:	BR	145772
145672:	MOV	#057,R2
145676:	TRAP	000		; print character r2
145700:	BR	145520
145702:	TST	007226
145706:	BEQ	145420
145710:	CALL	145450
145714:	SUB	007226,007224
145722:	BR	145622
145724:	MOV	(SP)+,@#004
145730:	CALL	120140		; restore registers from the stack
145734:	TRAP	002		; print CR, LF
145736:	JMP	103332
145742:	CALL	145450
145746:	MOV	R5,007224
145752:	BR	145622
145754:	MOV	#001,007226
145762:	TST	R3
145764:	BEQ	145772
145766:	MOV	R4,007224
145772:	MOV	007224,R0
145776:	CLC
146000:	MOVB	(R0),R1
146002:	BIC	#177400,R1
146006:	BLO	145420
146010:	MOV	#003,R4
146014:	BR	145550
146016:	TST	R3
146020:	BEQ	145706
146022:	MOV	R4,007224
146026:	ASR	R4
146030:	BLO	145526
146032:	JMP	@007224

; command RENUM
146036:	CALL	120114		; save registers on the stack
146042:	MOV	R5,-(SP)
146044:	CLR	R3
146046:	MOV	#D76,R4
146052:	CALL	125572		; evaluate arithm. expression to integer in R0
146056:	BLO	146132
146060:	TST	R0
146062:	BNE	146072
146064:	MOV	#012,(R4)+
146070:	BR	146074
146072:	MOV	R0,(R4)+
146074:	CALL	125572		; evaluate arithm. expression to integer in R0
146100:	BLO	146132
146102:	TST	R0
146104:	BNE	146122
146106:	MOV	R1,-(SP)
146110:	CALL	147156
146114:	MOV	(SP)+,R1
146116:	MOV	R0,(R4)+
146120:	BR	146124
146122:	MOV	R0,(R4)+
146124:	CALL	125572		; evaluate arithm. expression to integer in R0
146130:	BHIS	146142
146132:	TST	(SP)+
146134:	CALL	120140		; restore registers from the stack
146140:	TRAP	075		; error 30 - wrong parameters
146142:	TST	R0
146144:	BNE	146154
146146:	MOV	#012,(R4)
146152:	BR	146156
146154:	MOV	R0,(R4)
146156:	MOV	007362,R1
146162:	CALL	147156
146166:	MOV	#D76,R4
146172:	CMP	R0,000002(R4)
146176:	BEQ	146226
146200:	TRAP	102		; move the pointer r1 to the end of the line
146202:	CMP	R1,(SP)
146204:	BNE	146216
146206:	TST	(SP)+
146210:	CALL	120140		; restore registers from the stack
146214:	TRAP	103		; error 33 - illegal use of the RENUM operator
146216:	MOV	R1,007162
146222:	TRAP	010		; ATOI
146224:	BR	146166
146226:	MOV	007162,-(SP)
146232:	MOV	R0,-(SP)
146234:	TRAP	072		; get a character other than space to r2
146236:	CMPB	R2,#072
146242:	BEQ	146234
146244:	CMPB	R2,#012
146250:	BNE	146264
146252:	CMP	R1,000004(SP)
146256:	BNE	146234
146260:	JMP	146730
146264:	TSTB	R2
146266:	BPL	146234
146270:	CMPB	R2,#215
146274:	BEQ	146332
146276:	CMPB	R2,#213
146302:	BEQ	146410
146304:	CMPB	R2,#214
146310:	BEQ	146410
146312:	CMPB	R2,#262
146316:	BNE	146234
146320:	TRAP	072		; get a character other than space to r2
146322:	TRAP	070		; is r2 a digit?
146324:	BNE	146320		; branch if r2 is not a decimal digit
146326:	DEC	R1
146330:	BR	146410
146332:	TRAP	072		; get a character other than space to r2
146334:	CMPB	R2,#107
146340:	BEQ	146350
146342:	CMPB	R2,#124
146346:	BNE	146332
146350:	DEC	R1
146352:	TRAP	140		; get a pair of characters to r4
146354:	CMP	R4,#043517	; "GO"
146360:	BEQ	146404
146362:	CMP	R4,#052110	; "TH"
146366:	BNE	146332
146370:	TRAP	140		; get a pair of characters to r4
146372:	TRAP	072		; get a character other than space to r2
146374:	TRAP	070		; is r2 a digit?
146376:	BNE	146264		; branch if r2 is not a decimal digit
146400:	DEC	R1
146402:	BR	146410
146404:	TRAP	140		; get a pair of characters to r4
146406:	BR	146410
146410:	TRAP	072		; get a character other than space to r2
146412:	DEC	R1
146414:	MOV	R1,007224
146420:	CLR	007230
146424:	CMPB	-(R1),#012
146430:	BNE	146424
146432:	INC	R1
146434:	TRAP	010		; ATOI
146436:	MOV	R0,-(SP)
146440:	MOV	007224,R1
146444:	TRAP	072		; get a character other than space to r2
146446:	TRAP	070		; is r2 a digit?
146450:	BEQ	146472		; branch if r2 is a decimal digit
146452:	CMPB	R2,#072
146456:	BEQ	146500
146460:	CMPB	R2,#012
146464:	BEQ	146500
146466:	TST	(SP)+
146470:	BR	146234
146472:	CALL	147174
146476:	BR	146444
146500:	MOV	007224,R1
146504:	TRAP	010		; ATOI
146506:	MOV	R0,R3
146510:	CALL	147156
146514:	CMP	R0,R3
146516:	BEQ	146570
146520:	TRAP	102		; move the pointer r1 to the end of the line
146522:	CMP	R1,000006(SP)
146526:	BEQ	146534
146530:	TRAP	010		; ATOI
146532:	BR	146514
146534:	MOV	000002(SP),R2
146540:	MOV	000004(SP),R1
146544:	CLR	007226
146550:	INC	007226
146554:	CMP	R2,(SP)
146556:	BEQ	147102
146560:	TRAP	102		; move the pointer r1 to the end of the line
146562:	TRAP	010		; ATOI
146564:	MOV	R0,R2
146566:	BR	146550
146570:	MOV	000002(SP),R2
146574:	MOV	000004(SP),R1
146600:	CLR	007226
146604:	INC	007226
146610:	CMP	R2,R3
146612:	BEQ	146644
146614:	TRAP	102		; move the pointer r1 to the end of the line
146616:	CMP	R1,000006(SP)
146622:	BNE	146636
146624:	TST	(SP)+
146626:	MOV	007232,R1
146632:	JMP	146234
146636:	TRAP	010		; ATOI
146640:	MOV	R0,R2
146642:	BR	146604
146644:	TST	(SP)+
146646:	CALL	147206
146652:	CMP	007230,R5
146656:	BEQ	146674
146660:	SUB	007230,R5
146664:	TST	R5
146666:	BMI	146722
146670:	CALL	147320
146674:	MOVB	(R4)+,@007224
146700:	TSTB	(R4)
146702:	BEQ	146712
146704:	INC	007224
146710:	BR	146674
146712:	MOV	007232,R1
146716:	JMP	146234
146722:	CALL	147252
146726:	BR	146674
146730:	MOV	000002(SP),007224
146736:	MOV	000002(SP),R1
146742:	CLR	007226
146746:	CLR	007230
146752:	TRAP	072		; get a character other than space to r2
146754:	TRAP	070		; is r2 a digit?
146756:	BNE	146766		; branch if r2 is not a decimal digit
146760:	CALL	147174
146764:	BR	146752
146766:	INC	007226
146772:	CALL	147206
146776:	CMP	007230,R5
147002:	BEQ	147026
147004:	SUB	007230,R5
147010:	TST	R5
147012:	BMI	147022
147014:	CALL	147320
147020:	BR	147026
147022:	CALL	147252
147026:	MOVB	(R4)+,@007224
147032:	TSTB	(R4)
147034:	BEQ	147044
147036:	INC	007224
147042:	BR	147026
147044:	MOV	007232,R1
147050:	CMPB	(R1)+,#012
147054:	BNE	147050
147056:	CMP	R1,000004(SP)
147062:	BNE	147074
147064:	MOV	R1,006546
147070:	JMP	147374
147074:	MOV	R1,007224
147100:	BR	146746
147102:	TST	(SP)+
147104:	MOV	#147420,R0	; string 'nedopustimaja ssylka' (bad link)
147110:	TRAP	066		; print a string pointed to by r0
147112:	TRAP	002		; print CR, LF
147114:	CALL	142070		; r0 <- pointer to a zero terminated buffer
147120:	CALL	142100		; convert word r3 to decimal ASCII
147124:	TRAP	066		; print a string pointed to by r0
147126:	MOV	#055,R2
147132:	TRAP	000		; print character r2
147134:	CALL	147206
147140:	TRAP	066		; print a string pointed to by r0
147142:	TRAP	002		; print CR, LF
147144:	MOV	007224,R1
147150:	TRAP	010		; ATOI
147152:	JMP	146234
147156:	MOV	007362,R1
147162:	INC	R1
147164:	MOV	R1,007162
147170:	TRAP	010		; ATOI
147172:	RETURN
147174:	MOV	R1,007232
147200:	INC	007230
147204:	RETURN
147206:	MOV	#D76,R5
147212:	MOV	(R5)+,R2
147214:	MOV	000002(R5),R3
147220:	MOV	007226,R4
147224:	DEC	R4
147226:	MUL	R4,R3
147230:	ADD	R2,R3
147232:	CALL	142070		; r0 <- pointer to a zero terminated buffer
147236:	CALL	142100		; convert word r3 to decimal ASCII
147242:	MOV	007206,R5	; number of digits
147246:	MOV	R0,R4
147250:	RETURN
147252:	MOV	007232,R0
147256:	ADD	R5,007232
147262:	MOV	007232,R2
147266:	MOV	R2,R3
147270:	MOVB	(R0)+,(R2)+
147272:	CMP	R0,000006(SP)
147276:	BNE	147270
147300:	MOV	R2,000006(SP)
147304:	CLRB	(R2)+
147306:	CMP	R2,R0
147310:	BNE	147304
147312:	MOV	R3,007232
147316:	RETURN
147320:	MOV	000006(SP),R0
147324:	ADD	R5,000006(SP)
147330:	MOV	000006(SP),R2
147334:	CMP	SP,R2
147336:	BLE	147360
147340:	MOVB	(R0),(R2)
147342:	MOVB	-(R0),-(R2)
147344:	CMP	R0,007232
147350:	BNE	147342
147352:	MOV	R2,007232
147356:	RETURN
147360:	CMP	(SP)+,(SP)+
147362:	TST	(SP)+
147364:	MOV	(SP)+,R5
147366:	CALL	120140		; restore registers from the stack
147372:	TRAP	001		; error 0 - out of memory
147374:	CMP	(SP)+,(SP)+
147376:	TST	(SP)+
147400:	CALL	120140		; restore registers from the stack
147404:	MOV	006546,R5
147410:	CLR	007366
147414:	JMP	103332

147420:	0E 4E 45 44  4F 50 55 53  54 49 4D 41  51 20 53 53  .NEDOPUSTIMAQ SS
147440:	59 4C 4B 41  0F 0D 0A 00  E6 10 26 11  C3 15 03 00  YLKA....f.&.C...

; command PAINT
147450:	MOV	R3,-(SP)
147452:	MOV	R4,-(SP)
147454:	MOV	#003,R3		; number of arguments
147460:	MOV	#006570,R4
147464:	CALL	125572		; evaluate arithm. expression to integer in R0
147470:	BHIS	147500
147472:	MOV	(SP)+,R4
147474:	MOV	(SP)+,R3
147476:	TRAP	075		; error 30 - wrong parameters
147500:	MOV	R0,(R4)+
147502:	SOB	R3,147464
147504:	MOV	-(R4),007210
147510:	MOV	-(R4),006120
147514:	MOV	-(R4),006506
147520:	MOV	(SP)+,R4
147522:	MOV	(SP)+,R3
147524:	MOV	R5,006712
147530:	MOV	R1,006716
147534:	CALL	147560
147540:	TRAP	110
147542:	TST	007400
147546:	BEQ	147554
147550:	JMP	103276
147554:	JMP	103144
147560:	MOV	SP,006706
147564:	CALL	120114		; save registers on the stack
147570:	MOV	007210,R1
147574:	ASL	R1
147576:	ASL	R1
147600:	ASL	R1
147602:	MOV	#172042,007204
147610:	ADD	R1,007204
147614:	CLR	R2
147616:	MOV	006426,R3
147622:	MUL	006424,R3
147626:	DIV	#020,R2
147632:	MOV	006404,R1
147636:	CLR	(R1)+
147640:	SOB	R2,147636
147642:	MOV	006506,R4
147646:	MOV	006120,R0
147652:	MOV	006126,-(SP)
147656:	MOV	#100000,-(SP)
147662:	CALL	150654
147666:	BVC	147700
147670:	CMP	#007,R2
147674:	BVS	150010
147676:	BR	147706
147700:	CALL	150654
147704:	BVC	147700
147706:	MOV	R4,-(SP)
147710:	MOV	R0,-(SP)
147712:	TST	(SP)
147714:	BMI	150010
147716:	CALL	150270
147722:	CMP	#140000,(SP)
147726:	BEQ	150010
147730:	TST	R0
147732:	BGT	147744
147734:	INC	R0
147736:	CALL	150024
147742:	BR	147712
147744:	CMP	#077,R0
147750:	BGT	147762
147752:	DEC	R0
147754:	CALL	150024
147760:	BR	147712
147762:	MOV	R0,006546
147766:	DEC	R0
147770:	CALL	150024
147774:	MOV	006546,R0
150000:	INC	R0
150002:	CALL	150024
150006:	BR	147712
150010:	TST	(SP)+
150012:	MOV	(SP)+,006126
150016:	CALL	120140		; restore registers from the stack
150022:	RETURN
150024:	MOV	(SP)+,007166
150030:	MOV	007164,R4
150034:	CALL	150600
150040:	BVS	150126
150042:	CALL	150534
150046:	BNE	150126
150050:	DEC	R4
150052:	CALL	150600
150056:	BVS	150124
150060:	CALL	150534
150064:	BNE	150124
150066:	INC	R4
150070:	INC	R4
150072:	CALL	150534
150076:	BNE	150114
150100:	CALL	150654
150104:	BVS	150110
150106:	BR	150100
150110:	MOV	R4,-(SP)
150112:	MOV	R0,-(SP)
150114:	MOV	007164,R4
150120:	DEC	R4
150122:	BR	150156
150124:	BEQ	150262
150126:	DEC	R4
150130:	BNE	150156
150132:	CALL	150600
150136:	BVS	150262
150140:	CALL	150534
150144:	BNE	150262
150146:	INC	R4
150150:	MOV	R4,-(SP)
150152:	MOV	R0,-(SP)
150154:	BR	150262
150156:	CMP	R4,007162
150162:	BLE	150262
150164:	CALL	150600
150170:	BVS	150126
150172:	CALL	150534
150176:	BNE	150126
150200:	INC	R4
150202:	CALL	150600
150206:	BVC	150214
150210:	MOV	R4,-(SP)
150212:	MOV	R0,-(SP)
150214:	DEC	R4
150216:	CMP	R4,#007
150222:	BGE	150236
150224:	SUB	#007,R4
150230:	MOV	R4,R3
150232:	CLR	R4
150234:	BR	150244
150236:	SUB	#007,R4
150242:	CLR	R3
150244:	CALL	150744
150250:	BVS	150126
150252:	CMP	R4,007162
150256:	BLE	150262
150260:	BR	150216
150262:	MOV	007166,-(SP)
150266:	RETURN
150270:	MOV	(SP)+,007166
150274:	MOV	(SP)+,R0
150276:	MOV	(SP)+,R4
150300:	MOV	R4,007164
150304:	DEC	R4
150306:	CALL	150534
150312:	BNE	150516
150314:	TST	R4
150316:	BEQ	150410
150320:	CMP	R4,#007
150324:	BGE	150340
150326:	SUB	#007,R4
150332:	MOV	R4,R3
150334:	CLR	R4
150336:	BR	150346
150340:	CLR	R3
150342:	SUB	#007,R4
150346:	CALL	150744
150352:	BVC	150320
150354:	MOV	R4,007162
150360:	MOV	007164,R4
150364:	DEC	R4
150366:	CMP	R4,007162
150372:	BNE	150410
150374:	TST	007162
150400:	BNE	150526
150402:	CALL	150600
150406:	BVS	150526
150410:	CALL	150534
150414:	BISB	R1,(R5)
150416:	MOV	R4,R3
150420:	MOV	R0,R5
150422:	BIC	#177770,R3
150426:	BIC	#177770,R5
150432:	ADD	007204,R5
150436:	CLR	R1
150440:	MOVB	(R5),R1
150442:	MOV	#007,R2
150446:	SUB	R3,R2
150450:	NEG	R3
150452:	ASH	R3,R1
150454:	NEG	R3
150456:	ASH	R3,R1
150460:	SWAB	R1
150462:	CLRB	R1
150464:	ASH	R2,R1
150466:	MOV	#003,006126
150474:	MOV	R4,006506
150500:	MOV	R0,006120
150504:	CALL	121412
150510:	TST	R4
150512:	BEQ	150526
150514:	BR	150364
150516:	TST	(SP)
150520:	BGE	150274
150522:	BIS	#040000,(SP)
150526:	MOV	007166,-(SP)
150532:	RETURN
150534:	CLR	R2
150536:	MOV	R0,R5
150540:	MOV	R4,R3
150542:	DIV	#010,R2
150546:	MUL	006426,R5
150552:	ASR	R5
150554:	ASR	R5
150556:	ASR	R5
150560:	ADD	R2,R5
150562:	MOV	#001,R1
150566:	ASH	R3,R1
150570:	ADD	006404,R5
150574:	BITB	R1,(R5)
150576:	RETURN
150600:	CMP	#167,R4
150604:	BLT	150646
150606:	TST	R4
150610:	BMI	150646
150612:	MOV	#004,006126
150620:	CLR	R1
150622:	MOV	R4,006506
150626:	MOV	R0,006120
150632:	CALL	121412
150636:	TST	R1
150640:	BMI	150646
150642:	CLEAR	V
150644:	RETURN
150646:	CLC
150650:	SET	V
150652:	BR	150644
150654:	MOV	R4,006506
150660:	MOV	R0,006120
150664:	CMP	#167,R4
150670:	BLT	150736
150672:	CLR	R1
150674:	MOV	#007,R2
150700:	MOV	#004,006126
150706:	CALL	121412
150712:	CMP	#167,R4
150716:	BLT	150736
150720:	ASL	R1
150722:	BLO	150736
150724:	INC	R4
150726:	DEC	R2
150730:	BGE	150712
150732:	CLEAR	V
150734:	RETURN
150736:	CLC
150740:	SET	V
150742:	BR	150734
150744:	MOV	R4,006506
150750:	MOV	R0,006120
150754:	CLR	R1
150756:	MOV	#007,R2
150762:	MOV	#004,006126
150770:	CALL	121412
150774:	ADD	#007,R4
151000:	SWAB	R1
151002:	TST	R3
151004:	BEQ	151014
151006:	ASH	R3,R1
151010:	NEG	R3
151012:	SUB	R3,R4
151014:	ASRB	R1
151016:	BLO	151036
151020:	TST	R4
151022:	BEQ	151036
151024:	DEC	R4
151026:	DEC	R2
151030:	BGE	151014
151032:	CLEAR	V
151034:	RETURN
151036:	CLC
151040:	SET	V
151042:	BR	151034

; command TRON
151044:	MOV	#001,007410
151052:	TRAP	110
151054:	JMP	103144

; command TROFF
151060:	CLR	007410
151064:	TRAP	110
151066:	JMP	103144

151072:	MOV	R1,-(SP)
151074:	MOV	#133,R2		; '['
151100:	TRAP	000		; print character r2
151102:	TRAP	072		; get a character other than space to r2
151104:	TRAP	070		; is r2 a digit?
151106:	BNE	151114		; branch if r2 is not a decimal digit
151110:	TRAP	000		; print character r2
151112:	BR	151102
151114:	MOV	#135,R2		; ']'
151120:	TRAP	000		; print character r2
151122:	MOV	(SP)+,R1
151124:	RETURN

; file access routine
; byte 0(R0) - ?
; byte 1(R0) - action:	0 - kill file
;			1 - read file
;			2 - write file
;			3 - rename file
;			4 - ?
; word 2(R0) - pointer to the file name(s) in the Radix-50 format
151126:	CALL	120114	; save registers on the stack
151132:	MOV	#177777,007470
151140:	MOV	#177777,007472
151146:	MOV	R0,R1
151150:	CMPB	(R1),#002
151154:	BHIS	151252
151156:	MOVB	(R1)+,007444
151162:	CMPB	(R1),#005	; action code
151166:	BHIS	151260		; invalid command
151170:	MOV	007444,R3
151174:	CALL	157430	; check the memory module
151200:	MOVB	(R1)+,R2	; action code
151202:	MOV	(R1)+,(SP)	; pointer to the file name(s)
151204:	MOV	(SP),R0
151206:	MOV	R1,007462
151212:	TST	(R1)+
151214:	MOV	R1,007464
151220:	TST	(R1)+
151222:	MOV	R1,007466
151226:	CLR	R5
151230:	ASL	R2
151232:	TST	(R2)+		; R2 <- R2 + 2
151234:	ADD	PC,R2		; 151236+000002 = 151240
151236:	ADD	(R2),PC

151240:	.WORD	000172		; 151240+000172 = 151432, kill file
151242:	.WORD	000032		; 151240+000032 = 151272, read file
151244:	.WORD	000214		; 151240+000214 = 151454, write file
151246:	.WORD	000026		; 151240+000026 = 151266, rename file
151250:	.WORD	001476		; 151240+001476 = 152736

151252:	MOV	#-1,(SP)
151256:	BR	151422

151260:	MOV	#-2,(SP)
151264:	BR	151422

; rename file
151266:	MOV	#100,R5
; read file
151272:	JSR	R5,152246
151276:	MOV	R4,007460
151302:	JSR	R5,153264
151306:	BR	151416

151310:	MOV	#010,-(SP)
151314:	TST	R5
151316:	BNE	151360
151320:	ADD	(SP)+,R1
151322:	MOV	007460,@007464
151330:	MOV	(R1),(SP)
151332:	MOV	(R1)+,@007462
151336:	MOV	000004(R1),@007466
151344:	CLR	007434
151350:	CLC
151352:	CALL	120140		; restore registers from the stack
151356:	RETURN

151360:	ADD	#006,R0
151364:	MOV	#200,(R1)+
151370:	MOV	(R0)+,(R1)+
151372:	MOV	(R0)+,(R1)+
151374:	MOV	(R0)+,(R1)+
151376:	SUB	(SP)+,R1
151400:	JMP	153026

151404:	CLR	(SP)
151406:	BR	151344

151410:	MOV	#-3,(SP)
151414:	BR	151422
151416:	MOV	#-4,(SP)
151422:	CLR	007434
151426:	SEC
151430:	BR	151352

; kill file
151432:	JSR	R5,152246
151436:	JSR	R5,153264
151442:	BR	151416

151444:	MOV	#200,(R1)
151450:	JMP	153162

; write file
151454:	CLR	007470
151460:	MOV	#200,R5
151464:	JSR	R5,152246
151470:	MOV	002704,007456
151476:	CLR	007446
151502:	CLR	007450
151506:	BR	151516
151510:	JSR	R5,152356
151514:	BR	151622
151516:	CALL	152546
151522:	MOV	R4,007460
151526:	MOV	#F26,R5
151532:	JSR	R5,152272
151536:	.WORD	001000
151540:	BR	151510
151542:	MOV	000010(R1),R0
151546:	MOV	@007462,R2
151552:	BEQ	151562
151554:	CMP	#177777,R2
151560:	BNE	151670
151562:	CMP	(R5)+,R0
151564:	BHIS	151610
151566:	CMP	(R5),R0
151570:	BHIS	151602
151572:	MOV	(R5),-(R5)
151574:	ADD	#010,R5
151600:	MOV	-(R5),-(R5)
151602:	MOV	R0,-(R5)
151604:	MOV	R3,000004(R5)
151610:	ADD	R0,007460
151614:	CALL	153206
151620:	BR	151526
151622:	TST	(R5)+
151624:	MOV	@007462,R2
151630:	BNE	151644
151632:	ROR	(R5)
151634:	CMP	(R5),-(R5)
151636:	BLO	151650
151640:	TST	(R5)+
151642:	BR	151650
151644:	INC	R2
151646:	BNE	151410
151650:	MOV	(R5),@007462
151654:	BEQ	151410
151656:	MOV	000004(R5),R3
151662:	JSR	R5,152370
151666:	.WORD	000713
151670:	CMP	R0,R2
151672:	BLO	151610
151674:	MOV	R1,-(SP)
151676:	MOV	007476,R1	; DREND
151702:	CALL	153204
151706:	CALL	153206
151712:	CMP	R1,#004700
151716:	BHI	152060
151720:	MOV	(SP)+,R1
151722:	MOV	007460,R4
151726:	MOV	R1,R5
151730:	SUB	R2,000010(R1)
151734:	SUB	#016,R5
151740:	SUB	002706,R5
151744:	CMP	R5,#5CA
151750:	BLO	152000
151752:	BIT	#100,(R5)
151756:	BEQ	152000
151760:	CALL	152320
151764:	MOV	#200,(R1)
151770:	CLR	000010(R1)
151774:	CALL	153206
152000:	CALL	152320
152004:	MOV	#100,(R1)+
152010:	MOV	(SP),R0
152012:	MOV	(R0)+,(R1)+
152014:	MOV	(R0)+,(R1)+
152016:	MOV	(R0)+,(R1)+
152020:	MOV	R2,(R1)+
152022:	CLR	(R1)+
152024:	MOV	@#054,(R1)
152030:	ADD	#262,(R1)
152034:	MOV	@000000(R1),(R1)
152040:	MOV	R2,@007462
152044:	MOV	R4,@007464
152050:	JSR	R5,152462
152054:	JMP	151344

; EXTEND:
; enlarge the size of a directory
152060:	TST	(SP)+
152062:	MOV	007456,R2
152066:	INC	007434
152072:	CMP	R2,002700
152076:	BGE	152236
152100:	MOV	#5C8,R1
152104:	MOV	R1,R4
152106:	ADD	#1FC,R4
152112:	MOV	(R1)+,R5
152114:	CALL	153176
152120:	CMP	R1,R4
152122:	BLO	152114
152124:	CLR	R4
152126:	BIT	#500,(R1)
152132:	BEQ	152114
152134:	MOV	(R1),-(SP)
152136:	MOV	#800,(R1)
152142:	INC	R2
152144:	MOV	002702,-(SP)
152150:	MOV	R2,002702
152154:	JSR	R5,152462
152160:	MOV	#5C0,R0
152164:	TST	(R0)+
152166:	MOV	(SP)+,(R0)+
152170:	MOV	(SP)+,(R1)
152172:	CMP	(R0)+,(R0)+
152174:	MOV	R5,(R0)+
152176:	MOV	(R1)+,(R0)+
152200:	CMP	R1,#004700
152204:	BLOS	152176
152206:	MOV	R2,R0
152210:	JSR	R5,152470
152214:	JSR	R5,152452
152220:	INC	002704
152224:	JSR	R5,152462
152230:	DEC	007434
152234:	BR	151662
152236:	MOV	#177773,(SP)
152242:	JMP	151422

152246:	BIS	(SP),007474
152252:	MOV	#001,R3
152256:	JSR	R5,152370
152262:	.WORD	000402
152264:	TST	(R5)+
152266:	TST	(R5)+
152270:	RTS	R5

; ENTRY:
; scan for entry of specified type in current segment
152272:	BIT	(R5),(R1)
152274:	BNE	152264
152276:	BIT	(R1),#800
152302:	BNE	152266
152304:	ADD	000010(R1),007460
152312:	CALL	153206
152316:	BR	152272

; PUSH:
; make room in current directory segment for new entry
152320:	MOV	R3,-(SP)
152322:	MOV	R1,R5
152324:	JSR	R5,152272
152330:	.WORD	000000
152332:	MOV	R1,R3
152334:	CALL	153206
152340:	CMP	(R3)+,(R1)+
152342:	MOV	-(R3),-(R1)
152344:	CMP	R3,R5
152346:	BNE	152342
152350:	MOV	R5,R1
152352:	MOV	(SP)+,R3
152354:	RETURN

152356:	MOV	002702,R0
152362:	BEQ	152450
152364:	MOV	R0,R3
152366:	TST	(R5)+
152370:	MOV	R0,-(SP)
152372:	MOV	R3,R0
152374:	BIC	#177740,R0
152400:	CMP	R0,007470
152404:	BNE	152416
152406:	CMP	007444,007472
152414:	BEQ	152432
152416:	MOV	R0,007470
152422:	MOV	R3,-(SP)
152424:	JSR	R5,152460
152430:	MOV	(SP)+,R3
152432:	MOV	007444,007472
152440:	MOV	#5C8,R1
152444:	MOV	(R1)+,R4
152446:	MOV	(SP)+,R0
152450:	RTS	R5

; SEGRD1:
; read directory segments
152452:	MOV	#001,007470
152460:	CMP	#241,PC		; instead of SEC : BR 152124
; SEGWR:
; write directory segments
; D532:	clc
152464:	MOV	007470,R0
; SEGRW:
152470:	JSR	R0,152502
152474:	.WORD	000002		; number of sectors
152476:	.WORD	002700		; USRBUF
152500:	.WORD	007444		; device number

; Carry set = read, Carry cleared = write
152502:	MOV	(R0)+,R1	; number of sectors
152504:	MOV	(R0)+,R2	; source/destination address
152506:	MOV	@(R0)+,R3	; device number
152510:	MOV	(SP)+,R0
152512:	ROL	R0
152514:	ADD	007526,R0
152520:	BIT	#001,R0		; read or write?
152524:	BEQ	152540
152526:	BIC	#001,R0
152532:	CALL	153572		; read sectors from the memory module
152536:	BR	152544
152540:	CALL	153640		; write sectors to the memory module
152544:	RTS	R5

; CONSOL:
; remove unnecessary entries from a directory
152546:	MOV	R4,-(SP)
152550:	MOV	R3,-(SP)
152552:	MOV	R1,-(SP)
152554:	MOV	#016,R4
152560:	ADD	002706,R4
152564:	JSR	R5,152272
152570:	.WORD	000400
152572:	BR	152564
152574:	MOV	#200,(R1)
152600:	ADD	R4,R1
152602:	BR	152564
152604:	MOV	(SP),R1
152606:	JSR	R5,152272
152612:	.WORD	001000
152614:	BR	152722
152616:	MOV	R1,R2
152620:	ADD	R4,R2
152622:	BIT	#200,(R2)
152626:	BEQ	152666
152630:	ADD	000010(R2),000010(R1)
152636:	MOV	R2,R5
152640:	ADD	R4,R5
152642:	MOV	R1,-(SP)
152644:	JSR	R5,152272
152650:	.WORD	000000
152652:	MOV	R1,R3
152654:	MOV	(R5)+,(R2)+
152656:	CMP	R5,R3
152660:	BLOS	152654
152662:	MOV	(SP)+,R1
152664:	BR	152606
152666:	TST	000010(R1)
152672:	BNE	152716
152674:	MOV	R1,R2
152676:	MOV	R1,R3
152700:	SUB	R4,R3
152702:	CMP	R3,#5CA
152706:	BLO	152716
152710:	BIT	#400,(R3)
152714:	BNE	152636
152716:	ADD	R4,R1
152720:	BR	152606
152722:	MOV	R1,007476
152726:	MOV	(SP)+,R1
152730:	MOV	(SP)+,R3
152732:	MOV	(SP)+,R4
152734:	RETURN

152736:	MOV	#001,R3
152742:	JSR	R5,152370
152746:	.WORD	000403
152750:	JSR	R5,152356
152754:	BR	153166
152756:	MOV	(SP),R0
152760:	JSR	R5,152272
152764:	.WORD	000400
152766:	BR	152750
152770:	TST	(R1)+
152772:	MOV	R1,R2
152774:	ADD	#006,R2
153000:	CMP	(R0)+,(R1)+
153002:	BEQ	153016
153004:	MOV	R2,R1
153006:	CMP	(R1)+,(R1)+
153010:	ADD	002706,R1
153014:	BR	152756
153016:	CMP	R1,R2
153020:	BNE	153000
153022:	SUB	#010,R1
153026:	MOV	#F26,R0
153032:	MOV	(R1)+,(R0)+
153034:	MOV	(R1)+,(R0)+
153036:	MOV	(R1)+,(R0)+
153040:	MOV	(R1),(R0)
153042:	CMP	-(R0),-(R0)
153044:	CMP	-(R1),-(R1)
153046:	MOV	R1,-(SP)
153050:	MOV	R3,-(SP)
153052:	MOV	#001,R3
153056:	JSR	R5,153264
153062:	BR	153106
153064:	MOV	#200,(R1)
153070:	MOV	R3,R1
153072:	CMP	R1,(SP)
153074:	BEQ	153106
153076:	INC	007434
153102:	CALL	153220
153106:	MOV	(SP)+,R3
153110:	JSR	R5,152370
153114:	.WORD	012601
153116:	MOV	#400,-(R1)
153122:	BIT	#100,007474
153130:	BNE	153242
153132:	ADD	#010,R1
153136:	MOV	(R1),R2
153140:	MOV	@007462,(R1)
153144:	MOV	006546,000006(R1)
153152:	SUB	(R1),R2
153154:	CALL	153206
153160:	ADD	R2,(R1)
153162:	CALL	153220
153166:	DEC	007434
153172:	JMP	151404

; INCR1A:
; move R1 past one or two directory entries
153176:	ADD	000010(R1),R5
153202:	BR	153206
; INCR2:
153204:	MOV	PC,-(SP)
; INCR1:
153206:	ADD	002706,R1
153212:	ADD	#016,R1
153216:	RETURN

; CLOSUP:
; consolidate and rewrite a directory segment
153220:	MOV	R0,-(SP)
153222:	MOV	#5CA,R1
153226:	CALL	152546
153232:	JSR	R5,152462
153236:	MOV	(SP)+,R0
153240:	RETURN

153242:	TST	(R1)+
153244:	MOV	(R0)+,(R1)+
153246:	MOV	(R0)+,(R1)+
153250:	MOV	(R0)+,(R1)+
153252:	CMP	(R1)+,(R1)+
153254:	BIC	#100,007474
153262:	BR	153162

153264:	MOV	R0,-(SP)
153266:	JSR	R5,152370
153272:	.WORD	011600
153274:	JSR	R5,152272
153300:	.WORD	002000
153302:	BR	153354
153304:	TST	(R1)+
153306:	MOV	R1,R2
153310:	ADD	#006,R2
153314:	CMP	(R0)+,(R1)+
153316:	BNE	153336
153320:	CMP	R1,R2
153322:	BNE	153314
153324:	SUB	#010,R1
153330:	TST	(R5)+
153332:	MOV	(SP)+,R0
153334:	RTS	R5
153336:	MOV	R2,R1
153340:	ADD	(R1)+,007460
153344:	CMP	(R1)+,(R1)+
153346:	ADD	002706,R1
153352:	BR	153272
153354:	JSR	R5,152356
153360:	BR	153332
153362:	BR	153272

; write to the memory module address register
; R0 points to the buffer containing the address
153364:	CALL	120114		; save registers on the stack
153370:	MOV	#003,R1		; number of address bytes
153374:	TST	007524		; memory module type
153400:	BNE	153404		; skip if a ROM module
153402:	DEC	R1		; two address bytes for a RAM module
153404:	MOV	SP,R2
153406:	CLR	R0
153410:	JSR	R5,153470
153414:	.WORD	153430		; rts pc
153416:	.WORD	000250		; Write Address
153420:	.WORD	000000
153422:	.WORD	153456		; movb @0(r2),@#164020; inc (r2)
153424:	CALL	120140		; restore registers from the stack
153430:	RETURN

153432:	TSTB	@#164024
153436:	BPL	153432
153440:	RETURN

153442:	MOVB	@#164020,(R2)+
153446:	RETURN

153450:	MOVB	(R2)+,@#164020
153454:	RETURN

153456:	MOVB	@000000(R2),@#164020
153464:	INC	(R2)
153466:	RETURN

; number of bytes in r1
; device number in r3
; the call to this procedure should be followed by:
; 1. address of the procedure called before the transfer
; 2. code to be written to the E816 register (command for the memory module)
; 3. bit mask for the E814 register (data direction)
; 4. address of the data transfer procedure
153470:	MOV	#000011,@#164022
153476:	CALL	@(R5)+		; procedure called before the transfer
153500:	TST	@#164026	; terminate the previous transfer
153504:	BIC	#177776,R3
153510:	BIS	#000370,R3
153514:	MOV	R3,@#164024
153520:	MOV	(R5)+,@#164026	; command for the SMP module
153524:	CALL	153432
153530:	BIC	(R5)+,R3
153532:	MOV	R3,@#164024
153536:	CALL	153432
153542:	CALL	@000000(R5)	; call the data transfer procedure
153546:	CALL	153432
153552:	DEC	R1
153554:	BNE	153542
153556:	TST	@#164026	; end of the transfer
153562:	TST	(R5)+
153564:	CALL	153432
153570:	RTS	R5

; read R1 sectors from the memory module starting from the sector R0
153572:	CALL	153732		; convert the sector number in R0 to an address
153576:	SWAB	R1		; convert the number of sectors to read to ...
153600:	ASL	R1		; ... the number of bytes
153602:	CALL	157430		; check the memory module
153606:	MOV	#F52,R0		; r0 = pointer to the source address bytes
153612:	TST	007524		; memory module type
153616:	BEQ	153622		; skip if a RAM module
153620:	DEC	R0		; address bytes 0F51..0F53 if a ROM module
; read a memory block from the SMP
; pointer to the buffer containing the source address in r0
; destination address in r2
; number of bytes in r1
; device number in r3
153622:	JSR	R5,153470
153626:	.WORD	153364		; write to the SMP address register
153630:	.WORD	000330		; Read Postincrement
153632:	.WORD	000010
153634:	.WORD	153442		; movb @#164020,(r2)+
153636:	BR	153702

; write R1 sectors to the memory module starting from the sector R0
153640:	CALL	153732		; convert the sector number in R0 to an address
153644:	SWAB	R1		; convert the number of sectors to write to ...
153646:	ASL	R1		; ... the number of bytes
; write a memory block to the SMP
; destination address in 0F52 (bytes in big endian order)
; source address in r2
; number of bytes in r1
; device number in r3
153650:	CALL	157430		; check the memory module
153654:	MOV	#F52,R0		; r0 = pointer to the destination address bytes
153660:	TST	007524		; memory module type
153664:	BNE	153702		; skip if a ROM module
153666:	JSR	R5,153470
153672:	.WORD	153364		; write to the SMP address register
153674:	.WORD	000310		; Write Postincrement
153676:	.WORD	000000
153700:	.WORD	153450		; movb (r2)+,@#164020
153702:	BIC	#177776,R3
153706:	BIS	#130,R3
153712:	MOV	R3,@#164024
153716:	MOV	#242,@#164024
153724:	BIC	#177776,R3
153730:	RETURN

; convert the sector number in R0 to an address in 007521..007523
153732:	CLR	007520
153736:	CLR	007522
153742:	ASL	R0
153744:	MOVB	R0,007522
153750:	SWAB	R0
153752:	MOVB	R0,007521
153756:	RETURN

; erase the SMP with spaces
153760:	CLR	007520
153764:	MOV	#177777,007522	; obligatory destination address
153772:	MOV	#007521,R0		; r0 = pointer to the destination address bytes
153776:	CLR	R1		; number of bytes (65536 decimal)
154000:	JSR	R5,153470
154004:	.WORD	153364		; write to the SMP address register
154006:	.WORD	000040		; Erase Postdecrement
154010:	.WORD	000000
154012:	.WORD	154016		; movb #20,@#164020
154014:	BR	153702

154016:	MOVB	#040,@#164020
154024:	RETURN

; fetch a file name pointed to by R1 and convert it to Radix-50
; output buffer pointed to by R0
; returns Carry set in case of illegal characters in the file name
154026:	CLR	(R0)+
154030:	CLR	(R0)+
154032:	MOV	R0,R4
154034:	CLR	(R0)
154036:	CMP	-(R0),-(R0)
154040:	MOV	#055533,R3
154044:	TRAP	072		; get a character other than space to r2
154046:	TRAP	070		; is r2 a digit?
154050:	BVS	154130
154052:	BNE	154060		; branch if r2 is not a decimal digit
154054:	ADD	#056,R2
154060:	SUB	#100,R2
154064:	ASRB	R3
154066:	BHIS	154110
154070:	ASL	R2
154072:	ASL	R2
154074:	ASL	R2
154076:	MOV	R2,-(SP)
154100:	ASL	R2
154102:	ASL	R2
154104:	ADD	(SP)+,R2
154106:	BR	154064
154110:	CMP	R0,R4
154112:	BEQ	154144
154114:	ADD	R2,(R0)
154116:	ASRB	R3
154120:	BLO	154044
154122:	TST	(R0)+
154124:	SWAB	R3
154126:	BR	154044
154130:	CMPB	R2,#056
154134:	BNE	154150
154136:	MOV	R4,R0
154140:	TST	(R4)+
154142:	BR	154040
154144:	SEC
154146:	RETURN
154150:	CLC
154152:	RETURN

154154:	MOV	R1,-(SP)
154156:	TRAP	116
154160:	TST	007366
154164:	BNE	154172
154166:	MOV	R5,007366
154172:	MOV	007366,R4
154176:	MOV	007362,R3
154202:	SUB	R3,R4
154204:	MOVB	(R3)+,R2
154206:	BMI	154252
154210:	CMP	R2,#012
154214:	BNE	154220
154216:	INC	R4
154220:	CMP	R3,007366
154224:	BLO	154204
154226:	INC	R4
154230:	ADD	#1FF,R4
154234:	CLRB	R4
154236:	SWAB	R4
154240:	ASR	R4
154242:	MOV	R4,000004(R0)
154246:	MOV	(SP)+,R1
154250:	RETURN
154252:	MOV	#104170,R1
154256:	DEC	R4
154260:	BIC	#177600,R2
154264:	BEQ	154276
154266:	CMPB	(R1)+,#044
154272:	BNE	154266
154274:	SOB	R2,154266
154276:	CMPB	(R1)+,#044
154302:	BEQ	154220
154304:	INC	R4
154306:	BR	154276

; fetch the file name optionally preceded by the device name
154310:	MOV	R0,-(SP)
154312:	TRAP	072		; get a character other than space to r2
154314:	CMPB	R2,#042		; quotation mark
154320:	BNE	154410
154322:	MOV	R1,-(SP)
154324:	TRAP	140		; get a pair of characters to r4
154326:	CMP	R4,#051515	; "SM"
154332:	BNE	154400
154334:	TRAP	010		; ATOI
154336:	MOV	R0,R4
154340:	MOV	000002(SP),R0
154344:	CMPB	(R1)+,#072	; colon
154350:	BNE	154400
154352:	MOV	R4,(R0)+
154354:	TST	(SP)+
154356:	MOV	(R0)+,R0	; R0 points to the output buffer
154360:	CALL	154026		; fetch the filename and convert it to Radix-50
154364:	BLO	154410		; branch if illegal characters in the filename
154366:	CMPB	R2,#042		; quotation mark
154372:	BNE	154410
154374:	MOV	(SP)+,R0
154376:	RETURN
154400:	MOV	(SP)+,R1
154402:	MOV	007436,(R0)+
154406:	BR	154356
154410:	TST	(SP)+
154412:	TRAP	177		; error 63 - illegal file name

; print 'vy uvereny?' (are you sure?) then wait for a key
154414:	MOV	R0,-(SP)
154416:	MOV	R1,-(SP)
154420:	MOV	R3,-(SP)
154422:	MOV	#157674,R0	; string 'vy uvereny?' (are you sure?)
154426:	TRAP	066		; print a string pointed to by r0
154430:	TRAP	100		; input a line from the keyboard
154432:	MOVB	(R1),R2		; r2 = key code
154434:	MOV	(SP)+,R3
154436:	MOV	(SP)+,R1
154440:	MOV	(SP)+,R0
154442:	RETURN

; command KILL
154444:	MOV	#006406,R0
154450:	CALL	154310		; fetch the device and file name
154454:	CALL	154414		; print 'vy uvereny?' (are you sure?)
154460:	CMPB	#131,R2		; 'Y'
154464:	BNE	154514
154466:	MOV	(R0),R3
154470:	CALL	157430		; check the memory module
154474:	TST	007524		; memory module type
154500:	BEQ	154504		; skip if a RAM module
154502:	TRAP	161		; error 56 - file write protected
154504:	CALL	151126		; file access
154510:	BHIS	154514
154512:	TRAP	175		; error 62 - file not found
154514:	TRAP	002		; print CR, LF
154516:	JMP	103332

; command LOAD
154522:	CLR	006546
154526:	MOV	#006406,R0
154532:	CALL	154310		; fetch the device and file name
154536:	CLR	007200
154542:	MOV	R3,-(SP)
154544:	MOV	R1,-(SP)
154546:	TRAP	140		; get a pair of characters to r4
154550:	CMP	R4,#026101	; ",A"
154554:	BEQ	154616
154556:	TST	007510
154562:	BNE	154572
154564:	MOV	#CAB,007510
154572:	INC	007200
154576:	CMP	R4,#026122	; ",R"
154602:	BNE	154632
154604:	INC	007200
154610:	INC	007374
154614:	MOV	R1,(SP)
154616:	TST	007510
154622:	BNE	154632
154624:	MOV	#CBB,007510
154632:	MOVB	#001,000001(R0)	; read file
154640:	CALL	151126		; file access
154644:	BLO	154512
154646:	SWAB	006412
154652:	ASL	006412
154656:	MOV	006414,R2
154662:	CLR	007520
154666:	CLR	007522
154672:	ASL	R2
154674:	MOVB	R2,007522
154700:	SWAB	R2
154702:	MOVB	R2,007521
154706:	MOV	#001,007374
154714:	TST	007200
154720:	BEQ	154740
154722:	MOV	007362,R3
154726:	CALL	155012
154732:	INC	R3
154734:	MOV	R3,R5
154736:	BR	154726
154740:	MOV	R1,(SP)
154742:	TRAP	140		; get a pair of characters to r4
154744:	CMP	R4,#026122	",R"
154750:	BNE	154760
154752:	INC	007374
154756:	MOV	R1,(SP)
154760:	MOV	(SP)+,R1
154762:	MOV	(SP)+,R3
154764:	MOV	007362,R5
154770:	INC	R5
154772:	CLR	007366
154776:	CLR	007400
155002:	CLR	007360
155006:	JMP	103144

155012:	CALL	120114		; save registers on the stack
155016:	MOV	#001,R1
155022:	MOV	R3,R2
155024:	MOV	007444,R3
155030:	CALL	153602
155034:	JSR	R5,155074
155040:	.WORD	000001
155042:	CALL	120140		; restore registers from the stack
155046:	MOVB	(R3),R2
155050:	BEQ	155132
155052:	BIC	#177400,R2
155056:	ADD	R2,006546
155062:	DEC	006412
155066:	BGT	155072
155070:	TRAP	163		; error 57 - file overflow
155072:	RETURN

155074:	MOV	007520,R1
155100:	SWAB	R1
155102:	MOV	007522,R0
155106:	SWAB	R0
155110:	ADD	(R5)+,R0
155112:	ADC	R1
155114:	SWAB	R0
155116:	MOV	R0,007522
155122:	SWAB	R1
155124:	MOV	R1,007520
155130:	RTS	R5

155132:	CMP	006546,006416
155140:	BEQ	155144
155142:	TRAP	165		; error 58 - checksum error
155144:	TST	007200
155150:	BNE	155154
155152:	TST	(SP)+
155154:	TST	(SP)+
155156:	MOV	(SP)+,R1
155160:	MOV	(SP)+,R3
155162:	MOV	#001,006374
155170:	ASR	007374
155174:	BHIS	155202
155176:	JMP	154514
155202:	CLR	007374
155206:	JMP	105252

; command NAME
155212:	MOV	#006406,R0
155216:	CALL	154310		; fetch the device and file name
155222:	TRAP	140		; get a pair of characters to r4
155224:	CMP	R4,#040523	; "AS"
155230:	BNE	155304
155232:	MOV	#D10,R0
155236:	CALL	154310		; fetch the device and file name
155242:	MOV	#006406,R0
155246:	MOV	(R0),R3
155250:	CALL	157430		; check the memory module
155254:	TST	007524		; memory module type
155260:	BEQ	155264		; skip if a RAM module
155262:	TRAP	161		; error 56 - file write protected
155264:	MOVB	#003,000001(R0)	; rename file
155272:	CALL	151126		; file access
155276:	BLO	155306
155300:	JMP	103332
155304:	TRAP	173		; error 61 - wrong NAME operator format
155306:	TRAP	171		; error 60 - renamed file not found

; command SAVE
155310:	CLR	006546
155314:	MOV	#006406,R0
155320:	CALL	154154
155324:	CALL	154310		; fetch the device and file name
155330:	MOV	(R0),R3
155332:	CALL	157430		; check the memory module
155336:	TST	007524		; memory module type
155342:	BEQ	155346		; skip if a RAM module
155344:	TRAP	161		; error 56 - file write protected
155346:	CLR	007200
155352:	MOV	R1,-(SP)
155354:	TRAP	140		; get a pair of characters to r4
155356:	CMP	R4,#026101	",A"
155362:	BEQ	155440
155364:	MOV	(SP)+,R1
155366:	TST	007510
155372:	BNE	155402
155374:	MOV	#CAB,007510
155402:	INC	007200
155406:	MOV	R5,R4
155410:	MOV	007362,R3
155414:	SUB	R3,R4
155416:	INC	R4
155420:	ADD	#1FF,R4
155424:	CLRB	R4
155426:	SWAB	R4
155430:	ASR	R4
155432:	MOV	R4,000004(R0)
155436:	BR	155456
155440:	TST	(SP)+
155442:	TST	007510
155446:	BNE	155456
155450:	MOV	#CBB,007510
155456:	MOVB	#002,000001(R0)	; write file
155464:	CALL	151126		; file access
155470:	BHIS	155474
155472:	TRAP	167		; error 59 - SMP overflow
155474:	MOV	006414,R2
155500:	SWAB	R2
155502:	ASL	R2
155504:	MOV	R2,007442
155510:	TST	007200
155514:	BEQ	155552
155516:	MOV	007362,R0
155522:	MOV	R5,-(SP)
155524:	TRAP	116
155526:	MOVB	(R0)+,R2
155530:	CALL	155564
155534:	CMP	R0,R5
155536:	BLO	155526
155540:	MOV	(SP)+,R5
155542:	CALL	155644
155546:	JMP	103326
155552:	MOV	#001,007376
155560:	JMP	102440

155564:	CALL	120114		; save registers on the stack
155570:	MOV	007442,R0	; destination address
155574:	SWAB	R0
155576:	MOV	R0,007522
155602:	MOV	#002,R1		; number of bytes to write
155606:	MOV	007444,R3
155612:	MOV	SP,R2
155614:	CMP	(R2)+,(R2)+	; r2 = source address
155616:	CLRB	000001(R2)
155622:	CALL	153650		; write a memory block to the SMP
155626:	INC	007442
155632:	CALL	120140		; restore registers from the stack
155636:	ADD	R2,006546
155642:	RETURN

155644:	MOV	#006406,R0
155650:	MOVB	#004,000001(R0)
155656:	CALL	151126		; file access
155662:	RETURN

; command INIT
155664:	MOV	#006406,R0
155670:	CALL	156676		; test for the end of the command line
155674:	BEQ	155702		; skip if command without parameters
155676:	CALL	154310		; fetch the device and file name
155702:	CALL	154414		; print 'vy uvereny?' (are you sure?)
155706:	CMPB	#131,R2		; 'Y'
155712:	BNE	156122
155714:	MOV	R1,-(SP)
155716:	MOV	(R0),R3		; device number
155720:	CALL	153760		; erase the SMP with spaces
155724:	CALL	157430		; check the memory module
155730:	TST	007524		; memory module type
155734:	BEQ	155740		; skip if a RAM module
155736:	TRAP	161		; error 56 - file write protected
155740:	CLR	R4
155742:	CLR	007520
155746:	CLR	007522
; determine the SMP memory size
155752:	MOV	#001,R1		; number of bytes
155756:	MOV	#007522,R0	; source address
155762:	MOV	#002700,R2	; destination address
155766:	MOVB	#377,(R2)
155772:	CALL	153622		; read a memory block from the SMP
155776:	CMPB	002700,#377
156004:	BEQ	156034
156006:	CMPB	002700,#040
156014:	BNE	156030
156016:	INC	R4
156020:	JSR	R5,155074
156024:	.WORD	004000
156026:	BR	155752
156030:	TRAP	157		; error 55 - input/output error
156032:	TRAP	167		; error 59 - SMP overflow
156034:	ASL	R4
156036:	ASL	R4
156040:	SUB	006144,R4
156044:	BLE	156032
156046:	MOV	R4,006156
156052:	CLR	007470
156056:	MOV	#157200,R4	; data blocks copied to the SMP
156062:	MOV	#004,-(SP)	; number of copied blocks
156066:	MOV	(R4)+,R0	; destination address
156070:	SWAB	R0
156072:	MOV	R0,007522
156076:	MOV	(R4)+,R2	; source address
156100:	MOV	(R4)+,R1	; number of bytes to write
156102:	MOV	R4,-(SP)
156104:	CALL	153650		; write a memory block to the SMP
156110:	MOV	(SP)+,R4
156112:	DEC	(SP)		; counter of copied blocks
156114:	BNE	156066		; next block
156116:	TST	(SP)+
156120:	MOV	(SP)+,R1
156122:	JMP	103332

; command FILES
156126:	CALL	120114		; save registers on the stack
156132:	MOV	#006406,R0
156136:	CALL	156676		; test for the end of the command line
156142:	BEQ	156154		; branch if command without parameters
156144:	CALL	154310		; fetch the device and file name
156150:	MOV	R1,000002(SP)
156154:	MOV	(R0),007444
156160:	MOV	(R0),R3
156162:	CALL	157430		; check the memory module
156166:	CLR	007446
156172:	CLR	007450
156176:	CLR	007452
156202:	CLR	R5
156204:	JSR	R5,152246
156210:	MOV	R4,007460
156214:	MOV	#005,R5
156220:	CALL	156632
156224:	JSR	R5,152272
156230:	.WORD	003000
156232:	BR	156436
156234:	CALL	156604
156240:	BIT	(R1)+,#400
156244:	BNE	156276
156246:	MOV	#156771,R4
156252:	MOVB	(R4)+,(R0)+
156254:	BNE	156252
156256:	MOVB	#040,-(R0)
156262:	CMPB	(R0)+,(R0)+
156264:	ADD	#006,R1
156270:	ADD	(R1),007446
156274:	BR	156340
156276:	CALL	157054
156302:	ADD	(R1),007452
156306:	INC	007450
156312:	MOV	#007247,R0
156316:	MOV	#007250,R4
156322:	MOVB	-(R0),-(R4)
156324:	MOVB	-(R0),-(R4)
156326:	MOVB	-(R0),-(R4)
156330:	MOVB	#056,-(R4)
156334:	ADD	#006,R0
156340:	MOV	(R1),R3
156342:	CALL	156554
156346:	CMPB	(R0)+,(R0)+
156350:	MOV	007460,R3
156354:	CALL	156554
156360:	CLRB	(R0)+
156362:	MOV	#007236,R0	; input line buffer
156366:	TRAP	066		; print a string pointed to by r0
156370:	TRAP	002		; print CR, LF
156372:	ADD	(R1)+,007460
156376:	CMP	(R1)+,(R1)+
156400:	ADD	002706,R1
156404:	SOB	R5,156224
156406:	TST	007440
156412:	BNE	156426
156414:	CALL	137472		; wait for a key
156420:	CMPB	R2,#015
156424:	BNE	156540
156426:	TRAP	002		; print CR, LF
156430:	MOV	#006,R5
156434:	BR	156224
156436:	JSR	R5,152356
156442:	BR	156446
156444:	BR	156224
156446:	CMP	R5,#006
156452:	BEQ	156472
156454:	CALL	156624
156460:	TST	007440
156464:	BNE	156472
156466:	CALL	137472		; wait for a key
156472:	MOV	#004,R5
156476:	CALL	156624
156502:	MOV	#157036,R5
156506:	MOV	@(R5)+,R3
156510:	CALL	156604
156514:	CALL	156554
156520:	CLRB	000001(R0)
156524:	CMPB	-(R0),-(R0)
156526:	TRAP	066		; print a string pointed to by r0
156530:	MOV	(R5)+,R0
156532:	TRAP	066		; print a string pointed to by r0
156534:	TST	(R5)
156536:	BNE	156506
156540:	CALL	120140		; restore registers from the stack
156544:	CLR	007440
156550:	JMP	103332
156554:	CLR	R2
156556:	DIV	#012,R2
156562:	BEQ	156572
156564:	BIS	#060,R2
156570:	MOVB	R2,(R0)
156572:	INC	R0
156574:	BIS	#060,R3
156600:	MOVB	R3,(R0)+
156602:	RETURN
156604:	MOV	#012,R2
156610:	MOV	#007262,R0
156614:	MOV	#020040,-(R0)
156620:	SOB	R2,156614
156622:	RETURN
156624:	TRAP	002		; print CR, LF
156626:	SOB	R5,156624
156630:	RETURN

156632:	MOV	006534,-(SP)
156636:	MOV	#157006,R0	; string 'Spravochnik' (directory)
156642:	TRAP	066		; print a string pointed to by r0
156644:	BIS	#001,006534
156652:	TRAP	066		; print a string pointed to by r0
156654:	MOV	007444,R2
156660:	BIS	#060,R2
156664:	TRAP	000		; print character r2
156666:	TRAP	066		; print a string pointed to by r0
156670:	MOV	(SP)+,006534
156674:	RETURN

; test for the end of the command line
156676:	MOV	007436,(R0)
156702:	TRAP	072		; get a character other than space to r2
156704:	DEC	R1
156706:	CMPB	R2,#012
156712:	BEQ	156720
156714:	CMPB	R2,#072
156720:	RETURN

156720:	87 00 0E 46  41 4A 4C 4F  57 2C 20 00  42 4C 4F 4B  ...FAJLOW, .BLOK
156740:	4F 57 0D 0A  00 53 57 4F  42 4F 44 4E  59 48 20 42  OW...SWOBODNYH B
156760:	4C 4F 4B 4F  57 0F 0D 0A  00 0E 3C 53  57 4F 42 4F  LOKOW.....<SWOBO
157000:	44 4E 4F 3E  0F 00 20 20  00 0E 20 73  50 52 41 57  DNO>..  .. sPRAW
157020:	4F 5E 4E 49  4B 0F 20 53  4D 00 20 0D  0A 00 28 0F  O^NIK. SM. ...(.
157040:	D2 DD 2A 0F  DC DD 26 0F  E5 DD 00 00

157054:	MOV	R0,-(SP)
157056:	MOV	R3,-(SP)
157060:	MOV	R4,-(SP)
157062:	MOV	R5,-(SP)
157064:	MOV	#003,R4
157070:	SUB	R4,R0
157072:	MOV	#003,R5
157076:	ADD	#006,R0
157102:	MOV	(R1)+,R3
157104:	CALL	157130		; expansion of the Radix-50 encoded word
157110:	MOVB	R2,-(R0)
157112:	SOB	R5,157104
157114:	SOB	R4,157072
157116:	MOV	(SP)+,R5
157120:	MOV	(SP)+,R4
157122:	MOV	(SP)+,R3
157124:	MOV	(SP)+,R0
157126:	RETURN

; expansion of the Radix-50 encoded word
157130:	CLR	R2
157132:	DIV	#050,R2
157136:	MOV	R3,-(SP)
157140:	MOV	R2,R3
157142:	MOV	(SP)+,R2
157144:	BEQ	157172
157146:	CMP	R2,#033
157152:	BLT	157166
157154:	BEQ	157162
157156:	ADD	#011,R2
157162:	ADD	#177711,R2
157166:	ADD	#040,R2
157172:	ADD	#040,R2
157176:	RETURN

; data copied to the SMP by the INIT command
; destination address, source address, number of bytes
157200:	.WORD	002000, 006134, 000034
157206:	.WORD	000000, 157230, 000074
157214:	.WORD	001000, 157324, 000002
157222:	.WORD	001722, 157326, 000045

; boot loader written to the SMP
157230:	NOP
157232:	CALL	@#145154	; RAM initialisation
157236:	CALL	@#122324
157242:	MOV	@#006402,@#164000	; address of the display RAM
157250:	MOV	#104306,@#164002
157256:	JSR	R0,157312
157262:	.ASCIZ	"\016\r\n smp BEZ ZAGRUZ^IKA"	; SMP without loader
157311:	.EVEN
157312:	MOVB	(R0)+,R2
157314:	BEQ	157314
157316:	CALL	@#120034	; display character r2
157322:	BR	157312

157324:	             00 00 01 00  06 00 50 8E  42 41 53 49  ......P.BASI
157340:	43 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20  C               
157360:	20 20 20 20  20 20 20 20  20 20 20 FF  C0 15 06 0D             .@...

; command DEV
157374:	MOV	#006406,R0
157400:	CALL	156676		; test for the end of the command line
157404:	BNE	157414		; branch if command with parameters
157406:	CLR	007436
157412:	BR	157424
157414:	CALL	154310		; fetch the device and file name
157420:	MOV	(R0),007436
157424:	JMP	103332

; check the memory module
; returns 0 in the variable 007524 if write test passed
157430:	CALL	120114		; save registers on the stack
157434:	MOV	#001,007524	; memory module type <- ROM
157442:	MOV	007520,-(SP)
157446:	MOV	007522,-(SP)
; read data at location 0000
157452:	CLR	007520
157456:	CLR	007522
157462:	MOV	#007202,R2	; destination address
157466:	CLR	(R2)
157470:	MOV	#007521,R0	; source address
157474:	MOV	#001,R1		; number of bytes
157500:	CALL	153622		; read a memory block from the SMP
157504:	MOV	#007202,R2	; source address
157510:	MOV	(R2),006546
; complement data at location 0000
157514:	COMB	(R2)
157516:	MOV	#007521,R0	; destination address
157522:	MOV	#001,R1		; number of bytes
157526:	CALL	153666		; write a memory block to the SMP
; verify data at location 0000
157532:	MOV	#007202,R2	; destination address
157536:	CLR	(R2)
157540:	MOV	#007521,R0	; source address
157544:	MOV	#001,R1		; number of bytes
157550:	CALL	153622		; read a memory block from the SMP
157554:	CMPB	007202,006546
157562:	BEQ	157624
; restore original data at location 0000
157564:	MOV	#006546,R2	; source address
157570:	MOV	#007521,R0	; destination address
157574:	MOV	#001,R1		; number of bytes
157600:	CALL	153666		; write a memory block to the SMP
157604:	CLR	007524		; memory module type <- RAM
157610:	CLR	007526
157614:	MOV	#004,006144
157622:	BR	157656
157624:	CMPB	#377,007202
157632:	BNE	157636
157634:	TRAP	153		; error 53 - SMP not ready
157636:	MOV	#004,007526
157644:	MOV	#010,006144
157652:	INC	007524		; memory module type <- ROM
157656:	MOV	(SP)+,007522
157662:	MOV	(SP)+,007520
157666:	CALL	120140		; restore registers from the stack
157672:	RETURN

157674:	0E 57 59 20  .WY 
157700:	55 57 45 52  45 4E 59 3F  0F 00 FF FF  FF FF FF FF  UWERENY?........


; HALT mode vectors

160000:	.WORD	000000		; power on
160002:	.WORD	160016, 000340	; HALT in the HALT mode
160006:	.WORD	160022, 000340	; double bus error
160012:	.WORD	160030, 000340	; interrupt vector error

; instruction HALT or signal HALT in the HALT mode handler routine
160016:	CLR	R0
160020:	BR	160034
; double bus error handler routine
160022:	MOV	#002,R0
160026:	BR	160034
; interrupt vector error handler routine
160030:	MOV	#004,R0
160034:	TST	@#050
160040:	BEQ	160050
; the location 0028 can contain the address of alternative handler routines
160042:	ADD	@#050,R0
160046:	JMP	(R0)
; The default handler routine displays an error message followed by the
; address where the event has occurred, then hangs the system.
160050:	MOV	(SP),R1		; error address taken from the stack
; The above instruction indicates that upon entering the HALT mode the PSW
; and the PC registers are stored on the system stack instead of special
; registers, unlike in the 1801VM1 or 1801VM2 processors.
160052:	MOV	#200,SP
160056:	MOV	160116(R0),R0	; pointer to the message
160062:	MOV	R0,R5
160064:	ADD	#025,R0		; end of the buffer for the octal number
160070:	MOV	#006,R4		; number of digits
160074:	CALL	100032		; convert the word in r1 to octal ASCII
160100:	MOV	R5,R0
160102:	MOVB	(R0)+,R2
160104:	BEQ	160114
160106:	CALL	120034		; display character r2
160112:	BR	160102
160114:	BR	160114		; hang the system

160116:	.WORD	006236	; string "OST PO ADRESU 000000" - stop at address...
160120:	.WORD	006265	; string "DW OSH KANALA 000000" - double bus error 
160122:	.WORD	006314	; string "OSH WEK PRERYW 000000" - interr. vector error

; tests
160124:	MOV	#200,SP
160130:	CALL	160136
160134:	BR	160234

160136:	CALL	@#145154	; RAM initialisation
160142:	MOV	#001,@#006536
160150:	CALL	@#122324
160154:	MOV	#003,006126
160162:	MOV	#136550,@#310	; keyboard controller interrupt vector
160170:	CLR	@#312
160174:	MOV	#000066,@#164022
160202:	MOV	#342,@#164024
160210:	MOV	@#006402,@#164000	; address of the display RAM
160216:	MOV	#104306,@#164002
160224:	MOV	#001,006540
160232:	RETURN

160234:	CLR	@#006120
160240:	CLR	@#006506
160244:	INC	006536
160250:	BIS	#041,006534
160256:	MOV	#160554,R1	; string "TESTY" (tests)
160262:	CALL	160372		; display the string pointed to by r1
160266:	BIC	#001,006534
160274:	MOV	#160424,R1
160300:	CALL	160372		; display the string pointed to by r1
160304:	MOV	#160536,R1	; string "NOMER TESTA"
160310:	MOV	#040,006120
160316:	CLR	006506
160322:	CALL	160372		; display the string pointed to by r1
160326:	CALL	@#137472	; wait for a key
160332:	CALL	@#120034	; display character r2
160336:	BIC	#177770,R2
160342:	DEC	R2
160344:	ASL	R2
160346:	CLR	@#006536
160352:	CMP	#004,R2
160356:	BGE	160366
160360:	MOV	#010000,@#164032	; RAM address range 000000-037777
				; ROM address range 040000-157777, 166000-176777
160366:	JMP	@160406(R2)

; display a zero terminated string pointed to by r1
160372:	MOVB	(R1)+,R2
160374:	BEQ	160404
160376:	CALL	@#120034	; display character r2
160402:	BR	160372
160404:	RETURN

; addresses of test procedures
160406:	.WORD	042706, 040674, 040000, 160604, 160604, 160604, 173000

160424:	             0E 31 20 73  6D 70 20 20  32 20 4B 4C      .1 smp  2 KL
160440:	41 57 49 41  54 55 52 41  20 33 20 76  6B 69 20 20  AWIATURA 3 vki  
160460:	34 20 4D 41  47 4E 49 54  4F 46 4F 4E  20 35 20 61  4 MAGNITOFON 5 a
160500:	64 73 61 20  36 20 54 45  4C 45 57 49  5A 4F 52 20  dsa 6 TELEWIZOR 
160520:	20 0D 0A 0D  0A 37 20 77  59 48 4F 44  20 00 4E 4F   ....7 wYHOD .NO
160540:	4D 45 52 20  54 45 53 54  41 3A 0F 00  0E 20 20 20  MER TESTA:...   
160560:	20 20 20 20  54 45 53 54  59 20 20 20  20 20 20 20      TESTY       
160600:	20 0F 00 FF

; call the test procedure from the MK-92 ROM
; R2=6 - "vki", R2=8 - tape recorder, R2=A - "adsa", R2=C - tv
160604:	CALL	120114		; save registers on the stack
160610:	MOV	@#164200,R1
160614:	TST	@#164036
160620:	BMI	160750
160622:	MOV	#020000,@#164200	; switch the memory banks, MK-92 ROM enabled
160630:	SUB	#006,R2
160634:	ADD	#040022,R2	; table of addresses of the test procedures
160640:	MOV	R2,R4
160642:	BIT	#002,@#164036
160650:	BNE	160710
160652:	MOV	#004,R3		; number of ROM pages in the MK-92
; find the MK-92 ROM page which contains valid data
160656:	CLR	R0
160660:	CMP	#006273,@#040000
160666:	BNE	160732		; invalid data, try the next ROM page
160670:	CMP	R0,@#040014
160674:	BNE	160732		; invalid data, try the next ROM page
160676:	TST	(R4)
160700:	BLE	160732		; invalid data, try the next ROM page
160702:	MOV	R1,-(SP)
160704:	CALL	@(R4)+
160706:	MOV	(SP)+,R1
160710:	MOV	R1,@#164200
160714:	MOV	#005000,@#164032	; RAM address range 000000-077777, 164000-165777
				; ROM address range 100000-157777, 166000-176777
160722:	CALL	120140	; restore registers from the stack
160726:	JMP	160124		; back to the "TESTS" menu

; select the next ROM page in the MK-92
160732:	ADD	#800,@#164200
160740:	ADD	#800,R0
160744:	SOB	R3,160660
160746:	BR	160710

160750:	INC	006536
160754:	MOV	#160772,R1	; 'BR ne gotov' (something not ready)
160760:	CALL	160372		; display the string pointed to by r1
160764:	CALL	137472		; wait for a key
160770:	BR	160710

160772:	0E 0D  0A 62 72 20	...br 
161000:	4E 45 20 47  4F 54 4F 57  0F 00 FF FF  FF FF FF FF  NE GOTOW........

166000:	CALL	120114		; save registers on the stack
166004:	CLR	006620
166010:	CLR	007176
166014:	CLR	007200
166020:	MOV	#001,007212
166026:	TRAP	072		; get a character other than space to r2
166030:	DEC	R1
166032:	CMPB	R2,#042
166036:	BNE	166412
166040:	INC	006620
166044:	MOV	#006406,R0
166050:	CALL	154310		; fetch the device and file name
166054:	TST	007510
166060:	BNE	166070
166062:	MOV	#CBB,007510
166070:	TRAP	106		; get a pair of integer numbers
166072:	MOV	R3,007174	; first number
166076:	BNE	166104
166100:	INC	007176
166104:	MOV	#006406,R0
166110:	MOVB	#001,000001(R0)	; read file
166116:	CALL	151126		; file access
166122:	BHIS	166130
166124:	TRAP	175		; error 62 - file not found
166126:	BR	166412
166130:	MOV	006414,R0
166134:	CALL	153732		; convert the sector number in R0 to an address
166140:	MOV	006406,R3
166144:	MOV	#5C0,R2
166150:	MOV	#001,R1
166154:	CALL	153602
166160:	JSR	R5,155074
166164:	.WORD	000001
166166:	DEC	R2
166170:	MOVB	(R2),R2
166172:	BEQ	166412
166174:	TST	007176
166200:	BEQ	166254
166202:	TST	007400
166206:	BNE	166412
166210:	TRAP	000		; print character r2
166212:	CMPB	R2,#012
166216:	BNE	166144
166220:	DEC	007212
166224:	BEQ	166144
166226:	TST	007440
166232:	BNE	166144
166234:	MOV	R0,-(SP)
166236:	CALL	137472		; wait for a key
166242:	CMPB	R2,#015
166246:	BNE	166236
166250:	MOV	(SP)+,R0
166252:	BR	166144
166254:	TST	007200
166260:	BEQ	166370
166262:	TRAP	070		; is r2 a digit?
166264:	BNE	166302		; branch if r2 is not a decimal digit
166266:	MOV	#F4A,R1
166272:	ADD	R5,R1
166274:	MOVB	R2,(R1)
166276:	INC	R5
166300:	BR	166144
166302:	TST	R5
166304:	BNE	166314
166306:	INC	007216
166312:	BR	166144
166314:	MOV	#F4A,R1
166320:	MOV	R0,-(SP)
166322:	TRAP	010		; ATOI
166324:	CMP	007174,R0
166330:	BGT	166360
166332:	INC	007176
166336:	MOV	(SP)+,R0
166340:	SUB	R5,R0
166342:	SUB	007216,R0
166346:	SUB	#002,R0
166352:	CLRB	-(R1)
166354:	SOB	R5,166352
166356:	BR	166144
166360:	MOV	(SP)+,R0
166362:	CLR	007200
166366:	BR	166144
166370:	CMPB	R2,#012
166374:	BNE	166144
166376:	INC	007200
166402:	CLR	R5
166404:	CLR	007216
166410:	BR	166144
166412:	CALL	120140		; restore registers from the stack
166416:	RETURN

; command OPEN
166420:	CALL	120114		; save registers on the stack
166424:	TRAP	072		; get a character other than space to r2
166426:	CMPB	R2,#043
166432:	BNE	166574
166434:	TRAP	010		; ATOI
166436:	MOV	R0,R5
166440:	BLE	166574
166442:	CMP	#006,R5
166446:	BLT	166574
166450:	CMPB	(R1)+,#054
166454:	BNE	166574
166456:	TRAP	072		; get a character other than space to r2
166460:	MOVB	R2,R3
166462:	BIC	#177600,R3
166466:	CMPB	#111,R3
166472:	BEQ	166502
166474:	CMPB	#117,R3
166500:	BNE	166574
166502:	TRAP	072		; get a character other than space to r2
166504:	CMPB	R2,#054
166510:	BNE	166574
166512:	MOV	R1,-(SP)
166514:	TRAP	072		; get a character other than space to r2
166516:	CMPB	R2,#042
166522:	BNE	166572
166524:	TRAP	140		; get a pair of characters to r4
166526:	CMP	R4,#046120	; "LP"
166532:	BNE	166602
166534:	TRAP	072		; get a character other than space to r2
166536:	CMPB	R2,#072
166542:	BNE	166572
166544:	MOV	(SP)+,R1
166546:	CMPB	R3,#117
166552:	BNE	166574
166554:	DEC	R5
166556:	MUL	#010,R5
166562:	MOV	#050114,005700(R5)
166570:	BR	167044
166572:	MOV	(SP)+,R1
166574:	CALL	120140		; restore registers from the stack
166600:	TRAP	173		; error 61 - wrong NAME operator format
166602:	MOV	(SP)+,R1
166604:	MOV	#006406,R0
166610:	MOV	R3,-(SP)
166612:	CALL	154310		; fetch the device and file name
166616:	MOV	(SP)+,R3
166620:	TST	007510
166624:	BNE	166634
166626:	MOV	#CBB,007510
166634:	MOVB	#001,000001(R0)	; read file
166642:	CALL	151126		; file access
166646:	BLO	166750
166650:	MOV	006414,R2
166654:	MOV	006412,R4
166660:	CMPB	R3,#111
166664:	BNE	167062
166666:	MOV	R2,R0
166670:	CALL	153732		; convert the sector number in R0 to an address
166674:	CALL	167450
166700:	MOV	007520,(R0)+
166704:	MOV	007522,(R0)+
166710:	ADD	R2,R4
166712:	MOV	R0,R2
166714:	MOV	R4,R0
166716:	CALL	153732		; convert the sector number in R0 to an address
166722:	MOV	R5,-(SP)
166724:	JSR	R5,167402
166730:	WAIT
166732:	MOV	(SP)+,R5
166734:	MOV	R2,R0
166736:	MOV	007520,(R0)+
166742:	MOV	007522,(R0)+
166746:	BR	167024
166750:	CMPB	R3,#111
166754:	BNE	166764
166756:	CALL	120140		; restore registers from the stack
166762:	TRAP	175		; error 62 - file not found
166764:	MOV	#006406,R0
166770:	MOVB	#002,000001(R0)	; write file
166776:	CALL	151126		; file access
167002:	BHIS	167012
167004:	CALL	120140		; restore registers from the stack
167010:	TRAP	167		; error 59 - SMP overflow
167012:	MOV	006414,R2
167016:	MOV	006412,R4
167022:	BR	166666
167024:	MOV	006414,(R0)+
167030:	MOV	007504,(R0)+
167034:	MOV	007506,(R0)+
167040:	MOV	007510,(R0)+
167044:	MOV	R1,000002(SP)
167050:	CALL	120140		; restore registers from the stack
167054:	TRAP	110
167056:	JMP	103144
167062:	MOV	R1,-(SP)
167064:	MOV	#006406,R0
167070:	MOV	R4,R1
167072:	ASL	R1
167074:	MOV	R1,006412
167100:	MOVB	#002,000001(R0)	; write file
167106:	CALL	151126		; file access
167112:	BHIS	167124
167114:	MOV	(SP)+,R1
167116:	CALL	120140		; restore registers from the stack
167122:	TRAP	167		; error 59 - SMP overflow
167124:	ADD	006414,R1
167130:	MOV	R1,R0
167132:	CALL	153732		; convert the sector number in R0 to an address
167136:	MOV	R5,-(SP)
167140:	JSR	R5,167402
167144:	WAIT
167146:	MOV	(SP)+,R5
167150:	MOV	007522,-(SP)
167154:	MOV	007520,-(SP)
167160:	MOV	006414,-(SP)
167164:	BIC	#177600,006406
167172:	MOV	R3,-(SP)
167174:	MOV	006406,R3
167200:	MOV	#001,R1		; number of sectors
167204:	MOV	R2,R0		; starting sector
167206:	MOV	R2,-(SP)
167210:	MOV	#004700,R2	; destination address
167214:	CALL	153572		; read sectors from the memory module
167220:	MOV	#004700,R2	; source address
167224:	MOV	#001,R1		; number of sectors
167230:	MOV	006414,R0	; starting sector
167234:	CALL	153640		; write sectors to the memory module
167240:	MOV	(SP)+,R2
167242:	INC	R2
167244:	INC	006414
167250:	SOB	R4,167174
167252:	MOV	006414,R0
167256:	DEC	R0
167260:	CALL	153732		; convert the sector number in R0 to an address
167264:	MOV	006406,R3
167270:	MOV	#004700,R2
167274:	MOV	#001,R1
167300:	CALL	153602
167304:	MOV	R5,-(SP)
167306:	JSR	R5,155074
167312:	.WORD	000001
167314:	MOV	(SP)+,R5
167316:	CMPB	#012,004700
167324:	BNE	167270
167326:	MOV	#001,R1
167332:	MOV	#004700,R2
167336:	CALL	153602
167342:	TSTB	004700
167346:	BNE	167270
167350:	MOV	(SP)+,R3
167352:	MOV	(SP)+,006414
167356:	CALL	167450
167362:	MOV	007520,(R0)+
167366:	MOV	007522,(R0)+
167372:	MOV	(SP)+,(R0)+
167374:	MOV	(SP)+,(R0)+
167376:	MOV	(SP)+,R1
167400:	BR	167024
167402:	MOV	R1,-(SP)
167404:	MOV	R0,-(SP)
167406:	MOV	007520,R1
167412:	SWAB	R1
167414:	MOV	007522,R0
167420:	SWAB	R0
167422:	SUB	(R5)+,R0
167424:	SBC	R1
167426:	SWAB	R0
167430:	MOV	R0,007522
167434:	SWAB	R1
167436:	MOV	R1,007520
167442:	MOV	(SP)+,R0
167444:	MOV	(SP)+,R1
167446:	RTS	R5
167450:	MOV	#BC0,R0
167454:	DEC	R5
167456:	MUL	#024,R5
167462:	ADD	R5,R0
167464:	MOV	#046523,(R0)+
167470:	BIC	#177600,006406
167476:	MOV	006406,(R0)
167502:	MOVB	R3,000001(R0)
167506:	TST	(R0)+
167510:	RETURN

; command CLOSE
167512:	CALL	120114		; save registers on the stack
167516:	TRAP	072		; get a character other than space to r2
167520:	CMPB	R2,#043
167524:	BNE	167536
167526:	TRAP	010		; ATOI
167530:	CMP	R0,#006
167534:	BLOS	167544
167536:	CALL	120140		; restore registers from the stack
167542:	TRAP	173		; error 61 - wrong NAME operator format
167544:	MOV	#BC0,R2
167550:	DEC	R0
167552:	MOV	R0,R3
167554:	MUL	#024,R3
167560:	ADD	R3,R2
167562:	TST	(R2)
167564:	BNE	167570
167566:	TRAP	173		; error 61 - wrong NAME operator format
167570:	CMP	(R2),#050114
167574:	BNE	167602
167576:	CLR	(R2)
167600:	BR	167776
167602:	CMP	(R2),#046523
167606:	BNE	167776
167610:	MOV	000006(R2),R3
167614:	SWAB	R3
167616:	MOV	R3,000006(R2)
167622:	ASR	000006(R2)
167626:	BLO	167636
167630:	TSTB	000006(R2)
167634:	BEQ	167642
167636:	INCB	000007(R2)
167642:	CLR	006412
167646:	MOVB	000007(R2),006412
167654:	MOV	000014(R2),006414
167662:	MOV	000016(R2),007504
167670:	MOV	000020(R2),007506
167676:	MOV	000022(R2),007510
167704:	MOV	000002(R2),006406
167712:	BIC	#177400,006406
167720:	SUB	006414,006412
167726:	MOV	#006406,R0
167732:	MOVB	#004,000001(R0)
167740:	CALL	151126		; file access
167744:	TST	006412
167750:	BNE	167766
167752:	MOV	#006406,R0
167756:	CLRB	000001(R0)	; kill file
167762:	CALL	151126		; file access
167766:	MOV	#012,R1
167772:	CLR	(R2)+
167774:	SOB	R1,167772
167776:	CALL	120140		; restore registers from the stack
170002:	TRAP	110
170004:	JMP	103144
170010:	DEC	(SP)
170012:	MOV	(SP),R3
170014:	MUL	#024,R3
170020:	MOV	R3,R4
170022:	ADD	#BC0,R4
170026:	CMP	#050114,(R4)
170032:	BEQ	170046
170034:	CMP	#046523,(R4)
170040:	BNE	170050
170042:	TST	(R0)+
170044:	TST	(R0)+
170046:	TST	(R0)+
170050:	RTS	R0

; command GET
170052:	MOV	#001,007234
170060:	BR	170066

; command PUT
170062:	CLR	007234
170066:	CALL	120114		; save registers on the stack
170072:	TRAP	072		; get a character other than space to r2
170074:	CMPB	R2,#043
170100:	BEQ	170104
170102:	TRAP	173		; error 61 - wrong NAME operator format
170104:	TRAP	010		; ATOI
170106:	CMP	#006,R0
170112:	BLO	170102
170114:	JSR	R0,170010
170120:	TRAP	175		; error 62 - file not found
170122:	JMP	110122
170126:	CMPB	000003(R4),#117
170134:	BNE	170146
170136:	TST	007234
170142:	BEQ	170154
170144:	TRAP	075		; error 30 - wrong parameters
170146:	TST	007234
170152:	BEQ	170144
170154:	TRAP	072		; get a character other than space to r2
170156:	CMPB	R2,#054
170162:	BNE	170102
170164:	TST	007234
170170:	BEQ	170436
170172:	MOV	R1,-(SP)
170174:	MOV	#004700,R2
170200:	MOVB	(R1),(R2)+
170202:	CMPB	#012,(R1)
170206:	BEQ	170216
170210:	CMPB	#072,(R1)+
170214:	BNE	170200
170216:	MOVB	#075,177777(R2)
170224:	MOV	000002(R4),R3
170230:	MOV	000004(R4),007520
170236:	MOV	000006(R4),007522
170244:	CMP	007520,000010(R4)
170252:	BLOS	170266
170254:	CMP	007522,000012(R4)
170262:	BLOS	170266
170264:	TRAP	157		; error 55 - input/output error
170266:	MOV	R5,-(SP)
170270:	MOV	R4,-(SP)
170272:	MOV	#001,R1
170276:	CALL	153602
170302:	JSR	R5,155074
170306:	.WORD	000001
170310:	TSTB	177777(R2)
170314:	BNE	170320
170316:	TRAP	157		; error 55 - input/output error
170320:	CMPB	#012,177777(R2)
170326:	BNE	170272
170330:	MOV	(SP)+,R4
170332:	MOV	007520,000004(R4)
170340:	MOV	007522,000006(R4)
170346:	MOVB	#012,177776(R2)
170354:	MOV	(SP)+,R5
170356:	MOV	#004700,R1
170362:	TRAP	144
170364:	BVS	170406
170366:	BNE	170374
170370:	MOV	R4,R0
170372:	TRAP	146
170374:	MOV	R0,-(SP)
170376:	TRAP	072		; get a character other than space to r2
170400:	CMP	R2,#075
170404:	BEQ	170410
170406:	TRAP	021		; error 8 - illegal LET operator
170410:	TRAP	136		; evaluate an arithmetical expression
170412:	BVS	170434
170414:	MOV	(SP)+,R0
170416:	MOV	R2,(R0)+
170420:	MOV	R3,(R0)+
170422:	MOV	R4,(R0)+
170424:	MOV	(SP)+,R1
170426:	MOV	R5,000012(SP)
170432:	BR	170664
170434:	TRAP	017		; error 7 - mismatched parentheses
170436:	MOV	R4,-(SP)
170440:	MOV	#034,R0
170444:	TRAP	104		; check the available stack space
170446:	BHIS	170452
170450:	TRAP	001		; error 0 - out of memory
170452:	TRAP	136		; evaluate an arithmetical expression
170454:	BVC	170460
170456:	TRAP	027		; error 11 - illegal PRINT operator
170460:	MOV	R1,-(SP)
170462:	CALL	112420		; floating point to ASCII conversion
170466:	MOV	SP,R2		; pointer to the output string
170470:	TSTB	(R2)+		; search for the end of the output string
170472:	BNE	170470
170474:	MOVB	#015,-1(R2)	; append CR/LF at the end of the string
170502:	MOVB	#012,(R2)
170506:	MOV	SP,R2		; r2 = source address
170510:	MOV	000026(R2),R4
170514:	MOV	000002(R4),R3
170520:	MOV	000004(R4),007520
170526:	MOV	000006(R4),007522	; destination address (big endian order)
170534:	MOV	#001,R1		; number of bytes to write
170540:	CMPB	#040,(R2)
170544:	BNE	170552
170546:	INC	R2
170550:	BR	170540
170552:	CALL	153650		; write a memory block to the SMP
170556:	JSR	R5,155074
170562:	.WORD	000001
170564:	CMP	007520,000010(R4)
170572:	BHI	170606
170574:	BLO	170614
170576:	CMP	007522,000012(R4)
170604:	BLOS	170614
170606:	CALL	120140		; restore registers from the stack
170612:	TRAP	157		; error 55 - input/output error
170614:	TSTB	177777(R2)
170620:	BEQ	170652
170622:	CMPB	#012,177777(R2)
170630:	BNE	170534
170632:	MOV	007520,000004(R4)
170640:	MOV	007522,000006(R4)
170646:	CLRB	(R2)
170650:	BR	170534
170652:	ADD	#024,SP
170656:	MOV	(SP)+,R1
170660:	MOV	(SP)+,R4
170662:	DEC	R0
170664:	CALL	120140		; restore registers from the stack
170670:	TRAP	110
170672:	JMP	103144

; get an octal number in ASCII form pointed to by r1 to r0
170676:	CLR	R0
170700:	CLR	R2
170702:	ASL	R0
170704:	ASL	R0
170706:	ASL	R0
170710:	BIS	R2,R0
170712:	TRAP	072		; get a character other than space to r2
170714:	TRAP	070		; is r2 a digit?
170716:	BNE	170726		; branch if r2 is not a decimal digit
170720:	SUB	#060,R2
170724:	BR	170702
170726:	RETURN

; command BSAVE
170730:	CALL	120114		; save registers on the stack
170734:	MOV	#006406,R0
170740:	CALL	154310		; fetch the device and file name
170744:	TST	007510
170750:	BNE	170760
170752:	MOV	#DF6,007510
170760:	CALL	170676		; get an octal number to r0
170764:	MOV	R0,007512
170770:	BEQ	171164
170772:	CALL	170676		; get an octal number to r0
170776:	MOV	R0,007514
171002:	BEQ	171164
171004:	MOV	R0,R4
171006:	BIC	#1FF,R0
171012:	ASR	R0
171014:	SWAB	R0
171016:	BIC	#177000,R4
171022:	BEQ	171026
171024:	INC	R0
171026:	MOV	R0,006412
171032:	MOV	R3,-(SP)
171034:	MOV	006406,R3
171040:	CALL	157430		; check the memory module
171044:	MOV	(SP)+,R3
171046:	TST	007524		; memory module type
171052:	BEQ	171060		; skip if a RAM module
171054:	TRAP	161		; error 56 - file write protected
171056:	BR	171164
171060:	MOV	#006406,R0
171064:	MOVB	#002,000001(R0)	; write file
171072:	CALL	151126		; file access
171076:	BHIS	171104
171100:	TRAP	167		; error 59 - SMP overflow
171102:	BR	171164
171104:	MOV	006414,R0
171110:	SWAB	R0
171112:	ASL	R0
171114:	MOV	R0,007442
171120:	MOV	#004,R4
171124:	MOV	#F4A,R0
171130:	MOVB	(R0)+,R2
171132:	CALL	155564
171136:	SOB	R4,171130
171140:	MOV	007512,R0
171144:	MOV	007514,R4
171150:	MOVB	(R0)+,R2
171152:	CALL	155564
171156:	SOB	R4,171150
171160:	CALL	155644
171164:	CALL	120140		; restore registers from the stack
171170:	JMP	103276

; command BLOAD
171174:	CALL	120114		; save registers on the stack
171200:	CLR	007206
171204:	CLR	007200
171210:	MOV	#006406,R0
171214:	CALL	154310		; fetch the device and file name
171220:	TST	007510
171224:	BNE	171234
171226:	MOV	#DF6,007510
171234:	CALL	170676		; get an octal number to r0
171240:	MOV	R0,007206
171244:	DEC	R1
171246:	TRAP	072		; get a character other than space to r2
171250:	CMPB	R2,#054		; optional comma followed by the length
171254:	BEQ	171272
171256:	CMPB	R2,#012
171262:	BEQ	171302
171264:	CALL	120140		; restore registers from the stack
171270:	TRAP	075		; error 30 - wrong parameters
171272:	CALL	170676		; get an octal number to r0
171276:	MOV	R0,007200
171302:	MOV	#006406,R0
171306:	MOVB	#001,000001(R0)	; read file
171314:	CALL	151126		; file access
171320:	BHIS	171326
171322:	TRAP	175		; error 62 - file not found
171324:	BR	171636
171326:	MOV	006414,R0
171332:	MOV	006406,R3
171336:	CALL	153732		; convert the sector number in R0 to an address
171342:	MOV	#F4A,R2
171346:	MOV	#004,R5
171352:	MOV	#001,R1
171356:	CALL	153602
171362:	MOV	R5,-(SP)
171364:	JSR	R5,155074
171370:	.WORD	000001
171372:	MOV	(SP)+,R5
171374:	SOB	R5,171352
171376:	TST	007200
171402:	BNE	171450
171404:	MOV	007514,007200
171412:	MOV	R0,-(SP)
171414:	MOV	#171676,R0	; string 'DLINA: ' (length)
171420:	TRAP	066		; print a string pointed to by r0
171422:	CALL	142070		; r0 <- pointer to a zero terminated buffer
171426:	MOV	007200,R1
171432:	MOV	#006,R4		; number of digits
171436:	CALL	100032		; convert the word in r1 to octal ASCII
171442:	TRAP	066		; print a string pointed to by r0
171444:	TRAP	002		; print CR, LF
171446:	MOV	(SP)+,R0
171450:	TST	007426
171454:	BNE	171474
171456:	MOV	007200,R0
171462:	CALL	142342
171466:	BGT	171474
171470:	JMP	171646
171474:	MOV	007426,R2
171500:	SUB	007200,R2
171504:	CMP	006400,R2
171510:	BLE	171516
171512:	JMP	171646
171516:	TST	007206
171522:	BNE	171602
171524:	MOV	R0,-(SP)
171526:	MOV	#171664,R0	; string 'ADRES? '
171532:	TRAP	066		; print a string pointed to by r0
171534:	CALL	142070		; r0 <- pointer to a zero terminated buffer
171540:	MOV	006400,R1
171544:	MOV	#006,R4		; number of digits
171550:	CALL	100032		; convert the word in r1 to octal ASCII
171554:	TRAP	066		; print a string pointed to by r0
171556:	TRAP	002		; print CR, LF
171560:	CALL	137472		; wait for a key
171564:	MOV	(SP)+,R0
171566:	CMPB	R2,#131		; 'Y'
171572:	BNE	171636
171574:	MOV	006400,007206
171602:	MOV	007206,R2
171606:	MOV	007200,R5
171612:	MOV	#001,R1
171616:	CALL	153602
171622:	MOV	R5,-(SP)
171624:	JSR	R5,155074
171630:	.WORD	000001
171632:	MOV	(SP)+,R5
171634:	SOB	R5,171612
171636:	CALL	120140		; restore registers from the stack
171642:	JMP	103276
171646:	CLR	007426
171652:	MOV	006400,SP
171656:	CALL	120140		; restore registers from the stack
171662:	TRAP	001		; error 0 - out of memory

171660:	AE AC 01 89  0E 61 64 72  65 73 3F 20  0F 00 0E 64  .,...adres? ...d
171700:	6C 69 6E 61  3A 20 0F 00  E4 2B D3 84  E4 75 48 40  lina: ..d+S.duH@
171720:	00 04 47 D0  40 08 88 82  08 24 10 41  11 10 02 0B  ..GP@....$.A....
171740:	E2 20 38 47  D3 C5 36 29  8A F8 A5 C5  31 3A 94 A0  b 8GSE6).x%E1:. 
171760:	01 09 57 13  E4 21 2A E2  00 00 00 00  00 00 00 00  ..W.d!*b........
172000:	00 47 54 84  27 DD 57 14  C5 2E 29 8A  FC A5 00 00  .GT.']W.E.).|%..
172020:	C6 11 00 00  00 06 30 00  4F D2 00 00  12 FC 80 00  F.....0.OR...|..
172040:	00 FF FF FF  FF FF FF FF  FF FF 00 00  00 00 00 00  ................
172060:	00 00 77 FF  DD FF 77 FF  DD FF 80 00  08 00 80 00  ..w.].w.].......
172100:	08 00 77 DD  77 DD 77 DD  77 DD 88 00  22 00 88 00  ..w]w]w]w].."...
172120:	22 00 AA 55  AA 55 AA 55  AA 55 88 22  88 22 88 22  ".*U*U*U*U."."."
172140:	88 22 55 FF  55 FF 55 FF  55 FF AA 00  AA 00 AA 00  ."U.U.U.U.*.*.*.
172160:	AA 00 AA AA  AA AA AA AA  AA AA FF 00  FF 00 FF 00  *.********......
172200:	FF 00 BB 77  EE DD BB 77  EE DD 44 88  11 22 44 88  ..;wn];wn]D.."D.
172220:	11 22 88 88  88 88 88 88  88 88 00 00  FF 00 00 00  ."..............
172240:	FF 00 B1 30  03 1B D8 C0  0C 8D 20 40  80 01 02 04  ..10..X@.. @....
172260:	08 10 80 04  40 08 01 20  02 10 AA 00  80 00 88 00  ....@.. ..*.....
172300:	80 00 88 88  88 FF 88 88  88 FF 08 08  08 FF 08 08  ................
172320:	08 08 80 80  80 FF 08 08  08 FF 20 40  80 C1 22 1C  .......... @.A".
172340:	08 10 00 00  00 80 00 00  00 00 AA 00  88 14 22 41  ..........*..."A
172360:	88 00 20 40  80 00 08 04  02 00 40 A0  00 00 04 0A  .. @......@ ....
172400:	00 00 10 28  44 93 44 28  10 10 08 1C  24 42 C1 60  ...(D.D(....$BA`
172420:	10 08 E2 44  2E 1F 8E 44  E8 F1 80 80  41 3E 08 08  ..bD...Dhq..A>..
172440:	14 E3 AA 50  20 20 AA 05  02 02 10 20  54 AA FF 02  .c*P  *.... T*..
172460:	04 08 50 28  44 92 29 52  25 88 77 98  F8 F8 77 89  ..P(D.)R%.w.xxw.
172500:	8F 8F 16 16  F7 00 F7 F7  16 16 10 28  54 AA 54 28  ....w.ww...(T*T(
172520:	10 00 22 11  88 44 22 11  88 44 DD EE  77 BB DD EE  .."..D"..D]nw;]n
172540:	77 BB 66 99  99 66 66 99  99 66 77 DD  AA DD 77 DD  w;f..ff..fw]*]w]
172560:	AA DD 88 22  55 22 88 22  55 22 DD 44  77 11 DD 44  *]."U"."U"]Dw.]D
172600:	77 11 CC 33  CC 33 CC 33  CC 33 22 55  88 88 88 55  w.L3L3L3L3"U...U
172620:	22 22 FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF  ""..............

; system restart
173000:	MOV	#001000,SP
173004:	MOV	#001000,@#164034	; system ROM enabled
173012:	MOV	#005000,@#164032	; RAM address range 000000-077777, 164000-165777
				; ROM address range 100000-157777, 166000-176777
173020:	BIT	#000400,@#165032	; RTC register D, valid data?
173026:	BEQ	173060		; branch if not
173030:	MOV	@#165036,R0	; RTC user RAM, address 0F
173034:	ASR	R0
173036:	SWAB	R0
173040:	CLRB	R0
173042:	MOV	@#165034,R1	; RTC user RAM, address 0E
173046:	ASR	R1
173050:	BISB	R1,R0
173052:	CLR	-(SP)
173054:	MOV	R0,-(SP)
173056:	RTI
;
173060:	MOV	#166140,@#165034	; 30 shl 1 -> RTC user RAM, address 0E
173066:	MOV	#000754,@#165036	; F6 shl 1 -> RTC user RAM, address 0F
173074:	CALL	145154		; RAM initialisation
173100:	CALL	174146		; LCD controller initialisation
173104:	MOV	#173772,@#310	; keyboard controller interrupt vector
173112:	CLR	@#312
173116:	MOV	#000066,@#164022
173124:	MOV	#352,@#164024
173132:	CALL	122324
173136:	MOV	#020,006120
173144:	MOV	#034,006506
173152:	MOV	#174640,R0	; string "ELEKTRONIKA"
173156:	CALL	174562		; print a string pointed to by r0
173162:	CLR	006506
173166:	CLR	006120
173172:	BIS	#040,006534
173200:	MOV	#174705,R0	; string "="
173204:	CALL	174562		; print a string pointed to by r0
173210:	BIC	#040,006534
173216:	MOV	#010,006120
173224:	CLR	006506
173230:	MOV	#174711,R0
173234:	CALL	174562		; print a string pointed to by r0
173240:	MOV	#030,006120
173246:	CLR	006506
173252:	MOV	#174711,R0
173256:	CALL	174562		; print a string pointed to by r0
173262:	MOV	#040,006120
173270:	CLR	006506
173274:	MOV	#174705,R0
173300:	CALL	174562		; print a string pointed to by r0
173304:	MOV	#003,R3
173310:	CLR	R2
173312:	MOV	173554(R2),006506
173320:	MOV	173546(R2),006120
173326:	MOV	174554(R2),R0
173332:	CALL	174562		; print a string pointed to by r0
173336:	TST	(R2)+
173340:	SOB	R3,173312
173342:	MOV	#004,R1
173346:	MOV	173554(R1),006506
173354:	MOV	173546(R1),006120
173362:	CALL	173576
173366:	ASR	R1
173370:	CALL	173756		; wait for a key
173374:	CMPB	R0,#273		; cursor right?
173400:	BEQ	173436
173402:	CMPB	R0,#133		; cursor left?
173406:	BEQ	173510
173410:	CMPB	R0,#373		; key VK (enter) ?
173414:	BEQ	173524
173416:	CMPB	R0,#123		; key T ?
173422:	BNE	173430
173424:	JMP	@#160124	; tests
173430:	CALL	174036		; make a beep when unsupported key pressed
173434:	BR	173370

; cursor right (on the welcome screen)
173436:	MOV	R1,R0
173440:	INC	R0
173442:	CMP	R1,#002
173446:	BLT	173452
173450:	CLR	R0
173452:	ASL	R1
173454:	CALL	173576
173460:	MOV	R0,R1
173462:	ASL	R1
173464:	MOV	173546(R1),006120
173472:	MOV	173554(R1),006506
173500:	CALL	173576
173504:	ASR	R1
173506:	BR	173370

; cursor left (on the welcome screen)
173510:	MOV	R1,R0
173512:	DEC	R0
173514:	BPL	173452
173516:	ADD	#003,R0
173522:	BR	173452

; enter (on the welcome screen)
173524:	CLR	R0
173526:	ASR	R1
173530:	ADC	R0
173532:	ASL	R1
173534:	RESET
173536:	JMP	@173542(R1)

173542:	.WORD	174164		; boot from the SMP
173544:	.WORD	174534		; start the BASIC system
173546:	.WORD	000070, 000070, 000070
173554:	.WORD	000056, 000114, 000004, 000031, 000031
173564:	.WORD	000045, 000011, 000011, 000011, 010146

173576:	MOV	R1,-(SP)
173600:	MOV	006506,-(SP)
173604:	DEC	006506
173610:	MOV	R0,-(SP)
173612:	MOVB	#002,006126
173620:	MOV	173562(R1),R3
173624:	BEQ	173706
173626:	MOV	173570(R1),R2
173632:	BEQ	173706
173634:	MOV	#177400,R1
173640:	MOV	R3,R4
173642:	BIC	#177770,R4
173646:	ASH	#177775,R3
173652:	BEQ	173670
173654:	CALL	173724
173660:	ADD	#010,006506
173666:	SOB	R3,173654
173670:	MOV	#010,R0
173674:	SUB	R4,R0
173676:	ASH	R0,R1
173700:	BEQ	173706
173702:	CALL	173724
173706:	MOV	(SP)+,R0
173710:	MOV	(SP)+,006506
173714:	MOV	(SP)+,R1
173716:	CLRB	006126
173722:	RETURN
173724:	MOV	R2,R5
173726:	MOV	006120,-(SP)
173732:	DEC	006120
173736:	CALL	121436		; plot a dot
173742:	INC	006120
173746:	SOB	R5,173736
173750:	MOV	(SP)+,006120
173754:	RETURN

; wait for a key, return the row and column of a pressed key in r0
173756:	MTPS	#000
173762:	WAIT
173764:	MOV	@#054,R0
173770:	RETURN

; keyboard interrupt service routine
173772:	MOV	#362,@#164024
174000:	CLR	@#164026	; start of the transfer
174004:	TSTB	@#164024
174010:	BPL	174004
174012:	MOV	@#164026,@#054	; key scan code, end of the transfer
174020:	TSTB	@#164024
174024:	BPL	174020
174026:	MOV	#352,@#164024
174034:	RTI

; make a warning beep
174036:	MOV	#100,R0		; sound duration, 64 * 8 / 660Hz = 0.8 sec.
174042:	MOV	#173772,@#310	; keyboard controller interrupt vector
174050:	CLR	@#312
174054:	MOV	#373,@#164024
174062:	MOV	#002274,@#164022	; 660Hz
174070:	CLR	@#164026	; start of the transfer
174074:	TSTB	@#164024
174100:	BPL	174074
174102:	CLR	@#164020	; dummy data to emit 8 clock cycles
174106:	TSTB	@#164024
174112:	BPL	174106
174114:	SOB	R0,174102
174116:	TST	@#164026	; end of the transfer
174122:	TSTB	@#164024
174126:	BPL	174122
174130:	MOV	#352,@#164024
174136:	MOV	#000066,@#164022
174144:	RETURN

; LCD controller initialisation
174146:	MOV	006402,@#164000	; address of the display RAM
174154:	MOV	#104306,@#164002
174162:	RETURN

; boot from the SMP, r0 selects between the SMP0/1
174164:	MOV	#000011,@#164022	; transfer rate
174172:	MOV	#164024,R1	; control/status register
174176:	MOV	#000370,R5	; writing to the SMP
174202:	ADD	R0,R5
174204:	MOV	#174546,R2	; procedure 'wait for the transfer completed'
174210:	MOV	R5,(R1)
174212:	CLR	@#164026	; Read Status
174216:	CALL	(R2)
174220:	BIC	#010,R5		; reading from the SMP
174224:	MOV	R5,(R1)
174226:	MOV	@#164026,R3	; read from the SMP, end of the transfer
174232:	CALL	(R2)
; test whether the password protection is active
174234:	TSTB	R3
174236:	BPL	174356		; branch if inactive password protection
; test the attempt counter
174240:	ASLB	R3
174242:	BPL	174250		; less than 3 attempts counted, try to unlock
174244:	ASLB	R3
174246:	BMI	174470		; three attempts counted, don't even try
;
; the password protection is active,
; an attempt to unlock the memory module
174250:	BIS	#010,R5		; writing to the SMP
174254:	MOV	R5,(R1)
174256:	MOV	#250,@#164026	; Write Address
174264:	CALL	(R2)
174266:	CLR	@#164020
174272:	CALL	(R2)
174274:	CLR	@#164020	; high address byte
174300:	CALL	(R2)
174302:	CLR	@#164020	; low address byte
174306:	CALL	(R2)
174310:	TST	@#164026	; end of the transfer
174314:	CALL	(R2)
;
174316:	MOV	#230,@#164026	; Unlock
174324:	CALL	(R2)
174326:	MOV	#174630,R4	; password A0 00 A0 00 A0 00 A0 00
174332:	MOV	#010,R3
174336:	MOVB	(R4)+,@#164020
174342:	CALL	(R2)
174344:	SOB	R3,174336
174346:	TST	@#164026	; end of the transfer
174352:	CALL	(R2)
174354:	BR	174172		; back to the begin of the boot routine
;
; the password protection is inactive,
; continue with boot sector loading
174356:	BIS	#010,R5		; writing to the SMP
174362:	MOV	R5,(R1)
174364:	MOV	#250,@#164026	; Write Address
174372:	CALL	(R2)
174374:	CLR	@#164020
174400:	CALL	(R2)
174402:	CLR	@#164020	; high address byte
174406:	CALL	(R2)
174410:	CLR	@#164020	; low address byte
174414:	CALL	(R2)
174416:	TST	@#164026	; end of the transfer
174422:	CALL	(R2)
; read the SMP boot sector to the RAM 0000..01FF
174424:	MOV	#001000,R4	; number of bytes
174430:	CLR	R3		; destination address
174432:	MOV	#330,@#164026	; Read Postincrement
174440:	CALL	(R2)
174442:	BIC	#010,R5		; reading from the SMP
174446:	MOV	R5,(R1)
174450:	CALL	(R2)
174452:	MOVB	@#164020,(R3)+	; read data byte from the SMP to the RAM
174456:	CALL	(R2)
174460:	SOB	R4,174452	; next data byte
174462:	TST	@#164026	; end of the transfer
174466:	CALL	(R2)
;
174470:	CMPB	#240,@#000000	; test for instruction NOP at address 0000
174476:	BNE	174524
174500:	MOV	#010000,@#164032	; RAM address range 0000-3FFF, E800-EBFF
				;ROM address range 4000-DFFF, EC00-FDFF
174506:	TST	@#164036
174512:	BMI	174522
174514:	MOV	#020000,@#164200
174522:	CLR	PC		; start the program from address 0000
;
174524:	CALL	174036	; make a beep when wrong bootloader code
174530:	JMP	173000		; system restart

174534:	MOV	#010000,@#164032	; RAM address range 0000-3FFF, E800-EBFF
				; ROM address range 4000-DFFF, EC00-FDFF
174542:	JMP	@#117716	; start the BASIC system

174546:	TSTB	(R1)
174550:	BPL	174546
174552:	RETURN

174554:	.WORD	174656, 174665, 174674

; print a zero terminated string pointed to by r0
174562:	MOVB	(R0)+,006132
174566:	MOVB	(R0)+,006130
174572:	MOV	006104,006110
174600:	MOV	#001,006126
174606:	MOV	R2,-(SP)
174610:	CLR	R2
174612:	MOVB	(R0)+,R2
174614:	BEQ	174624
174616:	CALL	120156
174622:	BR	174610
174624:	MOV	(SP)+,R2
174626:	RETURN

174630:	A0 00 A0 00 A0 00 A0 00

174640:	01 01 7C 6C  65 6B 74 72  6F 6E 69 6B  61 00	..|lektronika.
174656:	01 01 73 6D 70 30  00	..smp0.
174665:	01 01 73  6D 70 31 00	..smp1.
174674:	01 01 62 65 6A 73 69 6B 00	..bejsik.
174705:	18 01 3D 00
174711:	18 01 7F 00
174715:	.EVEN

; font data, 35 bits for each character (width = 5 pixels, height = 7 pixels)

; character codes 0x20-0x3F
174716:	                                             00 00
174720:	00 00 04 21  08 40 11 4A  00 00 00 29  5F 57 D4 A8
174740:	BA 31 8B A3  8C 88 88 98  D1 4A 22 B2  69 84 40 00
174760:	00 11 10 84  10 48 20 84  22 20 04 AB  AA 40 00 84
175000:	F9 08 00 00  0C 61 10 00  03 E0 00 00  00 00 0C 60
175020:	02 22 22 00  74 67 5C C5  C4 61 08 42  39 D1 08 88
175040:	8F FC 44 10  62 E1 19 52  F8 85 F8 78  21 8B 8C 88
175060:	7A 31 77 C2  22 21 08 74  62 E8 C5 CE  8C 5E 11 30
175100:	0C 60 18 C0  01 8C 03 08  81 11 10 41  04 00 7C 1F
175120:	00 10 41 04  44 43 A2 11  10 04 00 00

; Latin characters, codes 0x40-0x7F
175134:	                                       74 6F 5B C1
175140:	E4 54 63 F8  C7 D1 8F A3  1F 3A 30 84  22 EE 4A 31
175160:	8C B9 F8 43  D0 87 FF 08  7A 10 83 A3  0B C6 2F 8C
175200:	63 F8 C6 2E  21 08 42 38  E2 10 85 26  46 54 C5 25
175220:	18 42 10 84  3F 1D D6 B1  8C 63 1C D6  71 8B A3 18
175240:	C6 2E F4 63  E8 42 0E 8C  63 59 37 D1  8F A9 28 BA
175260:	30 70 62 EF  90 84 21 09  18 C6 31 8B  A3 18 C6 2A
175300:	24 63 1A D6  AA 8C 54 45  46 31 8C 54  42 13 E1 11
175320:	11 0F B9 08  42 10 E0 41  04 10 40 E1  08 42 13 80
175340:	00 7C 20 00  00 00 00 1F  22 18 00 00  00 07 82 F8
175360:	BE 10 F4 63  1F 00 0F 84  20 F0 85 F1  8C 5E 00 3A
175400:	3F 83 C6 42  7C 84 20 00  F8 BC 2E 84  3D 18 C6 24
175420:	03 08 42 38  80 61 08 4C  42 12 A6 29  26 10 84 21
175440:	1C 00 6A B5  AD 40 0F 46  31 88 00 E8  C6 2E 00 3D
175460:	1F 42 00 03  E2 F0 84 00  B6 21 08 00  0F 83 83 E2
175500:	13 E4 21 06  00 46 31 8B  C0 08 C6 2A  20 01 18 D6
175520:	AA 00 22 A2  2A 20 04 62  F0 B8 00 F8  88 8F 8C 84
175540:	41 08 32 10  84 21 09 82  10 44 26 3E  00 00 00 07
175560:	FF FF FF FF  00 00

; Cyrillic characters, codes 0x40-0x7F
175566:	                   00 25  5E D6 40 07  82 F8 BC 2E
175600:	87 A3 17 00  12 94 BE 10  01 CA 57 E2  00 3A 3F 83
175620:	C0 07 56 AE  20 01 E8 42  10 00 22 A2  2A 20 04 67
175640:	5C C4 00 AC  EB 98 80 12  A6 29 20 00  E5 2D 52 00
175660:	47 75 8C 40  08 C7 F1 88  00 E8 C6 2E  00 3F 18 C6
175700:	20 03 E2 F2  E4 00 F4 7D  08 00 0F 84  20 F0 03 E4
175720:	21 08 00 46  2F 0B 80 0A  B9 D5 A8 01  E8 FA 3E 00
175740:	21 0F 47 C0  04 63 D9 F4  00 74 4D 17  00 15 AD 6B
175760:	F0 03 C1 38  7C 00 56 B5  F8 40 08 C5  E1 08 01 84
176000:	39 2E 95 6B  DA D6 44 54  63 F8 C7 F0  F4 63 1F 4A
176020:	52 94 BE 17  29 4A 57 E3  F8 43 F0 87  DD 5A D6 AE
176040:	27 E1 08 42  10 8C 54 45  46 31 8C EB  98 C6 B5 9D
176060:	73 18 C6 54  C5 25 17 94  A5 2D 53 1D  D6 B1 8C 63
176100:	18 FE 31 8B  A3 18 C6 2E  FC 63 18 C6  2F 8C 5E 54
176120:	C7 D1 8F A1  08 3A 30 84  22 EF 90 84  21 09 18 C5
176140:	E1 8B AB 57  3A B5 AF A3  1F 46 3E 84  21 E8 C7 D1
176160:	8C 7B 39 F5  D1 09 83 17  56 B5 AD 6B  F7 44 2F 0C
176200:	5D 5A D6 B5  F8 63 18 BC  21 0F FF FF  FF FF
